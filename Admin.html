<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tennis Admin Panel - DataStore Integrated</title>
  <link rel="icon" href="data:,">
  <script src="https://cdn.tailwindcss.com"></script>

</head>
<body>
  <div id="root"></div>
  
  <!-- React -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Shared utils (schema + helpers; no UI changes) -->
  <script src="./shared-utils.js"></script>
  <script src="./shared/config.js"></script>
  <script src="./shared/storage.js"></script>
  <script src="./shared/events.js"></script>
  <script src="./shared/datastore.js"></script>
  <script src="./shared/maintenance.js"></script>
  <script src="./shared/dataservice.js"></script>
  <script src="./shared/blocks.js"></script>

  <script>
(function () {
  if (location.protocol !== 'file:') return;

  console.warn('[dev] Loaded via file:// — this uses a different storage and won\'t receive app events.');

  function addBanner() {
    var b = document.createElement('div');
    b.style.cssText = 'position:fixed;left:0;right:0;bottom:0;padding:8px 12px;' +
                      'background:#f59e0b;color:#111;font:600 14px/1.2 system-ui;' +
                      'z-index:99999;text-align:center';
    b.textContent = '⚠️ Running from file:// — use http://127.0.0.1:5500 for correct behavior';
    document.body.appendChild(b);
  }

  if (document.body) addBanner();
  else window.addEventListener('DOMContentLoaded', addBanner, { once: true });
})();
</script>

  <script src="./domain/time.js"></script>
  <script src="./domain/blocks.js"></script>
  <script src="./domain/wetCourts.js"></script>
  <script src="./domain/availability.js"></script>
  <script src="./shared/domain/roster.js"></script>
  <script src="shared/selftest.js"></script>
  <!-- Preflight self-heal (normalize storage shape before app code runs) -->
  <script>try{ window.APP_UTILS && window.APP_UTILS.readDataSafe(); }catch(e){}</script>
  
  <!-- Lucide React Icons -->


  <!-- All code in one file -->
  <script type="text/babel">
   // Access shared utils (optional convenience)
   const U = window.APP_UTILS || {};
   // --- One-time guard helper (no UI change)
   const _one = (key) => (window[key] ? true : (window[key] = true, false));
   
   // Idempotent coalescer
   (function () {
     if (window.scheduleAdminRefresh) return;

     window.__adminRefreshPending = false;
     window.__adminCoalesceHits = 0; // dev-only metric

     window.scheduleAdminRefresh = function scheduleAdminRefresh() {
       if (window.__adminRefreshPending) return;
       window.__adminRefreshPending = true;

       setTimeout(() => {
         try {
           window.__adminCoalesceHits++;
           const fn =
             window.refreshAdminView ||
             window.loadData ||
             null;

           if (typeof fn === 'function') {
             fn();                           // direct path
             return;
           }
           // bridge path
           window.dispatchEvent(new Event('ADMIN_REFRESH'));
         } finally {
           window.__adminRefreshPending = false;
         }
       }, 0);
     };
   })();

   // Idempotent wiring (window + document, just in case)
   (function wireAdminListenersOnce(){
     if (window.__wiredAdminListeners) return;
     window.__wiredAdminListeners = true;

     const h = window.scheduleAdminRefresh;
     if (typeof h !== 'function') return;

     window.addEventListener('tennisDataUpdate', h, { passive: true });
     window.addEventListener('DATA_UPDATED',      h, { passive: true });
     window.addEventListener('BLOCKS_UPDATED',    h, { passive: true });

     // backup (some environments dispatch on document)
     document.addEventListener('tennisDataUpdate', h, { passive: true });
     document.addEventListener('DATA_UPDATED',      h, { passive: true });
     document.addEventListener('BLOCKS_UPDATED',    h, { passive: true });
   })();
   
   // Shared domain modules
   const USE_SHARED_DOMAIN = true;
   const WC = window.Tennis.Domain.wetCourts || window.Tennis.Domain.WetCourts;
   const Storage = window.Tennis.Storage;
   const Events = window.Tennis.Events;
   const BL = window.Tennis.Domain.blocks || window.Tennis.Domain.Blocks; // handle both names
   
   // ---- Storage & Event keys (constants; no behavior change) ----
   const STORAGE = {
     DATA: 'tennisClubData',
     SETTINGS: 'tennisClubSettings',
     BLOCKS: 'courtBlocks',
     UPDATE_TICK: 'tennisDataUpdateTick'
   };
   const EVENTS = {
     UPDATE: 'tennisDataUpdate'
   };
   
   // ---- JSON storage helpers (pure wrappers; no behavior change) ----
   const readJSON = (key) => {
     try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : null; }
     catch { return null; }
   };
   const writeJSON = (key, val) => {
     try { localStorage.setItem(key, JSON.stringify(val)); return true; }
     catch { return false; }
   };
   
   // ---- Safe defaults for app data (no behavior change) ----
   const getEmptyData = () => ({
     courts: Array(12).fill(null),
     waitingGroups: [],
     recentlyCleared: [],
     calculatedAvailability: null
   });
   
   const readDataSafe = () => readJSON(STORAGE.DATA) || getEmptyData();
   
   // ---- Core constants (declared only; not replacing existing usages) ----
   const APP = {
     COURT_COUNT: 12,
     PLAYERS: { MIN: 1, MAX: 4 },
     DURATION_MIN: { SINGLES: 60, DOUBLES: 90, MAX: 240 }
   };
   
   // ---- Dev flag & assert (no UI change) ----
   const DEV = (typeof location !== 'undefined') && /localhost|127\.0\.0\.1/.test(location.host);
   const assert = (cond, msg, obj) => { if (DEV && !cond) console.warn('ASSERT:', msg, obj||''); };
   
   // ---- Debounce helper (no UI change) ----
   const debounce = (fn, ms=150) => { let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };
   
   // ---- Logger (no UI change) ----
   const LOG_LEVEL = (DEV ? 'debug' : 'warn');
   const _PREFIX = '[Admin]';
   const log = {
     debug: (...a)=> { if (['debug'].includes(LOG_LEVEL)) console.debug(_PREFIX, ...a); },
     info:  (...a)=> { if (['debug','info'].includes(LOG_LEVEL)) console.info(_PREFIX, ...a); },
     warn:  (...a)=> { if (['debug','info','warn'].includes(LOG_LEVEL)) console.warn(_PREFIX, ...a); },
   };
   
   // central registry for timers in this view  
   const _timers = [];
   const addTimer = (id, type = 'interval') => { _timers.push({ id, type }); return id; };
   const clearAllTimers = () => {
     _timers.forEach(({id, type}) => {
       try { 
         if (type === 'interval') clearInterval(id);
         else clearTimeout(id);
       } catch {} 
     });
     _timers.length = 0;
   };
   
   // Global cleanup on page unload
   window.addEventListener('beforeunload', () => {
     try { clearAllTimers(); } catch {}
   });
   
   // Wait for everything to load
   window.addEventListener('load', () => {
      console.log('Window loaded, checking dependencies...');
      log.debug('React:', typeof React);
      log.debug('ReactDOM:', typeof ReactDOM);
      
      // Add a small delay to ensure Lucide is fully loaded
      addTimer(setTimeout(() => {
        initializeApp();
      }, 100), 'timeout');
    });
    
    // ============================================================
    // Section: Admin actions (assign, clear, block scheduling)
    // ============================================================
    
    function initializeApp() {
      // Boot data assertion
      const _bootData = (U.readDataSafe ? U.readDataSafe() : (readJSON(STORAGE.DATA) || getEmptyData()));
      assert(!_bootData || Array.isArray(_bootData.courts), 'Expected data.courts array on boot', _bootData);
      
      const React = window.React;
      const ReactDOM = window.ReactDOM;
      const { useState, useEffect, useCallback, useMemo, memo, useRef } = React;
      
      // DataStore Integration
      class TennisCourtDataStore {
        constructor() {
          this.cache = new Map();
          this.metrics = {
            cacheHits: 0,
            cacheMisses: 0,
            totalOperations: 0,
            totalResponseTime: 0,
            storageOperationsSaved: 0
          };
          
          // Initialize immediately
          this.warmCache();
        }

        warmCache() {
          const keys = ['tennisClubData', 'tennisClubSettings', 'tennisBlockTemplates', 'tennisRecurringBlocks', 'tennisBallPurchases', 'tennisAnalytics', 'courtBlocks', 'tennisGuestCharges'];
          keys.forEach(key => {
            const data = localStorage.getItem(key);
            if (data) {
              try {
                this.cache.set(key, JSON.parse(data));
              } catch (e) {
                console.warn(`Failed to parse ${key}:`, e);
              }
            }
          });
        }

        async get(key) {
          const startTime = performance.now();
          this.metrics.totalOperations++;
          
          if (this.cache.has(key)) {
            this.metrics.cacheHits++;
            const responseTime = performance.now() - startTime;
            this.metrics.totalResponseTime += responseTime;
            return this.cache.get(key);
          }
          
          this.metrics.cacheMisses++;
          this.metrics.storageOperationsSaved++;
          
          const data = localStorage.getItem(key);
          let parsed = null;
          if (data) {
            try {
              parsed = JSON.parse(data);
              this.cache.set(key, parsed);
            } catch (e) {
              console.warn(`Failed to parse ${key}:`, e);
            }
          }
          
          const responseTime = performance.now() - startTime;
          this.metrics.totalResponseTime += responseTime;
          return parsed;
        }

        async set(key, data, options = {}) {
          const startTime = performance.now();
          this.metrics.totalOperations++;
          
          this.cache.set(key, data);
          
          if (options.immediate || key === 'tennisClubData' || key === 'courtBlocks') {
            localStorage.setItem(key, JSON.stringify(data));
          }
          
          const responseTime = performance.now() - startTime;
          this.metrics.totalResponseTime += responseTime;
          
          // Dispatch update event
          window.dispatchEvent(new CustomEvent(EVENTS.UPDATE, { detail: { key, data } }));
        }

        getMetrics() {
          const avgResponseTime = this.metrics.totalOperations > 0 
            ? this.metrics.totalResponseTime / this.metrics.totalOperations 
            : 0;
          
          const cacheHitRate = this.metrics.totalOperations > 0 
            ? (this.metrics.cacheHits / this.metrics.totalOperations) * 100 
            : 0;

          return {
            ...this.metrics,
            avgResponseTime: parseFloat(avgResponseTime.toFixed(3)),
            cacheHitRate: parseFloat(cacheHitRate.toFixed(1))
          };
        }
      }

      // Initialize DataStore
      const dataStore = new (window.APP_UTILS?.TennisCourtDataStore || class {})();
      
    // For the regular Lucide library, we'll create simple icon components

     
      // Continue with all your component code here... 
    // ============================================
    // PASTE YOUR AdminPanelV2 COMPONENT CODE HERE
    // (Remove the imports and export statements)
    // Start from "// Utility Functions" and paste everything until just before "export default AdminPanelV2"
    // ============================================


    // Temporary: Emojis

    // Tennis-themed Emoji Icons
const Calendar = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>📅</span>;
const Clock = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>⏰</span>;
const Users = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>👥</span>;
const Settings = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>⚙️</span>;
const AlertCircle = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>⚠️</span>;
const CheckCircle = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>✅</span>;
const ChevronLeft = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>◀️</span>;
const ChevronRight = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>▶️</span>;
const Copy = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>📋</span>;
const Trash2 = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🗑️</span>;
const Save = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>💾</span>;
const X = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>❌</span>;
const Plus = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>➕</span>;
const Grid = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>⊞</span>;
const List = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>📄</span>;
const Filter = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🔍</span>;
const RefreshCw = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🔄</span>;
const BarChart = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>📊</span>;
const Download = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>⬇️</span>;
const FileText = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>📄</span>;
const TrendingUp = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>📈</span>;
const Activity = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>⚡</span>;
const Wrench = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🔧</span>;
const Droplets = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>💧</span>;
const GraduationCap = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🎓</span>;
const Trophy = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🏆</span>;
const Star = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>⭐</span>;
const Edit = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>✏️</span>;
const Edit2 = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>✏️</span>;
const Edit3 = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>✏️</span>;
const Grid3X3 = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>⊞</span>;
const Calendar2 = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>📅</span>;
const CalendarDays = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🗓️</span>;
const ChevronDown = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🔽</span>;
const ChevronUp = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🔼</span>;
const MoreHorizontal = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>⋯</span>;
const Play = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>▶️</span>;
const Pause = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>⏸️</span>;
const Square = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>⏹️</span>;
const AlertTriangle = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>⚠️</span>;
const EyeOff = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>👁️</span>;
const Eye = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>👁️</span>;
const Move = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🔄</span>;
const TennisBall = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🎾</span>;
const Court = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🏟️</span>;
const Bot = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🤖</span>;
const Check = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>✔️</span>;
const MessageCircle = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>💬</span>;
const greyFilter = { filter: 'grayscale(100%) opacity(0.6)' };

// Configuration (will be imported from main app)
const TENNIS_CONFIG = {
  COURTS: { TOTAL_COUNT: 12 },
  TIMING: {
    CLUB_OPEN: 4,
    CLUB_CLOSE: 22,
    AVG_GAME_TIME_MIN: 75
  },
  STORAGE: {
  KEY: 'tennisClubData',
  UPDATE_EVENT: 'tennisDataUpdate',
  SETTINGS_KEY: 'tennisClubSettings',
  BLOCK_TEMPLATES_KEY: 'tennisBlockTemplates',
  RECURRING_BLOCKS_KEY: 'tennisRecurringBlocks',
  BALL_SALES_KEY: 'tennisBallPurchases',  // ADD THIS LINE
  ANALYTICS_KEY: 'tennisAnalytics',  // ALSO ADD THIS LINE while you're at it
  GUEST_CHARGES_KEY: 'tennisGuestCharges'  // For tracking guest fees
},
  PRICING: {
    TENNIS_BALLS: 5.50
  }
};

// Utility Functions
const formatTime = (date) => {
  return date.toLocaleTimeString('en-US', { 
    hour: 'numeric', 
    minute: '2-digit',
    hour12: true 
  });
};

const formatDate = (date) => {
  return date.toLocaleDateString('en-US', { 
    weekday: 'short',
    month: 'short', 
    day: 'numeric' 
  });
};

const getDayOfWeek = (date) => {
  const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  return days[date.getDay()];
};

// Block Template Management
const BlockTemplateManager = ({ templates, onSave, onDelete, onApply }) => {
  const [showCreate, setShowCreate] = useState(false);
  const [newTemplate, setNewTemplate] = useState({
    name: '',
    reason: '',
    duration: 60,
    courts: []
  });

  const handleSave = () => {
    if (newTemplate.name && newTemplate.reason && newTemplate.courts.length > 0) {
      onSave({
        ...newTemplate,
        id: Date.now().toString()
      });
      setNewTemplate({ name: '', reason: '', duration: 60, courts: [] });
      setShowCreate(false);
    }
  };

  return (
    <div className="bg-white rounded-lg shadow-sm p-4">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-semibold text-gray-800">Quick Templates</h3>
        <button
          onClick={() => setShowCreate(!showCreate)}
          className="text-blue-600 hover:text-blue-700 p-1"
        >
          <Plus size={20} />
        </button>
      </div>

      {showCreate && (
        <div className="mb-4 p-3 bg-gray-50 rounded-lg">
          <input
            type="text"
            placeholder="Template name"
            value={newTemplate.name}
            onChange={(e) => setNewTemplate({ ...newTemplate, name: e.target.value })}
            className="w-full mb-2 p-2 border rounded"
          />
          <input
            type="text"
            placeholder="Block reason"
            value={newTemplate.reason}
            onChange={(e) => setNewTemplate({ ...newTemplate, reason: e.target.value })}
            className="w-full mb-2 p-2 border rounded"
          />
          <div className="mb-2">
            <label className="text-sm text-gray-600">Duration (minutes)</label>
            <input
              type="number"
              value={newTemplate.duration}
              onChange={(e) => setNewTemplate({ ...newTemplate, duration: parseInt(e.target.value) })}
              className="w-full p-2 border rounded"
            />
          </div>
          <div className="mb-2">
            <label className="text-sm text-gray-600">Courts</label>
            <div className="grid grid-cols-6 gap-1">
              {[...Array(TENNIS_CONFIG.COURTS.TOTAL_COUNT)].map((_, i) => (
                <button
                  key={i}
                  onClick={() => {
                    const courts = newTemplate.courts.includes(i + 1)
                      ? newTemplate.courts.filter(c => c !== i + 1)
                      : [...newTemplate.courts, i + 1];
                    setNewTemplate({ ...newTemplate, courts });
                  }}
                  className={`p-1 text-xs rounded ${
                    newTemplate.courts.includes(i + 1)
                      ? 'bg-blue-500 text-white'
                      : 'bg-gray-200'
                  }`}
                >
                  {i + 1}
                </button>
              ))}
            </div>
          </div>
          <div className="flex gap-2">
            <button
              onClick={handleSave}
              className="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
            >
              Save
            </button>
            <button
              onClick={() => setShowCreate(false)}
              className="px-3 py-1 bg-gray-300 text-gray-700 rounded text-sm hover:bg-gray-400"
            >
              Cancel
            </button>
          </div>
        </div>
      )}

      <div className="space-y-2">
        {templates.map(template => (
          <div key={template.id} className="flex items-center justify-between p-2 bg-gray-50 rounded">
            <div>
              <div className="font-medium text-sm">{template.name}</div>
              <div className="text-xs text-gray-600">
                {template.reason} • {template.duration}min • Courts: {template.courts.join(', ')}
              </div>
            </div>
            <div className="flex gap-1">
              <button
                onClick={() => onApply(template)}
                className="p-1 text-green-600 hover:bg-green-50 rounded"
              >
                <CheckCircle size={16} />
              </button>
              <button
                onClick={() => onDelete(template.id)}
                className="p-1 text-red-600 hover:bg-red-50 rounded"
              >
                <Trash2 size={16} />
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

// Recurrence Configuration Component
const RecurrenceConfig = ({ recurrence, onRecurrenceChange }) => {
  const [pattern, setPattern] = useState(recurrence?.pattern || 'daily');
  const [frequency, setFrequency] = useState(recurrence?.frequency || 1);
  const [endType, setEndType] = useState(recurrence?.endType || 'after');
  const [occurrences, setOccurrences] = useState(recurrence?.occurrences || 7);
  const [endDate, setEndDate] = useState(recurrence?.endDate || '');

  useEffect(() => {
    onRecurrenceChange({
      pattern,
      frequency,
      endType,
      occurrences,
      endDate
    });
  }, [pattern, frequency, endType, occurrences, endDate]);

  return (
    <div className="bg-gray-50 rounded-lg p-4 space-y-3">
      <div className="flex gap-3">
        <div className="flex-1">
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Repeat Pattern
          </label>
          <select
            value={pattern}
            onChange={(e) => setPattern(e.target.value)}
            className="w-full p-2 border rounded-lg"
          >
            <option value="daily">Daily</option>
            <option value="weekly">Weekly</option>
            <option value="monthly">Monthly</option>
          </select>
        </div>
        <div className="flex-1">
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Every
          </label>
          <div className="flex items-center gap-2">
            <input
              type="number"
              min="1"
              max="30"
              value={frequency}
              onChange={(e) => setFrequency(parseInt(e.target.value) || 1)}
              className="w-20 p-2 border rounded-lg"
            />
            <span className="text-sm text-gray-600">
              {pattern === 'daily' ? 'day(s)' : pattern === 'weekly' ? 'week(s)' : 'month(s)'}
            </span>
          </div>
        </div>
      </div>

      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          End
        </label>
        <div className="space-y-2">
          <label className="flex items-center gap-2">
            <input
              type="radio"
              value="after"
              checked={endType === 'after'}
              onChange={(e) => setEndType(e.target.value)}
              className="text-blue-600"
            />
            <span className="text-sm">After</span>
            <input
              type="number"
              min="1"
              max="365"
              value={occurrences}
              onChange={(e) => setOccurrences(parseInt(e.target.value) || 1)}
              disabled={endType !== 'after'}
              className="w-20 p-1 border rounded text-sm"
            />
            <span className="text-sm">occurrences</span>
          </label>
          <label className="flex items-center gap-2">
            <input
              type="radio"
              value="date"
              checked={endType === 'date'}
              onChange={(e) => setEndType(e.target.value)}
              className="text-blue-600"
            />
            <span className="text-sm">On date</span>
            <input
              type="date"
              value={endDate}
              onChange={(e) => setEndDate(e.target.value)}
              disabled={endType !== 'date'}
              className="p-1 border rounded text-sm"
            />
          </label>
        </div>
      </div>
    </div>
  );
};

// BlockScheduler component removed - was unused legacy code
// All block scheduling now handled by CompleteBlockManagerEnhanced


// Court Status Grid - WITH WET COURT FUNCTIONALITY

const CourtStatusGrid = ({ courts, courtBlocks, selectedDate, onClearCourt, onMoveCourt, currentTime, onEditBlock, onEditGame, onEmergencyWetCourt, onClearAllCourts, wetCourtsActive, handleEmergencyWetCourt, deactivateWetCourts, wetCourts, onClearWetCourt, onClearAllWetCourts }) => {
  const [movingFrom, setMovingFrom] = useState(null);
  const [selectedCourt, setSelectedCourt] = useState(null);
  const [showActions, setShowActions] = useState(null);
  const [editingGame, setEditingGame] = useState(null);
  const [editingBlock, setEditingBlock] = useState(null);
  const [localWetCourts, setLocalWetCourts] = useState(new Set());
  const [refreshKey, setRefreshKey] = useState(0);
  const [refreshTick, setRefreshTick] = useState(0);

  React.useEffect(() => {
    const onUpdate = () => setRefreshTick(t => t + 1);
    document.addEventListener('DATA_UPDATED', onUpdate);
    document.addEventListener('tennisDataUpdate', onUpdate);
    return () => {
      document.removeEventListener('DATA_UPDATED', onUpdate);
      document.removeEventListener('tennisDataUpdate', onUpdate);
    };
  }, []);

  // Load wet court status on mount and poll for updates
  useEffect(() => {
    const checkWetCourts = async () => {
      const blocks = await dataStore.get('courtBlocks') || [];
      const wetCourtNumbers = new Set(
        blocks
          .filter(block => block.isWetCourt && new Date(block.endTime) > currentTime)
          .map(block => block.courtNumber)
      );
      setLocalWetCourts(wetCourtNumbers);
    };

    // Only use local polling if wetCourts prop is not provided
    if (!wetCourts) {
      checkWetCourts();
      const interval = addTimer(setInterval(checkWetCourts, 1000)); // Check every second
      return () => { try { clearInterval(interval); } catch {} };
    }
  }, [currentTime, refreshKey, wetCourts]);

  const getCourtStatus = (court, courtNumber) => {
    // Use prop wetCourts if available, otherwise use local state
    const activeWetCourts = wetCourts || localWetCourts;
    
    // Check if court is wet first
    if (activeWetCourts.has(courtNumber)) {
      return { 
        status: 'wet', 
        info: {
          reason: 'WET COURT',
          type: 'wet'
        }
      };
    }

    // Then check for blocks on the selected date
    const activeBlock = courtBlocks.find(block => {
      if (block.courtNumber !== courtNumber || block.isWetCourt) return false;
      const blockStart = new Date(block.startTime);
      const blockEnd = new Date(block.endTime);
      
      // Filter by selected date - show blocks that occur on the selected date
      const selectedDateStart = new Date(selectedDate);
      selectedDateStart.setHours(0, 0, 0, 0);
      const selectedDateEnd = new Date(selectedDate);
      selectedDateEnd.setHours(23, 59, 59, 999);
      
      // Check if block overlaps with selected date
      const blockOverlapsSelectedDate = blockStart < selectedDateEnd && blockEnd > selectedDateStart;
      if (!blockOverlapsSelectedDate) return false;
      
      // For today, show only currently active blocks
      // For other dates, show all blocks for that date
      if (selectedDate.toDateString() === new Date().toDateString()) {
        return currentTime >= blockStart && currentTime < blockEnd;
      } else {
        return true; // Show all blocks for non-today dates
      }
    });
    
    if (activeBlock) {
      return { 
        status: 'blocked', 
        info: {
          id: activeBlock.id,
          reason: activeBlock.reason,
          startTime: activeBlock.startTime,
          endTime: activeBlock.endTime,
          type: 'block',
          courtNumber: courtNumber
        }
      };
    }
    
    // Check if court has players
    if (court && court.players && court.players.length > 0) {
      const endTime = new Date(court.endTime);
      const isOvertime = currentTime > endTime;
      
      return {
        status: isOvertime ? 'overtime' : 'occupied',
        info: {
          players: court.players,
          startTime: court.startTime,
          endTime: court.endTime,
          duration: court.duration,
          type: 'game',
          courtNumber: courtNumber
        }
      };
    }
    
    // Check for current session
    if (court && court.current && court.current.players && court.current.players.length > 0) {
      const endTime = new Date(court.current.endTime);
      const isOvertime = currentTime > endTime;
      
      return {
        status: isOvertime ? 'overtime' : 'occupied',
        info: {
          players: court.current.players,
          startTime: court.current.startTime,
          endTime: court.current.endTime,
          duration: court.current.duration,
          type: 'game',
          courtNumber: courtNumber
        }
      };
    }
    
    return { status: 'available', info: null };
  };

  const getStatusColor = (status) => {
    switch (status) {
      case 'available': return 'bg-green-100 border-green-300';
      case 'occupied': return 'bg-blue-100 border-blue-300';
      case 'overtime': return 'bg-gray-100 border-gray-300';
      case 'blocked': return 'bg-amber-50 border-amber-300';
      case 'wet': return 'bg-gray-200 border-gray-400'; // Grey for wet courts
      default: return 'bg-gray-100 border-gray-300';
    }
  };

  const handleWetCourtToggle = async (courtNum) => {
    // If parent provided a callback, use it
    if (onClearWetCourt) {
      onClearWetCourt(courtNum);
      return;
    }
    
    // Otherwise use local handling
    try {
      const blocks = await dataStore.get('courtBlocks') || [];
      const activeWetCourts = wetCourts || localWetCourts;
      
      if (activeWetCourts.has(courtNum)) {
        // Remove wet court block
        const updatedBlocks = blocks.filter(block => 
          !(block.isWetCourt && block.courtNumber === courtNum)
        );
        await dataStore.set('courtBlocks', updatedBlocks, { immediate: true });
        window.dispatchEvent(new Event(TENNIS_CONFIG.STORAGE.UPDATE_EVENT));

      } else {
        // Add wet court block
        const wetBlock = {
          id: `wet-court-${courtNum}-${Date.now()}`,
          courtNumber: courtNum,
          reason: 'WET COURT',
          startTime: new Date().toISOString(),
          endTime: new Date(new Date().setHours(22, 0, 0, 0)).toISOString(),
          isEvent: false,
          isWetCourt: true,
          createdAt: new Date().toISOString()
        };
        blocks.push(wetBlock);
        await dataStore.set('courtBlocks', blocks, { immediate: true });
      }
      
      window.dispatchEvent(new Event(TENNIS_CONFIG.STORAGE.UPDATE_EVENT));
      setRefreshKey(prev => prev + 1);
    } catch (error) {
      console.error('Error toggling wet court:', error);
    }
  };

  const formatTimeRemaining = (endTime) => {
    const end = new Date(endTime);
    const diff = end - currentTime;
    const minutes = Math.floor(diff / 60000);
    
    if (minutes < -60) return `${Math.abs(Math.floor(minutes / 60))}h over`;
    if (minutes < 0) return `${Math.abs(minutes)}m over`;
    if (minutes < 60) return `${minutes}m left`;
    return `${Math.floor(minutes / 60)}h ${minutes % 60}m left`;
  };

  const getPlayerNames = (players) => {
    if (!players || players.length === 0) return 'No players';
    return players.map(p => {
      const name = p.name || p.playerName || 'Unknown';
      return name.split(' ').pop();
    }).join(' & ');
  };

  const handleClearCourt = async (courtNum) => {
  // MODIFIED: Only clear ACTIVE blocks, preserve historical ones
  const currentTime = new Date();
  const existingBlocks = await dataStore.get('courtBlocks') || [];
  
  const updatedBlocks = existingBlocks.map(block => {
    if (block.courtNumber === courtNum) {
      const blockStart = new Date(block.startTime);
      const blockEnd = new Date(block.endTime);
      
      // Only end blocks that are currently active
      if (blockStart <= currentTime && blockEnd > currentTime) {
        return {
          ...block,
          endTime: currentTime.toISOString(),
          actualEndTime: currentTime.toISOString(),
          endReason: 'admin_cleared'
        };
      }
    }
    return block; // Keep all other blocks unchanged
  });
  
  await dataStore.set('courtBlocks', updatedBlocks, { immediate: true });
  window.dispatchEvent(new Event(TENNIS_CONFIG.STORAGE.UPDATE_EVENT));
  
  onClearCourt(courtNum);
  setShowActions(null);
};

  const handleEditClick = (courtNum, info) => {
    if (info.type === 'block') {
      const block = courtBlocks.find(b => b.id === info.id);
      if (block) {
        setEditingBlock({ ...block, courtNumber: courtNum });
      }
    } else if (info.type === 'game') {
      setEditingGame({ ...info, courtNumber: courtNum });
    }
    setShowActions(null);
  };

  const handleMoveCourt = async (from, to) => {
    try {
      const res = await onMoveCourt(from, to);   // <-- await the move
      if (res?.success) {
        setMovingFrom(null);                     // exit move mode ONLY on success
      }
      // If it failed, we stay in move mode so the user can pick another target.
    } catch (e) {
      Tennis?.UI?.toast?.('Unexpected error moving court', { type:'error' });
    }
  };

  const initiateMove = (courtNum) => {
    setMovingFrom(courtNum);
    setShowActions(null);
  };

const handleAllCourtsDry = async () => {
  // If parent provided a callback, use it
  if (onClearAllWetCourts) {
    onClearAllWetCourts();
    return;
  }
  
  // Otherwise use local handling
  try {
    const existingBlocks = await dataStore.get('courtBlocks') || [];
    
    // Remove all wet court blocks
    const updatedBlocks = existingBlocks.filter(block => !block.isWetCourt);
    
    await dataStore.set('courtBlocks', updatedBlocks, { immediate: true });
    window.dispatchEvent(new Event(TENNIS_CONFIG.STORAGE.UPDATE_EVENT));
    
    console.log('✅ All courts marked as dry');
    setRefreshKey(prev => prev + 1);
  } catch (error) {
    console.error('Error removing all wet court blocks:', error);
  }
};

  // ... (keep the handleSaveGame and handleSaveBlock functions as they are)

  // where the grid computes rows:
  const S = window.Tennis?.Storage;
  const data = S.readDataSafe(); // this will re-run on each re-render
  // if you compute occupied/free, use domain:
  const A = window.Tennis?.Domain?.availability || window.Tennis?.Domain?.Availability;
  const now = new Date();
  const blocks = S.readJSON(S.STORAGE?.BLOCKS) || [];
  const wetSet = new Set((blocks||[])
    .filter(b => b?.isWetCourt && new Date(b.startTime ?? b.start) <= now && now < new Date(b.endTime ?? b.end))
    .map(b => b.courtNumber));
  const statuses = A.getCourtStatuses({ data, now, blocks, wetSet });

  return (
    <>
      <div className="bg-white rounded-lg shadow-sm p-4">


        <div className="flex justify-between items-center mb-4">
  <h3 className="text-lg font-semibold text-gray-800">Court Status</h3>
  <div className="flex items-center gap-3">
    <button
      onClick={onClearAllCourts}
      className="px-3 py-1 bg-emerald-500 text-white rounded-lg hover:bg-emerald-600 text-xs font-medium"
    >
      Clear All Courts
    </button>
    <div className="text-sm text-gray-500">
      {currentTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
    </div>
  </div>
</div>


        
        <div className="grid grid-cols-3 gap-3">
          {Array.from({ length: 12 }, (_, index) => {
            const court = data?.courts?.[index] || null;
            const courtNum = index + 1;
            const { status, info } = getCourtStatus(court, courtNum);
            const isMoving = movingFrom === courtNum;
            const canReceiveMove = movingFrom && movingFrom !== courtNum && status === 'available';
            
            
            return (
              <div
                key={courtNum}
                className={`p-3 rounded-lg border-2 ${getStatusColor(status)} ${
                  isMoving ? 'ring-2 ring-blue-500' : ''
                } ${canReceiveMove ? 'cursor-pointer hover:bg-green-200' : ''} 
                ${status === 'wet' ? 'cursor-pointer hover:bg-gray-300' : ''}
                min-h-[120px] h-[120px] flex flex-col justify-between relative`}
                onClick={canReceiveMove ? () => {
                  handleMoveCourt(Number(movingFrom), Number(courtNum));
                } : status === 'wet' ? () => {
                  handleWetCourtToggle(courtNum);
                } : undefined}
              >
                <div>
                  <div className="flex justify-between items-start">
                    <h4 className="font-bold text-lg">Court {courtNum}</h4>
                    {status !== 'available' && status !== 'wet' && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          setShowActions(showActions === courtNum ? null : courtNum);
                          setMovingFrom(null);
                        }}
                        className="p-1 hover:bg-white/50 rounded"
                      >
                        <span style={{ fontSize: '18px' }}>☰</span>
                      </button>
                    )}
                  </div>
                  
                  {/* Time remaining for occupied courts */}
                  {(status === 'occupied' || status === 'overtime') && info && (
                    <div className={`text-xs font-medium ${
                      status === 'overtime' ? 'text-red-600' : 'text-blue-600'
                    }`}>
                      {formatTimeRemaining(info.endTime)}
                    </div>
                  )}
                  
                  {/* Court info */}
                  {info && (
                    <div className="mt-1">
                      {status === 'wet' && (
                        <>
                          <p className="font-medium text-sm">💧 WET COURT</p>
                          <p className="text-xs text-gray-600">Click to mark dry</p>
                        </>
                      )}
                      {status === 'blocked' && (
                        <>
                          <p className="font-medium text-sm truncate">{info.reason}</p>
                          <p className="text-xs text-gray-600">
                            Until {new Date(info.endTime).toLocaleTimeString([], { 
                              hour: '2-digit', 
                              minute: '2-digit' 
                            })}
                          </p>
                        </>
                      )}
                      {(status === 'occupied' || status === 'overtime') && (
                        <>
                          <p className="font-medium text-sm truncate">
                            {getPlayerNames(info.players)}
                          </p>
                          <p className="text-xs text-gray-600">
                            Since {new Date(info.startTime).toLocaleTimeString([], { 
                              hour: '2-digit', 
                              minute: '2-digit' 
                            })}
                          </p>
                        </>
                      )}
                    </div>
                  )}
                  
                  {/* Available court message when moving */}
                  {canReceiveMove && (
                    <div className="mt-2 text-center">
                      <p className="text-sm font-medium text-green-700">
                        Click to move here
                      </p>
                    </div>
                  )}
                </div>
                
                {/* Action dropdown menu */}
                {showActions === courtNum && status !== 'available' && status !== 'wet' && (
                  <div className="absolute top-12 right-2 bg-white border border-gray-300 rounded-lg shadow-lg z-10">
                    {status !== 'blocked' && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          initiateMove(courtNum);
                        }}
                        className="block w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
                      >
                        <div className="flex items-center gap-2">
                          <RefreshCw size={14} />
                          Move Players
                        </div>
                      </button>
                    )}
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        handleEditClick(courtNum, info);
                      }}
                      className="block w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
                    >
                      <div className="flex items-center gap-2">
                        <Edit2 size={14} />
                        Edit {info.type === 'block' ? 'Block' : 'Game'}
                      </div>
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        handleClearCourt(courtNum);
                      }}
                      className="block w-full text-left px-4 py-2 hover:bg-gray-100 text-sm text-red-600"
                    >
                      <div className="flex items-center gap-2">
                        <X size={14} />
                        Clear Court
                      </div>
                    </button>
                  </div>
                )}
              </div>
            );
          })}
        </div>


{/* Bottom buttons */}
<div className="mt-4 flex items-center gap-4">
  {/* WET COURTS Button */}
  <button
    onClick={wetCourtsActive ? deactivateWetCourts : handleEmergencyWetCourt}
    className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-all border ${
      wetCourtsActive
        ? 'bg-gray-600 text-white border-blue-400 ring-1 ring-blue-400 shadow-md'
        : 'bg-blue-50 hover:bg-blue-100 text-gray-700 border-blue-300 hover:border-blue-400'
    }`}
  >
    <Droplets size={20} />
    WET COURTS
    {wetCourts.size > 0 && (
      <span className="ml-1 px-1.5 py-0.5 bg-blue-500 text-white text-xs rounded-full">
        {wetCourts.size}
      </span>
    )}
  </button>

  {/* Wet Courts Active Message and All Courts Dry Button */}
  {wetCourts.size > 0 && (
    <div className="flex items-center gap-3">
      <span className="text-sm text-gray-600">
        💧 Click wet courts as they dry to resume normal operations
      </span>
      <button
        onClick={handleAllCourtsDry}
        className="px-3 py-1 bg-green-600 text-white rounded text-sm hover:bg-green-700 font-medium"
      >
        All Courts Dry
      </button>
    </div>
  )}
</div>

      </div>

      {/* Edit Game Modal */}
      {editingGame && (
        <EditGameModal
          game={editingGame}
          onSave={handleSaveGame}
          onClose={() => setEditingGame(null)}
        />
      )}

      {/* Edit Block Modal */}
      {editingBlock && (
        <EditBlockModal
          block={editingBlock}
          onSave={handleSaveBlock}
          onClose={() => setEditingBlock(null)}
          onEditInBlockManager={() => {
            if (onEditBlock) {
              onEditBlock(editingBlock);
            }
            setEditingBlock(null);
          }}
        />
      )}
    </>
  );
};


// Edit Game Modal Component
const EditGameModal = ({ game, onSave, onClose }) => {
  const [players, setPlayers] = useState(game.players || []);
  const [startTime, setStartTime] = useState(() => {
    const date = new Date(game.startTime);
    return date.toTimeString().slice(0, 5);
  });
  const [endTime, setEndTime] = useState(() => {
    const date = new Date(game.endTime);
    return date.toTimeString().slice(0, 5);
  });
  const [duration, setDuration] = useState(game.duration || 90);

  const handlePlayerNameChange = (index, newName) => {
    const newPlayers = [...players];
    newPlayers[index] = { ...newPlayers[index], name: newName };
    setPlayers(newPlayers);
  };

  const handleSave = () => {
    const startDate = new Date(game.startTime);
    const [startHours, startMinutes] = startTime.split(':');
    startDate.setHours(parseInt(startHours), parseInt(startMinutes));

    const endDate = new Date(game.endTime);
    const [endHours, endMinutes] = endTime.split(':');
    endDate.setHours(parseInt(endHours), parseInt(endMinutes));

    onSave({
      ...game,
      players,
      startTime: startDate.toISOString(),
      endTime: endDate.toISOString(),
      duration
    });
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-lg shadow-xl max-w-md w-full p-6">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-bold">Edit Game - Court {game.courtNumber}</h2>
          <button onClick={onClose} className="p-1 hover:bg-gray-100 rounded">
            <X size={20} />
          </button>
        </div>

        <div className="space-y-4">
          {/* Players */}
          <div>
            <label className="block text-sm font-medium mb-2">Players</label>
            {players.map((player, index) => (
              <input
                key={index}
                type="text"
                value={player.name || ''}
                onChange={(e) => handlePlayerNameChange(index, e.target.value)}
                className="w-full px-3 py-2 border rounded-lg mb-2"
                placeholder={`Player ${index + 1}`}
              />
            ))}
          </div>

          {/* Times */}
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium mb-2">Start Time</label>
              <input
                type="time"
                value={startTime}
                onChange={(e) => setStartTime(e.target.value)}
                className="w-full px-3 py-2 border rounded-lg"
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-2">End Time</label>
              <input
                type="time"
                value={endTime}
                onChange={(e) => setEndTime(e.target.value)}
                className="w-full px-3 py-2 border rounded-lg"
              />
            </div>
          </div>

          {/* Duration */}
          <div>
            <label className="block text-sm font-medium mb-2">Duration (minutes)</label>
            <input
              type="number"
              value={duration}
              onChange={(e) => setDuration(parseInt(e.target.value) || 90)}
              className="w-full px-3 py-2 border rounded-lg"
            />
          </div>
        </div>

        <div className="flex gap-3 mt-6">
          <button
            onClick={handleSave}
            className="flex-1 bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700"
          >
            Save Changes
          </button>
          <button
            onClick={onClose}
            className="flex-1 bg-gray-200 text-gray-700 py-2 rounded-lg hover:bg-gray-300"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  );
};

// Edit Block Modal Component
const EditBlockModal = ({ block, onSave, onClose, onEditInBlockManager }) => {
  const [reason, setReason] = useState(block.reason);
  const [endTime, setEndTime] = useState(() => {
    const date = new Date(block.endTime);
    return date.toTimeString().slice(0, 5);
  });

  const handleQuickSave = () => {
    const endDate = new Date(block.endTime);
    const [endHours, endMinutes] = endTime.split(':');
    endDate.setHours(parseInt(endHours), parseInt(endMinutes));

    onSave({
      ...block,
      reason,
      endTime: endDate.toISOString()
    });
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-lg shadow-xl max-w-md w-full p-6">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-bold">Edit Block - Court {block.courtNumber}</h2>
          <button onClick={onClose} className="p-1 hover:bg-gray-100 rounded">
            <X size={20} />
          </button>
        </div>

        <div className="space-y-4">
          {/* Block Reason */}
          <div>
            <label className="block text-sm font-medium mb-2">Block Reason</label>
            <input
              type="text"
              value={reason}
              onChange={(e) => setReason(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg"
              placeholder="e.g., MAINTENANCE, WET COURT"
            />
          </div>

          {/* End Time */}
          <div>
            <label className="block text-sm font-medium mb-2">End Time</label>
            <input
              type="time"
              value={endTime}
              onChange={(e) => setEndTime(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg"
            />
          </div>

          {/* Advanced Edit Option */}
          <div className="p-3 bg-blue-50 rounded-lg">
            <p className="text-sm text-blue-700">
              For more options (recurrence, multiple courts, etc.), use the full block editor.
            </p>
            <button
              onClick={onEditInBlockManager}
              className="mt-2 text-sm text-blue-600 hover:text-blue-700 font-medium"
            >
              Open in Block Manager →
            </button>
          </div>
        </div>

        <div className="flex gap-3 mt-6">
          <button
            onClick={handleQuickSave}
            className="flex-1 bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700"
          >
            Save Changes
          </button>
          <button
            onClick={onClose}
            className="flex-1 bg-gray-200 text-gray-700 py-2 rounded-lg hover:bg-gray-300"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  );
};


// Auto-mapping function for event types
const getEventTypeFromReason = (reason) => {
  const reasonUpper = reason.toUpperCase();
  
  if (reasonUpper.includes('TOURNAMENT')) return 'tournament';
  if (reasonUpper.includes('LEAGUE')) return 'league';
  if (reasonUpper.includes('CLINIC')) return 'clinic';
  if (reasonUpper.includes('LESSON')) return 'lesson';
  if (reasonUpper.includes('MAINTENANCE') || reasonUpper.includes('COURT WORK')) return 'maintenance';
  
  // Reasons that shouldn't be events by default
  if (reasonUpper.includes('WET')) return null;
  
  return 'other'; // For custom reasons
};

// Collision detection algorithm
const calculateEventLayout = (events) => {
        // Sort events by start time, then by duration (longer events first)
        const sortedEvents = [...events].sort((a, b) => {
          const aStart = new Date(a.startTime).getTime();
          const bStart = new Date(b.startTime).getTime();
          if (aStart !== bStart) return aStart - bStart;
          
          const aDuration = new Date(a.endTime).getTime() - aStart;
          const bDuration = new Date(b.endTime).getTime() - bStart;
          return bDuration - aDuration;
        });

        // Group overlapping events
        const groups = [];
        sortedEvents.forEach(event => {
          const eventStart = new Date(event.startTime).getTime();
          const eventEnd = new Date(event.endTime).getTime();
          
          // Find a group this event overlaps with
          let foundGroup = false;
          for (const group of groups) {
            const groupStart = Math.min(...group.map(e => new Date(e.startTime).getTime()));
            const groupEnd = Math.max(...group.map(e => new Date(e.endTime).getTime()));
            
            if (eventStart < groupEnd && eventEnd > groupStart) {
              group.push(event);
              foundGroup = true;
              break;
            }
          }
          
          if (!foundGroup) {
            groups.push([event]);
          }
        });

        // Assign columns within each group
        const layoutInfo = new Map();
        
        groups.forEach(group => {
          const columns = [];
          
          group.forEach(event => {
            const eventStart = new Date(event.startTime).getTime();
            const eventEnd = new Date(event.endTime).getTime();
            
            // Find the first available column
            let column = 0;
            while (true) {
              const canFit = !columns[column] || columns[column].every(e => {
                const eStart = new Date(e.startTime).getTime();
                const eEnd = new Date(e.endTime).getTime();
                return eventEnd <= eStart || eventStart >= eEnd;
              });
              
              if (canFit) {
                if (!columns[column]) columns[column] = [];
                columns[column].push(event);
                break;
              }
              column++;
            }
            
            layoutInfo.set(event.id || `${event.startTime}-${event.courtNumbers?.[0]}`, {
              column,
              totalColumns: columns.length,
              group
            });
          });
          
          // Update total columns for all events in group
          group.forEach(event => {
            const key = event.id || `${event.startTime}-${event.courtNumbers?.[0]}`;
            const info = layoutInfo.get(key);
            if (info) {
              info.totalColumns = columns.length;
            }
          });
        });

        return layoutInfo;
      };

      const getEventIcon = (type) => {
        switch (type) {
          case 'league':
            return Trophy;
          case 'tournament':
            return Star;
          case 'clinic':
            return GraduationCap;
          default:
            return Calendar;
        }
      };


      // Event color utility function (ADD HERE)
const getEventColor = (event) => {
  const eventType = event.eventType || event.type;
  const reason = (event.reason || '').toUpperCase();
  
  // First check explicit eventType
  if (eventType) {
    switch (eventType) {
      case 'tournament':
        return 'bg-purple-200 border-purple-300 text-purple-800';
      case 'league':
        return 'bg-yellow-300 border-yellow-400 text-yellow-900';
      case 'clinic':
        return 'bg-purple-100 border-purple-200 text-purple-700';
      case 'lesson':
        return 'bg-teal-500 border-teal-600 text-white';
      case 'maintenance':
        return 'bg-amber-200 border-amber-300 text-amber-800';
    }
  }
  
  // Then check by reason for blocks without explicit eventType
  if (reason.includes('WET') || reason.includes('WET COURT')) {
    return 'bg-blue-200 border-blue-300 text-blue-800';
  }
  if (reason.includes('MAINTENANCE') || reason.includes('COURT WORK')) {
    return 'bg-orange-200 border-orange-300 text-orange-800';
  }
  if (reason.includes('LESSON')) {
    return 'bg-green-200 border-green-300 text-green-800';
  }
  if (reason.includes('CLINIC')) {
    return 'bg-purple-100 border-purple-200 text-purple-700';
  }
  if (reason.includes('TOURNAMENT')) {
    return 'bg-purple-200 border-purple-300 text-purple-800';
  }
  if (reason.includes('LEAGUE')) {
    return 'bg-yellow-300 border-yellow-400 text-yellow-900';
  }
  
  // Default color for unknown types
  return 'bg-gray-200 border-gray-300 text-gray-700';
};

// Interactive Event Component (ADD BEFORE Day View)
const InteractiveEvent = ({ 
  event, 
  className, 
  style, 
  onEventClick, 
  onEventHover, 
  onEventLeave, 
  isWeekView 
}) => {
  const eventRef = useRef(null);
  
  const handleMouseEnter = () => {
    if (onEventHover && eventRef.current) {
      onEventHover(event, eventRef.current);
    }
  };
  
  return (
    <div
      ref={eventRef}
      className={`${className} cursor-pointer transition-all duration-200 shadow-sm hover:shadow-2xl hover:-translate-y-1 hover:z-20 hover:brightness-105`}
      style={style}
      onClick={() => onEventClick?.(event)}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={() => onEventLeave?.()}
    >
      <div className="font-medium text-xs truncate">
        {event.eventDetails?.title || event.title || event.reason}
      </div>
      {isWeekView && (
        <div className="text-xs opacity-75">
          Court {event.courtNumbers?.[0] || event.courtNumber}
        </div>
      )}
    </div>
  );
};

 // Enhanced Time Entry Component
 const VisualTimeEntry = ({ startTime, endTime, onStartTimeChange, onEndTimeChange, selectedDate = new Date(), selectedCourts = [], blockReason = '', timePickerMode = 'visual', setTimePickerMode = null, hideToggleButton = false }) => {
        const [duration, setDuration] = useState({ hours: 0, minutes: 0 });
        const [validationError, setValidationError] = useState('');
        const [lastUsedDuration, setLastUsedDuration] = useState(null);

        const generateTimeSlots = () => {
          const slots = [];
          const now = new Date();
          const currentHour = now.getHours();
          const currentMinutes = now.getMinutes();
          const isToday = selectedDate.toDateString() === now.toDateString();
          
          for (let hour = 6; hour <= 22; hour++) {
            for (let minute = 0; minute < 60; minute += 30) {
              const isPast = isToday && (hour < currentHour || (hour === currentHour && minute <= currentMinutes));
              
              slots.push({
                hour,
                minute,
                label: `${hour > 12 ? hour - 12 : hour === 0 ? 12 : hour}:${minute.toString().padStart(2, '0')} ${hour >= 12 ? 'PM' : 'AM'}`,
                value: `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`,
                isPast
              });
            }
          }
          return slots;
        };

        const timeSlots = generateTimeSlots();

        useEffect(() => {
          if (startTime && endTime && startTime !== 'now') {
            const start = new Date();
            const end = new Date();
            const [startHours, startMinutes] = startTime.split(':');
            const [endHours, endMinutes] = endTime.split(':');
            
            start.setHours(parseInt(startHours), parseInt(startMinutes), 0);
            end.setHours(parseInt(endHours), parseInt(endMinutes), 0);
            
            if (end < start) {
              end.setDate(end.getDate() + 1);
            }
            
            const diffMs = end - start;
            const diffMinutes = Math.floor(diffMs / 60000);
            
            setDuration({
              hours: Math.floor(diffMinutes / 60),
              minutes: diffMinutes % 60
            });

            if (diffMinutes <= 0) {
              setValidationError('End time must be after start time');
            } else if (diffMinutes > 720) {
              setValidationError('Block duration cannot exceed 12 hours');
            } else {
              setValidationError('');
            }
          } else if (startTime === 'now' && endTime) {
            const now = new Date();
            const end = new Date();
            const [endHours, endMinutes] = endTime.split(':');
            end.setHours(parseInt(endHours), parseInt(endMinutes), 0);
            
            if (end < now) {
              end.setDate(end.getDate() + 1);
            }
            
            const diffMs = end - now;
            const diffMinutes = Math.floor(diffMs / 60000);
            
            setDuration({
              hours: Math.floor(diffMinutes / 60),
              minutes: diffMinutes % 60
            });

            if (diffMinutes <= 0) {
              setValidationError('End time must be in the future');
            } else {
              setValidationError('');
            }
          }
        }, [startTime, endTime]);

        const durationPresets = [
          { label: '30 min', minutes: 30 },
          { label: '1 hour', minutes: 60 },
          { label: '2 hours', minutes: 120 },
          { label: '4 hours', minutes: 240 }
        ];

        const applyPresetDuration = (minutes) => {
          let baseTime = new Date();
          
          if (startTime !== 'now' && startTime) {
            const [hours, mins] = startTime.split(':');
            baseTime.setHours(parseInt(hours), parseInt(mins), 0);
          }
          
          const endDate = new Date(baseTime.getTime() + minutes * 60000);
          const endTimeString = endDate.toTimeString().slice(0, 5);
          onEndTimeChange(endTimeString);
        };

        const handleSlotClick = (slot, isStart) => {
          if (slot.isPast && isStart) return;
          
          if (isStart) {
            onStartTimeChange(slot.value);
            if (!endTime) {
              const [hours, minutes] = slot.value.split(':').map(Number);
              const date = new Date();
              date.setHours(hours, minutes);
              date.setMinutes(date.getMinutes() + 120);
              onEndTimeChange(date.toTimeString().slice(0, 5));
            }
          } else {
            onEndTimeChange(slot.value);
          }
        };

        const isSlotSelected = (slot, isStart) => {
          if (isStart) {
            return startTime === slot.value;
          } else {
            return endTime === slot.value;
          }
        };

        const isSlotInRange = (slot) => {
          if (!startTime || !endTime || startTime === 'now') return false;
          
          const slotTime = new Date();
          slotTime.setHours(slot.hour, slot.minute, 0);
          
          const start = new Date();
          const [startHours, startMinutes] = startTime.split(':');
          start.setHours(parseInt(startHours), parseInt(startMinutes), 0);
          
          const end = new Date();
          const [endHours, endMinutes] = endTime.split(':');
          end.setHours(parseInt(endHours), parseInt(endMinutes), 0);
          
          return slotTime > start && slotTime < end;
        };

        return (
          <div className="space-y-4">
            {startTime && endTime && (
              <div className={`p-3 rounded-lg ${validationError ? 'bg-red-50' : 'bg-blue-50'}`}>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Clock size={16} className={validationError ? 'text-red-600' : 'text-blue-600'} />
                    <span className={`font-medium ${validationError ? 'text-red-700' : 'text-blue-700'}`}>
                      {validationError ? validationError : `Duration: ${duration.hours}h ${duration.minutes}m`}
                    </span>
                  </div>
                  {validationError && <AlertCircle size={16} className="text-red-600" />}
                </div>
              </div>
            )}

            {!hideToggleButton && setTimePickerMode && (
              <div className="flex items-center">
                <button
                  onClick={() => setTimePickerMode(timePickerMode === 'visual' ? 'manual' : 'visual')}
                  className="text-sm text-blue-600 hover:text-blue-700"
                >
                  {timePickerMode === 'visual' ? 'Switch to manual input' : 'Switch to visual picker'}
                </button>
              </div>
            )}

            {timePickerMode === 'visual' ? (
              <>
                <div>
                  <div className="flex items-center justify-between mb-2">
                    <div className="flex items-center gap-3">
                      <label className="text-sm font-medium">Start Time</label>
                      {selectedDate.toDateString() === new Date().toDateString() && (
                        <button
                          onClick={() => onStartTimeChange('now')}
                          className={`px-3 py-1 text-sm rounded-lg transition-all ${
                            startTime === 'now' 
                              ? 'bg-blue-600 text-white' 
                              : selectedCourts.length > 0 && blockReason
                                ? 'bg-blue-50 hover:bg-blue-100 border border-blue-300 shadow-sm'
                                : 'bg-gray-100 hover:bg-gray-200'
                          }`}
                        >
                          Start Now
                        </button>
                      )}
                    </div>
                    {setTimePickerMode && (
                      <button
                        onClick={() => setTimePickerMode(timePickerMode === 'visual' ? 'manual' : 'visual')}
                        className="text-sm text-blue-600 hover:text-blue-700"
                      >
                        {timePickerMode === 'visual' ? 'Switch to manual input' : 'Switch to visual picker'}
                      </button>
                    )}
                  </div>
                  <div className="grid grid-cols-4 gap-2 max-h-48 overflow-y-auto p-2 border rounded-lg">
                    {timeSlots.map(slot => (
                      <button
                        key={slot.value}
                        onClick={() => handleSlotClick(slot, true)}
                        disabled={slot.isPast}
                        className={`py-2 px-3 text-sm rounded-lg transition-colors ${
                          isSlotSelected(slot, true)
                            ? 'bg-blue-600 text-white'
                            : slot.isPast
                            ? 'bg-gray-50 text-gray-400 cursor-not-allowed'
                            : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                        }`}
                      >
                        {slot.label}
                      </button>
                    ))}
                  </div>
                </div>

                {startTime && (
                  <div>
                    <label className="block text-sm font-medium mb-2">Quick Duration</label>
                    <div className="grid grid-cols-4 gap-2">
                      {durationPresets.map(preset => (
                        <button
                          key={preset.label}
                          onClick={() => {
                            applyPresetDuration(preset.minutes);
                            setLastUsedDuration(preset.minutes);
                          }}
                          className={`py-2 px-3 rounded-lg text-sm font-medium transition-all shadow-sm border ${
                            lastUsedDuration === preset.minutes
                              ? 'bg-blue-600 text-white border-blue-700 shadow-md'
                              : 'bg-white hover:bg-blue-50 text-blue-600 border-blue-300 hover:border-blue-400 hover:shadow-md'
                          }`}
                        >
                          {preset.label}
                        </button>
                      ))}
                    </div>
                  </div>
                )}

                <div>
                  <label className="text-sm font-medium mb-2 block">End Time</label>
                  <div className="grid grid-cols-4 gap-2 max-h-48 overflow-y-auto p-2 border rounded-lg">
                    {timeSlots.map(slot => {
                      const isDisabled = startTime && startTime !== 'now' && slot.value <= startTime;
                      return (
                        <button
                          key={slot.value}
                          onClick={() => handleSlotClick(slot, false)}
                          disabled={isDisabled}
                          className={`py-2 px-3 text-sm rounded-lg transition-colors ${
                            isSlotSelected(slot, false)
                              ? 'bg-blue-600 text-white'
                              : isSlotInRange(slot)
                              ? 'bg-blue-100 text-blue-700'
                              : isDisabled
                              ? 'bg-gray-50 text-gray-400 cursor-not-allowed'
                              : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                          }`}
                        >
                          {slot.label}
                        </button>
                      );
                    })}
                  </div>
                </div>
              </>
            ) : (
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium mb-2">Start Time</label>
                  <div className="flex gap-2">
                    {selectedDate.toDateString() === new Date().toDateString() && (
                      <button
                        onClick={() => onStartTimeChange('now')}
                        className={`px-3 py-2 rounded-lg font-medium transition-all shadow-sm border ${
                          startTime === 'now' 
                            ? 'bg-blue-600 text-white border-blue-700 shadow-md' 
                            : 'bg-white hover:bg-blue-50 text-blue-600 border-blue-300 hover:border-blue-400 hover:shadow-md'
                        }`}
                      >
                        Now
                      </button>
                    )}
                    <input
                      type="time"
                      value={startTime === 'now' ? '' : startTime}
                      onChange={(e) => onStartTimeChange(e.target.value)}
                      className="flex-1 px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                  </div>
                </div>
                
                <div>
                  <label className="block text-sm font-medium mb-2">End Time</label>
                  <input
                    type="time"
                    value={endTime}
                    onChange={(e) => onEndTimeChange(e.target.value)}
                    required
                    className={`w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 ${
                      validationError ? 'border-red-300 focus:ring-red-500' : 'focus:ring-blue-500'
                    }`}
                  />
                </div>
              </div>
            )}
          </div>
        );
      };

      const MiniCalendar = ({ selectedDate, onDateSelect, minDate = new Date() }) => {
        const [viewMonth, setViewMonth] = useState(new Date(selectedDate));
        
        const getDaysInMonth = (date) => {
          const year = date.getFullYear();
          const month = date.getMonth();
          const firstDay = new Date(year, month, 1);
          const lastDay = new Date(year, month + 1, 0);
          const daysInMonth = lastDay.getDate();
          const startingDayOfWeek = firstDay.getDay();
          
          const days = [];
          
          for (let i = 0; i < startingDayOfWeek; i++) {
            days.push(null);
          }
          
          for (let i = 1; i <= daysInMonth; i++) {
            days.push(new Date(year, month, i));
          }
          
          return days;
        };
        
        const isToday = (date) => {
          if (!date) return false;
          const today = new Date();
          return date.toDateString() === today.toDateString();
        };
        
        const isSelected = (date) => {
          if (!date) return false;
          return date.toDateString() === selectedDate.toDateString();
        };
        
        const isPastDate = (date) => {
          if (!date) return false;
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          return date < today;
        };
        
        const changeMonth = (increment) => {
          const newMonth = new Date(viewMonth);
          newMonth.setMonth(newMonth.getMonth() + increment);
          setViewMonth(newMonth);
        };
        
        const days = getDaysInMonth(viewMonth);
        const monthYear = viewMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        
        return (
          <div className="bg-white border rounded-lg p-4">
            <div className="flex items-center justify-between mb-4">
              <button
                onClick={() => changeMonth(-1)}
                className="p-1 hover:bg-gray-100 rounded"
              >
                <ChevronLeft size={16} />
              </button>
              <h3 className="font-medium text-sm">{monthYear}</h3>
              <button
                onClick={() => changeMonth(1)}
                className="p-1 hover:bg-gray-100 rounded"
              >
                <ChevronRight size={16} />
              </button>
            </div>
            
            <div className="grid grid-cols-7 gap-1 mb-2">
              {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((day, index) => (
                <div key={index} className="text-center text-xs text-gray-500 font-medium">
                  {day}
                </div>
              ))}
            </div>
            
            <div className="grid grid-cols-7 gap-1">
              {days.map((date, index) => {
                if (!date) {
                  return <div key={index} />;
                }
                
                const isPast = isPastDate(date);
                const isDateToday = isToday(date);
                const isDateSelected = isSelected(date);
                
                return (
                  <button
                    key={index}
                    onClick={() => !isPast && onDateSelect(date)}
                    disabled={isPast}
                    className={`
                      aspect-square flex items-center justify-center text-sm rounded
                      ${isDateSelected ? 'bg-blue-600 text-white font-medium' : ''}
                      ${isDateToday && !isDateSelected ? 'bg-blue-100 text-blue-600 font-medium' : ''}
                      ${isPast ? 'text-gray-300 cursor-not-allowed' : ''}
                      ${!isDateSelected && !isDateToday && !isPast ? 'hover:bg-gray-100' : ''}
                    `}
                  >
                    {date.getDate()}
                  </button>
                );
              })}
            </div>
          </div>
        );
      };


      // Day View Component with collision detection
      const DayView = memo(({ 
        selectedDate, 
        events, 
        currentTime, 
        onEventClick, 
        onEventHover, 
        onEventLeave,
        onQuickAction 
      }) => {
        const { eventsWithLayout, hours, showCurrentTime } = useMemo(() => {
          const isToday = selectedDate.toDateString() === currentTime.toDateString();
          const hoursArray = Array.from({ length: 15 }, (_, i) => i + 7);
          
          // Filter events for this day
          const dayEvents = events.filter(event => {
            const eventDate = new Date(event.startTime);
            return eventDate.toDateString() === selectedDate.toDateString();
          });
          
          // Calculate layout for collision detection
          const layout = calculateEventLayout(dayEvents);
          
          const positions = dayEvents.map(event => {
            const eventStart = new Date(event.startTime);
            const eventEnd = new Date(event.endTime);
            const startHour = eventStart.getHours() + eventStart.getMinutes() / 60;
            const endHour = eventEnd.getHours() + eventEnd.getMinutes() / 60;
            
            const layoutInfo = layout.get(event.id || `${event.startTime}-${event.courtNumbers?.[0]}`) || {
              column: 0,
              totalColumns: 1
            };
            
            return {
              ...event,
              top: (startHour - 7) * 60,
              height: (endHour - startHour) * 60,
              startHour,
              endHour,
              column: layoutInfo.column,
              totalColumns: layoutInfo.totalColumns,
              hasConflict: layoutInfo.totalColumns > 1 && layoutInfo.group.some(otherEvent => 
                otherEvent !== event && 
                event.courtNumbers?.some(court => otherEvent.courtNumbers?.includes(court))
              )
            };
          });
          
          return { 
            eventsWithLayout: positions, 
            hours: hoursArray,
            showCurrentTime: isToday
          };
        }, [selectedDate, events, currentTime]);
        
        return (
          <div className="flex h-full">
            {/* Time column */}
            <div className="w-20 flex-shrink-0 relative" style={{ height: `${hours.length * 60}px` }}>
              {hours.map((hour, idx) => (
                <div key={hour} className="absolute right-2 text-sm text-gray-500" style={{ top: `${idx * 60 - 8}px` }}>
                  {hour > 12 ? `${hour - 12}:00 PM` : hour === 12 ? '12:00 PM' : `${hour}:00 AM`}
                </div>
              ))}
            </div>
            
            {/* Event column */}
            <div className="flex-1 bg-white relative border-l border-gray-300" style={{ height: `${hours.length * 60}px` }}>
              {/* Hour blocks with grid lines */}
              {hours.map((hour, idx) => (
                <div key={hour} className="absolute w-full h-[60px] border-t border-gray-200" style={{ top: `${idx * 60}px` }}>
                  {/* Half-hour line */}
                  <div className="absolute w-full h-px bg-gray-100" style={{ top: '30px' }} />
                </div>
              ))}
              
              {/* Current time indicator */}
              {showCurrentTime && (
                <div
                  className="absolute left-0 right-0 border-t-2 border-red-500 z-10"
                  style={{
                    top: `${((currentTime.getHours() + currentTime.getMinutes() / 60) - 7) * 60}px`
                  }}
                >
                  <div className="absolute -top-2 left-0 bg-red-500 text-white text-xs px-1 rounded">
                    {currentTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                  </div>
                </div>
              )}
              
              {/* Events with collision handling */}
              {eventsWithLayout.map((event, idx) => {
                const width = `calc(${100 / event.totalColumns}% - 16px)`;
                const left = `calc(${(100 / event.totalColumns) * event.column}% + 8px)`;
                
                return (
                  <InteractiveEvent
                    key={idx}
                    event={event}
                    className={`absolute p-3 rounded-lg shadow-md ${getEventColor(event)} border-2 group hover:z-10 hover:shadow-lg transition-shadow`}
                    style={{
                      top: `${event.top}px`,
                      height: `${event.height}px`,
                      minHeight: '60px',
                      left: left,
                      width: width
                    }}
                    onEventClick={onEventClick}
                    onEventHover={onEventHover}
                    onEventLeave={onEventLeave}
                    onQuickAction={onQuickAction}
                    isWeekView={false}
                  />
                );
              })}
            </div>
          </div>
        );
      });

      // Enhanced Day View Component with Court Grid
const DayViewEnhanced = memo(({ 
  selectedDate, 
  events, 
  currentTime, 
  onEventClick, 
  onEventHover, 
  onEventLeave,
  onQuickAction 
}) => {
  const { courts, eventsByCourtWithLayout, hours } = useMemo(() => {
    const hoursArray = Array.from({ length: 16 }, (_, i) => i + 6); // 6am to 9pm
    const courtsArray = Array.from({ length: 12 }, (_, i) => i + 1); // Courts 1-12
    
    // Filter events for selected date
    const dayEvents = events.filter(event => {
      const eventDate = new Date(event.startTime);
      return eventDate.toDateString() === selectedDate.toDateString();
    });
    
    // Group events by court and calculate layout
    const eventsByCourt = {};
    courtsArray.forEach(courtNum => {
      const courtEvents = dayEvents.filter(event => 
        event.courtNumbers?.includes(courtNum) || event.courtNumber === courtNum
      );
      
      const layout = calculateEventLayout(courtEvents);
      
      eventsByCourt[courtNum] = courtEvents.map(event => {
        const eventStart = new Date(event.startTime);
        const eventEnd = new Date(event.endTime);
        const startHour = eventStart.getHours() + eventStart.getMinutes() / 60;
        const endHour = eventEnd.getHours() + eventEnd.getMinutes() / 60;
        
        const layoutInfo = layout.get(event.id || `${event.startTime}-${courtNum}`) || {
          column: 0,
          totalColumns: 1
        };
        
        return {
          ...event,
          courtNumber: courtNum,
          top: (startHour - 6) * 60,
          height: (endHour - startHour) * 60,
          startHour,
          endHour,
          column: layoutInfo.column,
          totalColumns: layoutInfo.totalColumns
        };
      });
    });
    
    return { courts: courtsArray, eventsByCourtWithLayout: eventsByCourt, hours: hoursArray };
  }, [selectedDate, events]);
  
  return (
    <div className="h-full overflow-auto">
      <div className="flex min-w-max">
        {/* Time column */}
        <div className="w-16 flex-shrink-0 bg-gray-50">
          <div className="h-12 border-b border-gray-300 bg-gray-50 sticky top-0 z-20"></div>
          <div className="relative" style={{ height: `${hours.length * 60}px` }}>
            {hours.map((hour, idx) => (
  hour >= 7 && (
    <div key={hour} className="absolute right-2 text-xs text-gray-500" style={{ top: `${idx * 60 - 8}px` }}>
      {hour > 12 ? `${hour - 12} PM` : hour === 12 ? '12 PM' : `${hour} AM`}
    </div>
  )
))}

          </div>
        </div>
        
        {/* Court columns */}
        <div className="flex bg-gray-200 min-w-0" style={{ minHeight: `${hours.length * 60 + 48}px` }}>
          {courts.map((courtNum) => {
            const courtEvents = eventsByCourtWithLayout[courtNum] || [];

            return (
              
            <div key={courtNum} className="w-24 bg-white border-r border-gray-200 last:border-r-0 flex-shrink-0">
                
              <div className="h-12 p-2 text-center border-b border-gray-300 bg-gray-50 sticky top-0 z-20">
                <div className="text-xs text-gray-600">Court</div>
                  <div className="text-sm font-medium">{courtNum}</div>
                </div>
                
                <div className="relative" style={{ height: `${hours.length * 60}px` }}>
                  {/* Hour blocks with grid lines */}
                  {hours.map((hour, idx) => (
                    <div
                      key={hour}
                      className="absolute w-full h-[60px] border-t border-gray-200"
                      style={{ top: `${idx * 60}px` }}
                    >
                      {/* Half-hour line */}
                      <div className="absolute w-full h-px bg-gray-100" style={{ top: '30px' }} />
                    </div>
                  ))}
                  
                  {/* Events */}
                  {courtEvents.map((event, idx) => {
                    const width = `${100 / event.totalColumns}%`;
                    const left = `${(100 / event.totalColumns) * event.column}%`;
                    
                    return (
                      <InteractiveEvent
                        key={idx}
                        event={event}
                        className={`absolute p-1 rounded shadow-sm ${getEventColor(event)} text-xs overflow-hidden border-l-2 group hover:z-10`}
                        style={{
                          top: `${event.top}px`,
                          height: `${event.height}px`,
                          minHeight: '20px',
                          left: left,
                          width: width,
                          marginRight: '2px'
                        }}
                        onEventClick={onEventClick}
                        onEventHover={onEventHover}
                        onEventLeave={onEventLeave}
                        onQuickAction={onQuickAction}
                        isWeekView={false}
                      />
                    );
                  })}
                </div>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
});


      // Month View Component with memoization
      const MonthView = memo(({ selectedDate, events, currentTime, onEventClick }) => {
        const { start, end, calendarDays, eventsByDate } = useMemo(() => {
          const firstDay = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), 1);
          const startingDayOfWeek = firstDay.getDay();
          const daysInMonth = new Date(selectedDate.getFullYear(), selectedDate.getMonth() + 1, 0).getDate();
          
          const days = [];
          // Add empty cells for days before month starts
          for (let i = 0; i < startingDayOfWeek; i++) {
            days.push(null);
          }
          // Add days of month
          for (let i = 1; i <= daysInMonth; i++) {
            days.push(new Date(selectedDate.getFullYear(), selectedDate.getMonth(), i));
          }
          
          // Group events by date
          const evtsByDate = {};
          events.forEach(event => {
            const dateKey = new Date(event.startTime).toDateString();
            if (!evtsByDate[dateKey]) {
              evtsByDate[dateKey] = [];
            }
            evtsByDate[dateKey].push(event);
          });
          
          return {
            start: firstDay,
            end: new Date(selectedDate.getFullYear(), selectedDate.getMonth() + 1, 0, 23, 59, 59, 999),
            calendarDays: days,
            eventsByDate: evtsByDate
          };
        }, [selectedDate, events]);
        
        return (
          <div>
            <div className="grid grid-cols-7 gap-px bg-gray-200">
              {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day => (
                <div key={day} className="bg-gray-50 p-2 text-center text-sm font-medium">
                  {day}
                </div>
              ))}
            </div>
            <div className="grid grid-cols-7 gap-px bg-gray-200 mt-px">
              {calendarDays.map((date, index) => {
                const isToday = date && date.toDateString() === currentTime.toDateString();
                const dateEvents = date ? eventsByDate[date.toDateString()] || [] : [];
                
                return (
                  <div
                    key={index}
                    className={`bg-white p-2 min-h-[100px] ${
                      !date ? 'bg-gray-50' : ''
                    } ${isToday ? 'bg-blue-50' : ''}`}
                  >
                    {date && (
                      <>
                        <div className={`text-sm font-medium mb-1 ${
                          isToday ? 'text-blue-600' : 'text-gray-900'
                        }`}>
                          {date.getDate()}
                        </div>
                        <div className="space-y-1">
                          {dateEvents.slice(0, 2).map((event, idx) => {
                            const Icon = getEventIcon(event.eventDetails?.type);
                            return (
                              <div
                                key={idx}
                                onClick={() => onEventClick(event)}
                                className={`text-xs p-1 rounded flex items-center gap-1 cursor-pointer hover:opacity-80 ${getEventColor(event)}`}
                              >
                                <Icon size={10} />
                                <span className="truncate">
                                  {event.eventDetails?.title || event.reason}
                                </span>
                              </div>
                            );
                          })}
                          {dateEvents.length > 2 && (
                            <div className="text-xs text-gray-500">
                              +{dateEvents.length - 2} more
                            </div>
                          )}
                        </div>
                      </>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        );
      });


 // Event Summary Component
 const EventSummary = memo(({ events, currentTime, onEventClick }) => {
        const upcomingEvents = useMemo(() => {
          return events
            .filter(event => new Date(event.startTime) > currentTime)
            .sort((a, b) => new Date(a.startTime) - new Date(b.startTime))
            .slice(0, 3);
        }, [events, currentTime]);
        
        return (
          <div className="bg-gray-50 rounded-lg p-4">
            <h3 className="font-medium text-gray-700 mb-2">Upcoming Events</h3>
            <div className="space-y-2">
              {upcomingEvents.map(event => {
                const Icon = getEventIcon(event.eventDetails?.type);
                return (
                  <div 
                    key={event.id} 
                    onClick={() => onEventClick(event)}
                    className="flex items-center gap-3 text-sm cursor-pointer hover:bg-gray-100 p-2 -m-2 rounded transition-colors"
                  >
                    <Icon size={16} className="text-gray-600" />
                    <div className="flex-1">
                      <span className="font-medium">{event.eventDetails?.title || event.reason}</span>
                      <span className="text-gray-500 ml-2">
                        Courts {event.courtNumbers.join(', ')}
                      </span>
                    </div>
                    <span className="text-gray-500">
                      {new Date(event.startTime).toLocaleDateString([], { 
                        month: 'short', 
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                      })}
                    </span>
                  </div>
                );
              })}
            </div>
          </div>
        );
      });



// Week View Component with collision detection
const WeekView = memo(({ 
        selectedDate, 
        events, 
        currentTime, 
        onEventClick, 
        onEventHover, 
        onEventLeave,
        onQuickAction 
      }) => {
        const { days, eventsByDayWithLayout, hours } = useMemo(() => {
          const start = new Date(selectedDate);
          start.setDate(start.getDate() - start.getDay());
          start.setHours(0, 0, 0, 0);
          
          const weekDays = [];
          for (let i = 0; i < 7; i++) {
            const day = new Date(start);
            day.setDate(day.getDate() + i);
            weekDays.push(day);
          }

          const hoursArray = Array.from({ length: 16 }, (_, i) => i + 6);
          
          // Group events by day and calculate layout
          const eventsByDay = {};
          weekDays.forEach((day, dayIndex) => {
            const dayEvents = events.filter(event => {
              const eventDate = new Date(event.startTime);
              return eventDate.toDateString() === day.toDateString();
            });
            
            const layout = calculateEventLayout(dayEvents);
            
            eventsByDay[dayIndex] = dayEvents.map(event => {
              const eventStart = new Date(event.startTime);
              const eventEnd = new Date(event.endTime);
              const startHour = eventStart.getHours() + eventStart.getMinutes() / 60;
              const endHour = eventEnd.getHours() + eventEnd.getMinutes() / 60;
              
              const layoutInfo = layout.get(event.id || `${event.startTime}-${event.courtNumbers?.[0]}`) || {
                column: 0,
                totalColumns: 1
              };
              
              return {
                ...event,
                dayIndex,
                top: (startHour - 6) * 60,
                height: (endHour - startHour) * 60,
                startHour,
                endHour,
                column: layoutInfo.column,
                totalColumns: layoutInfo.totalColumns,
                hasConflict: layoutInfo.totalColumns > 1 && layoutInfo.group.some(otherEvent => 
                  otherEvent !== event && 
                  event.courtNumbers?.some(court => otherEvent.courtNumbers?.includes(court))
                )
              };
            });
          });
          
          return { days: weekDays, eventsByDayWithLayout: eventsByDay, hours: hoursArray };
        }, [selectedDate, events]);
        
        return (
          <div className="flex h-full">
            {/* Time column */}
            <div className="w-16 flex-shrink-0">
              <div className="h-12"></div>

              <div className="relative" style={{ height: `${hours.length * 60}px` }}>
              
                {hours.map((hour, idx) => (
  <div key={hour} className="absolute right-2 text-xs text-gray-500" style={{ top: `${idx * 60 - 8}px` }}>
    {hour > 12 ? `${hour - 12} PM` : hour === 12 ? '12 PM' : `${hour} AM`}
  </div>
))}
                 
              </div>
            </div>
            
            {/* Day columns */}
            <div className="flex-1 flex bg-gray-200 min-w-0" style={{ minHeight: `${hours.length * 60 + 48}px` }}>
  {days.map((day, dayIndex) => {
    const isToday = day.toDateString() === currentTime.toDateString();
    const dayEvents = eventsByDayWithLayout[dayIndex] || [];

    return (
      <div key={dayIndex} className="flex-1 bg-white border-r border-gray-200 last:border-r-0">
        <div className={`h-12 p-2 text-center border-b border-gray-300 sticky top-0 z-20 ${
          isToday ? 'bg-blue-50' : 'bg-gray-50'
        }`}>
          <div className="text-xs text-gray-600">
            {day.toLocaleDateString('en-US', { weekday: 'short' })}
          </div>
          <div className={`text-sm font-medium ${
            isToday ? 'text-blue-600' : ''
          }`}>
            {day.getDate()}
          </div>
        </div>
        
        <div className="relative" style={{ height: `${hours.length * 60}px` }}>
          {/* Hour blocks with grid lines */}
          {hours.map((hour, idx) => (
            <div
              key={hour}
              className="absolute w-full h-[60px] border-t border-gray-200"
              style={{ top: `${idx * 60}px` }}
            >
              {/* Half-hour line */}
              <div className="absolute w-full h-px bg-gray-100" style={{ top: '30px' }} />
            </div>
          ))}
          
          {/* Events with collision handling */}
          {dayEvents.map((event, idx) => {
            const width = `${100 / event.totalColumns}%`;
            const left = `${(100 / event.totalColumns) * event.column}%`;
            
            return (
              <InteractiveEvent
                key={idx}
                event={event}
                className={`absolute p-1 rounded shadow-sm ${getEventColor(event)} text-xs overflow-hidden border-l-2 group hover:z-10`}
                style={{
                  top: `${event.top}px`,
                  height: `${event.height}px`,
                  minHeight: '20px',
                  left: left,
                  width: width,
                  marginRight: '2px'
                }}
                onEventClick={onEventClick}
                onEventHover={onEventHover}
                onEventLeave={onEventLeave}
                onQuickAction={onQuickAction}
                isWeekView={true}
              />
            );
          })}
        </div>
      </div>
    );
  })}
</div>
</div>
        );
      });


// Enhanced Event Calendar Component with interactive features
const EventCalendarEnhanced = ({ courts, currentTime, refreshTrigger, onRefresh, onEditEvent, onDuplicateEvent, defaultView = 'week' }) => {
        const [viewMode, setViewMode] = useState(defaultView);
        const [selectedDate, setSelectedDate] = useState(new Date());
        const [selectedEvent, setSelectedEvent] = useState(null);
        const [hoveredEvent, setHoveredEvent] = useState(null);
        const [hoverPosition, setHoverPosition] = useState({ top: 0, left: 0 });
        const [quickActionEvent, setQuickActionEvent] = useState(null);
        const [quickActionPosition, setQuickActionPosition] = useState({ top: 0, left: 0 });
        
        useEffect(() => {
    setViewMode(defaultView);
  }, [defaultView]);

        // Memoized event extraction and processing
        const events = useMemo(() => {
          const processedEvents = new Map();
          
          // Get events from localStorage
          try {
            const courtBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]');
            courtBlocks.forEach(block => {
              if (block.isEvent) {
                const eventKey = `${block.eventDetails?.title || block.reason}-${block.startTime}`;
                
                if (!processedEvents.has(eventKey)) {
                  processedEvents.set(eventKey, {
                    ...block,
                    courtNumbers: block.eventDetails?.courts || [block.courtNumber],
                    id: eventKey
                  });
                }
              }
            });


            courtBlocks.forEach(block => {
  if (!block.isEvent) {
    const eventKey = `${block.eventDetails?.title || block.title || block.reason}-${block.courtNumber}-${block.startTime}`;
    
    if (!processedEvents.has(eventKey)) {
      processedEvents.set(eventKey, {
        id: block.id,
        title: block.eventDetails?.title || block.title || block.reason,
        startTime: block.startTime,
        endTime: block.endTime,
        eventType: getEventTypeFromReason(block.reason),
        courtNumbers: [block.courtNumber],
        isBlock: true,
        reason: block.reason
      });
    }
  }
});

          } catch (error) {
            console.error('Error loading events:', error);
          }
          
          // Also check courts data for backward compatibility
          courts.forEach((court, idx) => {
            if (court && court.blocked && court.blocked.isEvent) {
              const eventKey = `${court.blocked.eventDetails.title}-${court.blocked.startTime}`;
              
              if (!processedEvents.has(eventKey)) {
                processedEvents.set(eventKey, {
                  ...court.blocked,
                  courtNumbers: court.blocked.eventDetails.courts || [idx + 1],
                  id: eventKey
                });
              }
            }
          });
          
          return Array.from(processedEvents.values());
        }, [courts, refreshTrigger]);
        
        // Memoized filtered events based on view and date range
        const filteredEvents = useMemo(() => {
          let startDate, endDate;
          
          if (viewMode === 'month') {
            startDate = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), 1);
            endDate = new Date(selectedDate.getFullYear(), selectedDate.getMonth() + 1, 0, 23, 59, 59, 999);
          } else if (viewMode === 'week') {
            startDate = new Date(selectedDate);
            startDate.setDate(startDate.getDate() - startDate.getDay());
            startDate.setHours(0, 0, 0, 0);
            endDate = new Date(startDate);
            endDate.setDate(endDate.getDate() + 6);
            endDate.setHours(23, 59, 59, 999);
          } else {
            startDate = new Date(selectedDate);
            startDate.setHours(0, 0, 0, 0);
            endDate = new Date(selectedDate);
            endDate.setHours(23, 59, 59, 999);
          }
          
          return events.filter(event => {
            const eventStart = new Date(event.startTime);
            const eventEnd = new Date(event.endTime);
            return (eventStart >= startDate && eventStart <= endDate) ||
                   (eventEnd >= startDate && eventEnd <= endDate) ||
                   (eventStart <= startDate && eventEnd >= endDate);
          });
        }, [events, viewMode, selectedDate]);
        
        // Event handlers
        const handleEventClick = useCallback((event) => {
          setSelectedEvent(event);
          setHoveredEvent(null);
        }, []);
        
        
        const handleEventHover = useCallback((event, element) => {
  if (!quickActionEvent && element) {
    const rect = element.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const cardWidth = 320; // HoverCard width (w-80 = 20rem = 320px)
    
    // Calculate optimal position
    let leftPosition;
    
    // Try positioning to the right first
    if (rect.right + 10 + cardWidth <= viewportWidth) {
      leftPosition = rect.right + 10;
    }
    // If right doesn't fit, try left
    else if (rect.left - cardWidth - 10 >= 0) {
      leftPosition = rect.left - cardWidth - 10;
    }
    // If neither fits well, center it with some margin
    else {
      leftPosition = Math.max(10, Math.min(
        viewportWidth - cardWidth - 10,
        rect.left + (rect.width / 2) - (cardWidth / 2)
      ));
    }
    
    setHoveredEvent(event);
    setHoverPosition({
      top: rect.top + rect.height / 2,
      left: leftPosition
    });
  }
}, [quickActionEvent]);
        
        const handleEventLeave = useCallback(() => {
          setHoveredEvent(null);
        }, []);
        
        const handleQuickAction = useCallback((event, position) => {
          setQuickActionEvent(event);
          setQuickActionPosition(position);
          setHoveredEvent(null);
        }, []);
        
        const handleEdit = useCallback((event) => {
  console.log('Edit event:', event);
  
  try {
    const courtBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]');
    const blockToEdit = courtBlocks.find(block => {
      if (event.eventDetails?.title && block.eventDetails?.title) {
        return block.eventDetails.title === event.eventDetails.title && 
               block.startTime === event.startTime;
      }
      return block.id === event.id;
    });
    
    if (blockToEdit) {
      setSelectedEvent(null); // Close modal
      onEditEvent(blockToEdit); // Let parent handle the edit
    }
  } catch (error) {
    console.error('Error finding block to edit:', error);
  }
}, [onEditEvent]);
        
        const handleDelete = useCallback(async (event) => {
           console.log('Delete event:', event);
          try {
        const courtBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]');
    
    // Remove all blocks that match this event
    const updatedBlocks = courtBlocks.filter(block => {
      // Remove blocks with matching event details
      if (event.eventDetails?.title && block.eventDetails?.title) {
        return !(block.eventDetails.title === event.eventDetails.title && 
                block.startTime === event.startTime);
      }
      // Fallback: remove by ID if available
      return block.id !== event.id;
    });
    
    await Tennis.BlocksService.saveBlocks(updatedBlocks);
    console.log('Event deleted successfully');
    onRefresh();
  } catch (error) {
    console.error('Error deleting event:', error);
  }
}, [onRefresh]);
        
     const handleDuplicate = useCallback((event) => {
      console.log('Duplicate event:', event);
      setSelectedEvent(null); // Close modal
      onDuplicateEvent(event); // Let parent handle the duplication
}, [onDuplicateEvent]);

        
        // Memoized callbacks
        const navigateDate = useCallback((direction) => {
          setSelectedDate(prevDate => {
            const newDate = new Date(prevDate);
            
            if (viewMode === 'month') {
              newDate.setMonth(newDate.getMonth() + direction);
            } else if (viewMode === 'week') {
              newDate.setDate(newDate.getDate() + (direction * 7));
            } else {
              newDate.setDate(newDate.getDate() + direction);
            }
            
            return newDate;
          });
        }, [viewMode]);
        
        const handleToday = useCallback(() => {
          setSelectedDate(new Date());
        }, []);
        
        const handleViewModeChange = useCallback((mode) => {
          setViewMode(mode);
        }, []);
        
        // Memoized header text
        const headerText = useMemo(() => {
          if (viewMode === 'month') {
            return selectedDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
          } else if (viewMode === 'week') {
            const start = new Date(selectedDate);
            start.setDate(start.getDate() - start.getDay());
            const end = new Date(start);
            end.setDate(end.getDate() + 6);
            return `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`;
          } else {
            return selectedDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
          }
        }, [viewMode, selectedDate]);
        
        // Close menus on click outside
        useEffect(() => {
          const handleClickOutside = () => {
            setQuickActionEvent(null);
          };
          
          if (quickActionEvent) {
            document.addEventListener('click', handleClickOutside);
            return () => document.removeEventListener('click', handleClickOutside);
          }
        }, [quickActionEvent]);
        
        return (
          <div className="space-y-4">

            {/* Controls */}
<div className="flex items-center justify-between mb-2 px-20">  {/* Added px-20 to bring everything in */}
  {/* Day/Week/Month buttons on the left */}
  <div className="flex bg-gray-100 rounded-lg p-1">
    <button
      onClick={() => handleViewModeChange('day')}
      className={`px-3 py-1 rounded text-sm ${
        viewMode === 'day' ? 'bg-white shadow-sm' : 'hover:bg-gray-200'
      }`}
    >
      Day
    </button>
    <button
      onClick={() => handleViewModeChange('week')}
      className={`px-3 py-1 rounded text-sm ${
        viewMode === 'week' ? 'bg-white shadow-sm' : 'hover:bg-gray-200'
      }`}
    >
      Week
    </button>
    <button
      onClick={() => handleViewModeChange('month')}
      className={`px-3 py-1 rounded text-sm ${
        viewMode === 'month' ? 'bg-white shadow-sm' : 'hover:bg-gray-200'
      }`}
    >
      Month
    </button>
  </div>
  
  {/* Navigation arrows and Today button in center */}
  <div className="flex items-center gap-3">
    <button
      onClick={() => navigateDate(-1)}
      className="p-2 hover:bg-gray-100 rounded"
    >
      <ChevronLeft size={32} />
    </button>

    <button
  onClick={() => handleToday()}
  className="px-4 py-1.5 bg-blue-100 hover:bg-blue-300 text-gray-800 border border-blue-300 hover:border-blue-400 rounded text-sm font-medium transition-all hover:shadow-md hover:-translate-y-0.5"
>
  Today
</button>
    <button
      onClick={() => navigateDate(1)}
      className="p-2 hover:bg-gray-100 rounded"
    >
      <ChevronRight size={32} />
    </button>
  </div>

  {/* Date display on the right */}
  <h2 className="text-lg font-semibold w-64 text-right">{headerText}</h2>
</div>
    

       
            
            
             {/* Calendar View */}
               
             <div className="bg-white rounded-lg shadow-sm p-2">  {/* Changed p-4 to p-2 to reduce padding */}
              <div className="border-t border-gray-300">  {/* Add this wrapper div with border */}

            
            
              {viewMode === 'month' && (
                <MonthView 
                  selectedDate={selectedDate} 
                  events={filteredEvents} 
                  currentTime={currentTime}
                  onEventClick={handleEventClick}
                />
              )}
              {viewMode === 'week' && (
                <div className="h-[600px] overflow-auto">
                  <WeekView 
                    selectedDate={selectedDate} 
                    events={filteredEvents} 
                    currentTime={currentTime}
                    onEventClick={handleEventClick}
                    onEventHover={handleEventHover}
                    onEventLeave={handleEventLeave}
                    onQuickAction={handleQuickAction}
                  />
                </div>
              )}

              {viewMode === 'day' && (
  <div className="h-[600px] overflow-auto">
    <DayViewEnhanced 
      selectedDate={selectedDate} 
      events={filteredEvents} 
      currentTime={currentTime}
      onEventClick={handleEventClick}
      onEventHover={handleEventHover}
      onEventLeave={handleEventLeave}
      onQuickAction={handleQuickAction}
    />
  </div>
)}
</div>
            </div>

            {/* Event Summary */}
            <EventSummary events={events} currentTime={currentTime} onEventClick={handleEventClick} />
            
            {/* Hover Card */}
            {hoveredEvent && !quickActionEvent && (
              <HoverCard
                event={hoveredEvent}
                position={hoverPosition}
                onClose={() => setHoveredEvent(null)}
              />
            )}
            
            {/* Quick Actions Menu */}
            {quickActionEvent && (
              <QuickActionsMenu
                event={quickActionEvent}
                position={quickActionPosition}
                onClose={() => setQuickActionEvent(null)}
                onEdit={handleEdit}
                onDelete={handleDelete}
                onDuplicate={handleDuplicate}
              />
            )}
            
            {/* Event Details Modal */}
            {selectedEvent && (
              <EventDetailsModal
                event={selectedEvent}
                onClose={() => setSelectedEvent(null)}
                onEdit={handleEdit}
                onDelete={handleDelete}
                onDuplicate={handleDuplicate}
              />
            )}
          </div>
        );
      };


// Hover Card Component
const HoverCard = memo(({ event, position, onClose }) => {
  const startTime = new Date(event.startTime);
  const endTime = new Date(event.endTime);
  const duration = Math.round((endTime - startTime) / (1000 * 60)); // minutes, rounded
  
  return (
    <div
      className="fixed z-50 bg-white rounded-lg shadow-xl border border-gray-200 p-4 w-80"
      style={{
        top: `${position.top}px`,
        left: `${position.left}px`,
        transform: 'translateY(-50%)'
      }}
      onMouseLeave={onClose}
    >
      <div className="flex items-start gap-3">
        <div className="flex-1">
          <h4 className="font-semibold text-gray-900">{event.eventDetails?.title || event.reason}</h4>
          <p className="text-sm text-gray-500 mt-1">
            {startTime.toLocaleDateString([], { weekday: 'short', month: 'short', day: 'numeric' })}
          </p>
        </div>
      </div>
      
      <div className="mt-3 space-y-2 text-sm">
        <div className="flex items-center gap-2 text-gray-600">
          <span>🕐</span>
          <span>
            {startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })} - 
            {endTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })} 
            ({Math.floor(duration / 60)}h {duration % 60}m)
          </span>
        </div>
        
        <div className="flex items-center gap-2 text-gray-600">
          <span>🎾</span>
          <span>Courts {event.courtNumbers.join(', ')}</span>
        </div>
        
        {event.eventDetails?.participants && (
          <div className="flex items-center gap-2 text-gray-600">
            <span>👥</span>
            <span>{event.eventDetails.participants} participants</span>
          </div>
        )}
        
        {event.eventDetails?.organizer && (
          <div className="flex items-center gap-2 text-gray-600">
            <span>ℹ️</span>
            <span>{event.eventDetails.organizer}</span>
          </div>
        )}
      </div>
      
      {event.hasConflict && (
        <div className="mt-3 pt-3 border-t border-gray-200">
          <div className="flex items-center gap-2 text-amber-600 text-sm">
            <span>⚠️</span>
            <span>This event conflicts with other bookings</span>
          </div>
        </div>
      )}
    </div>
  );
});


// Quick Actions Menu Component
const QuickActionsMenu = memo(({ event, position, onClose, onEdit, onDelete, onDuplicate }) => {
  if (!event) return null;
  
  return (
    <>
      {/* Invisible overlay to close menu when clicking outside */}
      <div 
        className="fixed inset-0 z-40" 
        onClick={onClose} 
      />
      
      <div
        className="fixed z-50 bg-white rounded-lg shadow-lg border border-gray-200 py-1 w-48"
        style={{
          top: `${position.top}px`,
          left: `${position.left}px`
        }}
      >
        <button
          onClick={() => {
            onEdit(event);
            onClose();
          }}
          className="w-full px-4 py-2 text-left text-sm hover:bg-gray-50 flex items-center gap-3"
        >
          <span>✏️</span>
          Edit Event
        </button>
        <button
          onClick={() => {
            onDuplicate(event);
            onClose();
          }}
          className="w-full px-4 py-2 text-left text-sm hover:bg-gray-50 flex items-center gap-3"
        >
          <span>📋</span>
          Duplicate
        </button>
        <div className="border-t border-gray-200 my-1"></div>
        <button
          onClick={() => {
            if (window.confirm('Are you sure you want to delete this event?')) {
              onDelete(event);
              onClose();
            }
          }}
          className="w-full px-4 py-2 text-left text-sm hover:bg-red-50 text-red-600 flex items-center gap-3"
        >
          <span>🗑️</span>
          Delete Event
        </button>
      </div>
    </>
  );
});

// Event Details Modal Component
const EventDetailsModal = memo(({ event, onClose, onEdit, onDelete, onDuplicate }) => {
  if (!event) return null;
  
  const emoji = getEventEmoji(event.eventDetails?.type || event.type || 'other');
  const startTime = new Date(event.startTime);
  const endTime = new Date(event.endTime);
  const duration = (endTime - startTime) / (1000 * 60); // minutes
  
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-lg shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-hidden">
        {/* Header */}
      
<div className={`p-6 ${getEventColor(event)}`}>
  <div className="flex items-start justify-between">
    <div className="flex items-start gap-4">
      <div>
        <h2 className="text-2xl font-bold">{event.eventDetails?.title || event.reason}</h2>
        <p className="opacity-90 mt-1">
          {startTime.toLocaleDateString([], { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}
        </p>
      </div>
    </div>
    <button
      onClick={onClose}
      className="p-2 hover:bg-white hover:bg-opacity-20 rounded-lg transition-colors"
    >
      <span className="text-xl">✖️</span>
    </button>
  </div>
</div>
        
        {/* Quick Actions */}
        <div className="flex items-center gap-2 px-6 py-3 bg-gray-50 border-b">
          <button
            onClick={() => onEdit(event)}
            className="flex items-center gap-2 px-3 py-1.5 text-sm bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors"
          >
            <span>✏️</span>
            Edit Event
          </button>
          <button
            onClick={() => onDuplicate(event)}
            className="flex items-center gap-2 px-3 py-1.5 text-sm bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors"
          >
            <span>📋</span>
            Duplicate
          </button>
          <button
            onClick={() => {
              if (window.confirm('Are you sure you want to delete this event?')) {
                onDelete(event);
                onClose();
              }
            }}
            className="flex items-center gap-2 px-3 py-1.5 text-sm bg-white border border-red-300 text-red-600 rounded-lg hover:bg-red-50 transition-colors ml-auto"
          >
            <span>🗑️</span>
            Delete
          </button>
        </div>
        
        {/* Content */}
        <div className="p-6 space-y-6 overflow-y-auto max-h-[60vh]">
          {/* Time and Location */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-3">
              <h3 className="font-semibold text-gray-900">Schedule</h3>
              <div className="space-y-2">
                <div className="flex items-center gap-3 text-gray-600">
                  <span>🕐</span>
                  <div>
                    <p className="font-medium">
                      {startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })} - 
                      {endTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                    </p>
                    <p className="text-sm text-gray-500">
                      Duration: {Math.floor(duration / 60)}h {duration % 60}m
                    </p>
                  </div>
                </div>
                {event.eventDetails?.recurringInfo && (
                  <div className="flex items-center gap-3 text-gray-600">
                    <span>🔄</span>
                    <div>
                      <p className="font-medium">{event.eventDetails.recurringInfo.pattern}</p>
                      <p className="text-sm text-gray-500">{event.eventDetails.recurringInfo.instance}</p>
                    </div>
                  </div>
                )}
              </div>
            </div>
            
            <div className="space-y-3">
              <h3 className="font-semibold text-gray-900">Location</h3>
              <div className="flex items-center gap-3 text-gray-600">
                <span>🎾</span>
                <div>
                  <p className="font-medium">Courts {event.courtNumbers.join(', ')}</p>
                  <p className="text-sm text-gray-500">{event.courtNumbers.length} court{event.courtNumbers.length > 1 ? 's' : ''} reserved</p>
                </div>
              </div>
            </div>
          </div>
          
          {/* Description */}
          {event.eventDetails?.description && (
            <div className="space-y-2">
              <h3 className="font-semibold text-gray-900">Description</h3>
              <p className="text-gray-600">{event.eventDetails.description}</p>
            </div>
          )}
          
          {/* Details */}
          <div className="grid grid-cols-2 gap-4">
            {event.eventDetails?.participants && (
              <div className="space-y-2">
                <h3 className="font-semibold text-gray-900">Participants</h3>
                <div className="flex items-center gap-3 text-gray-600">
                  <span>👥</span>
                  <span>{event.eventDetails.participants} registered</span>
                </div>
              </div>
            )}
            
            {event.eventDetails?.organizer && (
              <div className="space-y-2">
                <h3 className="font-semibold text-gray-900">Organizer</h3>
                <div className="flex items-center gap-3 text-gray-600">
                  <span>ℹ️</span>
                  <span>{event.eventDetails.organizer}</span>
                </div>
              </div>
            )}
          </div>
          
          {/* Conflicts */}
          {event.hasConflict && (
            <div className="p-4 bg-amber-50 border border-amber-200 rounded-lg">
              <div className="flex items-start gap-3">
                <span className="text-xl">⚠️</span>
                <div>
                  <h4 className="font-medium text-amber-900">Schedule Conflict</h4>
                  <p className="text-sm text-amber-700 mt-1">
                    This event overlaps with other bookings during the same time period.
                    {event.conflictingEvents && (
                      <span className="block mt-2">
                        Conflicts with: {event.conflictingEvents.map(e => e.title).join(', ')}
                      </span>
                    )}
                  </p>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
});

// Block Timeline Component
const BlockTimeline = ({ courts, currentTime, onEditBlock, onRemoveBlock, onDuplicateBlock, refreshTrigger }) => {
      const [viewMode, setViewMode] = useState('day');
        const [selectedDate, setSelectedDate] = useState(new Date());
        const [filterCourt, setFilterCourt] = useState('all');
        const [showPastBlocks, setShowPastBlocks] = useState(false);

        const getAllBlocks = () => {
          const blocks = [];
          
          // Get blocks from localStorage
          try {
            const courtBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]');
            courtBlocks.forEach(block => {

              blocks.push({
                ...block,
                id: block.id || `${block.courtNumber}-${block.startTime}`
              });

            });
          } catch (error) {
            console.error('Error loading blocks:', error);
          }
          
        // Add backup detection for wet court blocks
        blocks.forEach(block => {
          if (!block.isWetCourt && block.reason === 'WET COURT') {
            block.isWetCourt = true;
          }
        });
          return blocks;
        };

        const filteredBlocks = useMemo(() => {
  let blocks = getAllBlocks();
  blocks = blocks.filter(block => {
    const blockStart = new Date(block.startTime);
    const blockEnd = new Date(block.endTime);
    
    if (viewMode === 'day') {
      const dayStart = new Date(selectedDate);
      dayStart.setHours(0, 0, 0, 0);
      const dayEnd = new Date(selectedDate);
      dayEnd.setHours(23, 59, 59, 999);
      
      return (blockStart >= dayStart && blockStart <= dayEnd) ||
             (blockEnd >= dayStart && blockEnd <= dayEnd) ||
             (blockStart <= dayStart && blockEnd >= dayEnd);
    } else {
      const weekStart = new Date(selectedDate);
      weekStart.setDate(weekStart.getDate() - weekStart.getDay());
      weekStart.setHours(0, 0, 0, 0);
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekEnd.getDate() + 6);
      weekEnd.setHours(23, 59, 59, 999);
      
      return (blockStart >= weekStart && blockStart <= weekEnd) ||
             (blockEnd >= weekStart && blockEnd <= weekEnd);
    }
  });
  
  if (filterCourt !== 'all') {
    blocks = blocks.filter(block => block.courtNumber === parseInt(filterCourt));
  }
  if (!showPastBlocks) {
    blocks = blocks.filter(block => new Date(block.endTime) > currentTime);
  }
    blocks.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
  return blocks;
}, [viewMode, selectedDate, filterCourt, showPastBlocks, currentTime, refreshTrigger]);
        
        const getBlockStatus = (block) => {
          const start = new Date(block.startTime);
          const end = new Date(block.endTime);
          
          if (currentTime >= start && currentTime < end) return 'active';
          if (currentTime >= end) return 'past';
          return 'future';
        };

        const getStatusColor = (status) => {
          switch (status) {
            case 'active': return 'bg-red-50 border-red-300 text-red-900';
            case 'past': return 'bg-gray-50 border-gray-300 text-gray-600';
            case 'future': return 'bg-blue-50 border-blue-300 text-blue-900';
            default: return '';
          }
        };

        const formatTimeRange = (start, end) => {
          const startDate = new Date(start);
          const endDate = new Date(end);
          
          const startTime = startDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          const endTime = endDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          
          if (startDate.toDateString() !== endDate.toDateString()) {
            return `${startDate.toLocaleDateString([], { month: 'short', day: 'numeric' })} ${startTime} - ${endDate.toLocaleDateString([], { month: 'short', day: 'numeric' })} ${endTime}`;
          }
          
          return `${startTime} - ${endTime}`;
        };

        
        const groupedBlocks = filteredBlocks.reduce((groups, block) => {
          const blockDate = new Date(block.startTime);
          const dateKey = blockDate.toDateString();
          
          if (!groups[dateKey]) {
            groups[dateKey] = {
              date: blockDate,
              blocks: []
            };
          }
          
          groups[dateKey].blocks.push(block);
          return groups;
        }, {});
        
        const sortedGroups = Object.values(groupedBlocks).sort((a, b) => a.date - b.date);
        
        const isToday = (date) => {
          return date.toDateString() === new Date().toDateString();
        };
        
        const isTomorrow = (date) => {
          const tomorrow = new Date();
          tomorrow.setDate(tomorrow.getDate() + 1);
          return date.toDateString() === tomorrow.toDateString();
        };
        
        const getDateLabel = (date) => {
          if (isToday(date)) return 'Today';
          if (isTomorrow(date)) return 'Tomorrow';
          
          const now = new Date();
          const diffTime = date - now;
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
          
          if (diffDays > 0 && diffDays <= 7) {
            return date.toLocaleDateString('en-US', { weekday: 'long' });
          }
          
          return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
        };

        const navigateDate = (direction) => {
          setSelectedDate(prevDate => {
            const newDate = new Date(prevDate);
            
            if (viewMode === 'week') {
              newDate.setDate(newDate.getDate() + (direction * 7));
            } else {
              newDate.setDate(newDate.getDate() + direction);
            }
            
            return newDate;
          });
        };

        return (
          <div className="space-y-4">
            <div className="flex flex-wrap gap-4 items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="flex bg-gray-100 rounded-lg p-1">
                  <button
                    onClick={() => setViewMode('day')}
                    className={`px-3 py-1 rounded ${viewMode === 'day' ? 'bg-white shadow-sm' : ''}`}
                  >
                    Day
                  </button>
                  <button
                    onClick={() => setViewMode('week')}
                    className={`px-3 py-1 rounded ${viewMode === 'week' ? 'bg-white shadow-sm' : ''}`}
                  >
                    Week
                  </button>
                </div>

                <div className="flex items-center gap-2">
                  <button
                    onClick={() => navigateDate(-1)}
                    className="p-1 hover:bg-gray-100 rounded"
                  >
                    <ChevronLeft size={20} />
                  </button>
                  <button
                    onClick={() => setSelectedDate(new Date())}
                    className="px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700"
                  >
                    Today
                  </button>
                  <button
                    onClick={() => navigateDate(1)}
                    className="p-1 hover:bg-gray-100 rounded"
                  >
                    <ChevronRight size={20} />
                  </button>
                </div>

                <div className="font-medium">
                  {viewMode === 'day' 
                    ? selectedDate.toLocaleDateString([], { weekday: 'long', month: 'long', day: 'numeric' })
                    : `Week of ${selectedDate.toLocaleDateString([], { month: 'short', day: 'numeric' })}`
                  }
                </div>
              </div>

              <div className="flex items-center gap-3">
                <select
                  value={filterCourt}
                  onChange={(e) => setFilterCourt(e.target.value)}
                  className="px-3 py-1 border rounded-lg text-sm"
                >
                  <option value="all">All Courts</option>
                  {[...Array(12)].map((_, i) => (
                    <option key={i} value={i + 1}>Court {i + 1}</option>
                  ))}
                </select>

                <button
                  onClick={() => setShowPastBlocks(!showPastBlocks)}
                  className={`flex items-center gap-2 px-3 py-1 rounded-lg text-sm ${
                    showPastBlocks ? 'bg-gray-200' : 'bg-gray-100'
                  }`}
                >
                  {showPastBlocks ? <Eye size={16} /> : <EyeOff size={16} />}
                  Past Blocks
                </button>
              </div>
            </div>

            <div className="space-y-6">
              {sortedGroups.length === 0 ? (
                <div className="text-center py-8 text-gray-500">
                  No blocks scheduled for this {viewMode}
                </div>
              ) : (
                sortedGroups.map(group => (
                  <div key={group.date.toDateString()} className="space-y-2">
                    <div className="flex items-center gap-3 sticky top-0 bg-gray-50 py-2 z-10">
                      <div className="flex-1 h-px bg-gray-300"></div>
                      <div className="flex items-center gap-2">
                        <CalendarDays size={16} className="text-gray-600" />
                        <h3 className="font-semibold text-gray-700">
                          {getDateLabel(group.date)}
                        </h3>
                        {isToday(group.date) && (
                          <span className="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded-full">
                            {group.blocks.filter(b => getBlockStatus(b) === 'active').length} active
                          </span>
                        )}
                      </div>
                      <div className="flex-1 h-px bg-gray-300"></div>
                    </div>
                    
                    {group.blocks.map(block => {
                      const status = getBlockStatus(block);
                      const isEditable = status !== 'past';
                      
                      return (
                        <div
                          key={block.id}
                          className={`p-4 rounded-lg border-2 ${getStatusColor(status)} transition-all`}
                        >
                          <div className="flex items-start justify-between">
                            <div className="flex-1">
                              <div className="flex items-center gap-3 mb-2">
                                <span className="font-bold text-lg">Court {block.courtNumber}</span>
                                <span className="px-2 py-1 bg-white/70 rounded text-sm font-medium">
                                  {block.eventDetails?.title || block.title || block.reason}
                                </span>
                                {status === 'active' && (
                                  <span className="px-2 py-1 bg-red-600 text-white rounded text-xs font-medium animate-pulse">
                                    ACTIVE NOW
                                  </span>
                                )}
                              </div>
                              <div className="flex items-center gap-2 text-sm">
                                <Clock size={14} />
                                <span>
                                  {new Date(block.startTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                  {' - '}
                                  {new Date(block.endTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                </span>
                              </div>
                            </div>

                            <div className="flex items-center gap-1">
                              {isEditable && (
                                <>
                                  <button
                                    onClick={() => onEditBlock(block)}
                                    className="p-2 hover:bg-white/50 rounded transition-colors"
                                    title="Edit block"
                                  >
                                    <Edit2 size={16} />
                                  </button>
                                  <button
                                    onClick={() => onDuplicateBlock(block)}
                                    className="p-2 hover:bg-white/50 rounded transition-colors"
                                    title="Duplicate block"
                                  >
                                    <Copy size={16} />
                                  </button>
                                </>
                              )}
                              <button
                                onClick={() => {
                                  if (window.confirm(`Remove block on Court ${block.courtNumber}?`)) {
                                    onRemoveBlock(block.id);
                                  }
                                }}
                                className="p-2 text-red-600 hover:bg-red-50 rounded transition-colors"
                                title="Remove block"
                              >
                                <Trash2 size={16} />
                              </button>
                            </div>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                ))
              )}
            </div>

            <div className="mt-6 p-4 bg-gray-50 rounded-lg">
              <div className="grid grid-cols-3 gap-4 text-center">
                <div>
                  <p className="text-2xl font-bold text-blue-600">
                    {filteredBlocks.filter(b => getBlockStatus(b) === 'future').length}
                  </p>
                  <p className="text-sm text-gray-600">Upcoming Blocks</p>
                </div>
                <div>
                  <p className="text-2xl font-bold text-red-600">
                    {filteredBlocks.filter(b => getBlockStatus(b) === 'active').length}
                  </p>
                  <p className="text-sm text-gray-600">Active Now</p>
                </div>
                <div>
                  <p className="text-2xl font-bold text-gray-600">
                    {filteredBlocks.filter(b => getBlockStatus(b) === 'past').length}
                  </p>
                  <p className="text-sm text-gray-600">Past Blocks</p>
                </div>
              </div>
            </div>
          </div>
        );
      };

 // Conflict Detection Component
 const ConflictDetector = ({ courts, selectedCourts, startTime, endTime, selectedDate, editingBlock }) => {
        const [conflicts, setConflicts] = useState([]);
        useEffect(() => {
          if (!selectedCourts.length || !startTime || !endTime) {
            setConflicts([]);
            return;
          }
          
          const detectedConflicts = [];
          
          selectedCourts.forEach(courtNum => {
            const court = courts[courtNum - 1];
            if (!court) return;
            
            let blockStart, blockEnd;
            
            if (startTime === 'now') {
              blockStart = new Date();
            } else {
              blockStart = new Date(selectedDate);
              const [hours, minutes] = startTime.split(':');
              blockStart.setHours(parseInt(hours), parseInt(minutes), 0, 0);
            }
            
            blockEnd = new Date(selectedDate);
            const [endHours, endMinutes] = endTime.split(':');
            blockEnd.setHours(parseInt(endHours), parseInt(endMinutes), 0, 0);
            
            if (blockEnd < blockStart) {
              blockEnd.setDate(blockEnd.getDate() + 1);
            }
            
            // Check for existing blocks in localStorage
            try {
              const courtBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]');
              
              courtBlocks.forEach(block => {
                if (block.courtNumber === courtNum && (!editingBlock || block.id !== editingBlock.id)) {
                  const existingStart = new Date(block.startTime);
                  const existingEnd = new Date(block.endTime);
                  
                  if (
                    (blockStart >= existingStart && blockStart < existingEnd) ||
                    (blockEnd > existingStart && blockEnd <= existingEnd) ||
                    (blockStart <= existingStart && blockEnd >= existingEnd)
                  ) {
                    detectedConflicts.push({
                      courtNumber: courtNum,
                      type: 'block',
                      reason: block.reason,
                      time: `${existingStart.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })} - ${existingEnd.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`
                    });
                  }
                }
              });
            } catch (error) {
              console.error('Error checking block conflicts:', error);
            }
            
            if (court.current && court.current.players) {
              const bookingStart = new Date(court.current.startTime);
              const bookingEnd = new Date(court.current.endTime);
              
              if (
                (blockStart >= bookingStart && blockStart < bookingEnd) ||
                (blockEnd > bookingStart && blockEnd <= bookingEnd) ||
                (blockStart <= bookingStart && blockEnd >= bookingEnd)
              ) {
                detectedConflicts.push({
                  courtNumber: courtNum,
                  type: 'booking',
                  players: court.current.players.map(p => p.name),
                  time: `${bookingStart.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })} - ${bookingEnd.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`
                });
              }
            }
          });
          
          setConflicts(detectedConflicts);
        }, [courts, selectedCourts, startTime, endTime, selectedDate]);
        
        if (conflicts.length === 0) return null;
        
        return (
          <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
            <div className="flex items-start gap-3">
              <AlertTriangle className="text-yellow-600 mt-0.5" size={20} />
              <div className="flex-1">
                <h4 className="font-medium text-yellow-900 mb-2">Conflicts Detected</h4>
                <div className="space-y-2">
                  {conflicts.map((conflict, idx) => (
                    <div key={idx} className="text-sm text-yellow-800">
                      <span className="font-medium">Court {conflict.courtNumber}</span>
                      {conflict.type === 'block' ? (
                        <span>: Already blocked ({conflict.reason}) at {conflict.time}</span>
                      ) : (
                        <span>: Booked by {conflict.players.join(', ')} at {conflict.time}</span>
                      )}
                    </div>
                  ))}
                </div>
                <p className="mt-3 text-sm text-yellow-700">
                  You can still create this block, but existing bookings will need to be handled.
                </p>
              </div>
            </div>
          </div>
        );
      };


// Complete Block Manager Component (Enhanced with Interactive Event Calendar)
const CompleteBlockManagerEnhanced = ({ 
  courts, onApplyBlocks, existingBlocks,
  wetCourtsActive, setWetCourtsActive, wetCourts, setWetCourts, 
  suspendedBlocks, setSuspendedBlocks, ENABLE_WET_COURTS, onNotification,
  defaultView = 'timeline'
}) => {

        const [activeView, setActiveView] = useState(defaultView);
        const [selectedCourts, setSelectedCourts] = useState([]);
        const [blockReason, setBlockReason] = useState('');
        const [startTime, setStartTime] = useState('');
        const [endTime, setEndTime] = useState('');
        const [selectedDate, setSelectedDate] = useState(new Date());
        const [timePickerMode, setTimePickerMode] = useState('visual');
        const [recurrence, setRecurrence] = useState(null);
        const [showTemplates, setShowTemplates] = useState(false);
        const [isValid, setIsValid] = useState(false);
        const [editingBlock, setEditingBlock] = useState(null);
        const [isEvent, setIsEvent] = useState(true);
        const [eventType, setEventType] = useState('event');
        const [eventTitle, setEventTitle] = useState('');
        const [refreshTrigger, setRefreshTrigger] = useState(0);
        const [showCustomReason, setShowCustomReason] = useState(false);
        const [showRecurrence, setShowRecurrence] = useState(false);

        useEffect(() => {
  setActiveView(defaultView);
}, [defaultView]);

        const currentTime = new Date();

        // Wet Court Helper Functions
        const handleEmergencyWetCourt = async () => {
  if (!ENABLE_WET_COURTS) return;
  
  console.log('🌧️ Emergency wet court activated');
  
  // Set all courts as wet
  const allCourts = new Set();
  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].forEach(courtNum => {
    WC.markWet(allCourts, courtNum);
  });
  setWetCourts(allCourts);
  setWetCourtsActive(true);

  // Notify (preserve legacy event name for other pages)
  const nextWet = Array.from(allCourts).sort((a,b)=>a-b);
  Events.emitDom('tennisDataUpdate', { key: 'wetCourts', data: nextWet });
  
  // Create wet court blocks immediately with explicit court list
  try {
    const now = new Date().toISOString();
    let existingBlocks = [];
    try { existingBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]'); }
    catch { /* transient partial write; use empty array */ }
    
    // Create wet court blocks for all courts (1-12)
    const wetCourtBlocks = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map(courtNum => ({
      id: `wet-court-${courtNum}-${Date.now()}`,
      courtNumber: courtNum,
      reason: 'WET COURT',
      startTime: now,
      endTime: (() => {
        const today = new Date();
        const endTime = new Date(today);
        endTime.setHours(22, 0, 0, 0); // 10:00 PM today
        
        // If it's already past 10pm, set for 10pm tomorrow
        if (today.getHours() >= 22) {
          endTime.setDate(endTime.getDate() + 1);
        }
        
        return endTime.toISOString();
      })(),
      isEvent: false,
      isWetCourt: true,
      createdAt: now
    }));
    
    // Add to storage
    const updatedBlocks = [...existingBlocks, ...wetCourtBlocks];
    await Tennis.BlocksService.saveBlocks(updatedBlocks);

    console.log(`📦 Created ${wetCourtBlocks.length} wet court blocks directly`);
    setRefreshTrigger(prev => prev + 1);
    
  } catch (error) {
    console.error('Error creating wet court blocks:', error);
  }
};


const removeWetCourtBlock = async (courtNumber) => {
  if (!ENABLE_WET_COURTS) return;
  
  try {
    let existingBlocks = [];
    try { existingBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]'); }
    catch { /* transient partial write; use empty array */ }
    
    // Remove wet court blocks for this court
    const updatedBlocks = existingBlocks.filter(block => 
      !(block.isWetCourt && block.courtNumber === courtNumber)
    );
    
    await Tennis.BlocksService.saveBlocks(updatedBlocks);

    console.log(`🗑️ Removed wet court block for court ${courtNumber}`);
    setRefreshTrigger(prev => prev + 1); // Refresh timeline
    
  } catch (error) {
    console.error('Error removing wet court block:', error);
  }
};

const removeAllWetCourtBlocks = async () => {
  if (!ENABLE_WET_COURTS) return;
  
  try {
    let existingBlocks = [];
    try { existingBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]'); }
    catch { /* transient partial write; use empty array */ }
    
    // Remove all wet court blocks
    const updatedBlocks = existingBlocks.filter(block => !block.isWetCourt);
    
    await Tennis.BlocksService.saveBlocks(updatedBlocks);

    console.log('🧹 Removed all wet court blocks');
    setRefreshTrigger(prev => prev + 1); // Refresh timeline
    
  } catch (error) {
    console.error('Error removing all wet court blocks:', error);
  }
};

const clearWetCourt = (courtNumber) => {
  if (!ENABLE_WET_COURTS) return;
  
  console.log(`☀️ Clearing wet court ${courtNumber}`);
  
  const newWetCourts = new Set(wetCourts);
  WC.clearWet(newWetCourts, courtNumber);
  setWetCourts(newWetCourts);

  // Notify (preserve legacy event name for other pages)
  const nextWet = Array.from(newWetCourts).sort((a,b)=>a-b);
  Events.emitDom('tennisDataUpdate', { key: 'wetCourts', data: nextWet });

  // Remove wet court block for this court
  removeWetCourtBlock(courtNumber);

  // If all courts are dry, deactivate system
  if (newWetCourts.size === 0) {
    setWetCourtsActive(false);
    console.log('✅ All courts dry - wet court system deactivated');
  }
};

const deactivateWetCourts = () => {
  if (!ENABLE_WET_COURTS) return;
  
  console.log('🔄 Manually deactivating wet court system');
  setWetCourtsActive(false);
  setWetCourts(new Set());
  setSuspendedBlocks([]);

  // Remove all wet court blocks
  removeAllWetCourtBlocks();
};
        
        const quickReasons = [
          { label: 'MAINTENANCE', icon: Wrench, color: 'bg-orange-100 hover:bg-orange-200 text-orange-700' },
          { label: 'LESSON', icon: GraduationCap, color: 'bg-green-100 hover:bg-green-200 text-green-700' },
          { label: 'CLINIC', icon: Users, color: 'bg-purple-100 hover:bg-purple-200 text-purple-700' }
        ];
        
        const blockTemplates = [
          { name: 'Wet Courts (2 hours)', reason: 'WET COURT', duration: 120 },
          { name: 'Maintenance (4 hours)', reason: 'COURT WORK', duration: 240 },
          { name: 'Morning Lesson', reason: 'LESSON', startTime: '09:00', endTime: '10:00' },
          { name: 'Evening Clinic', reason: 'CLINIC', startTime: '18:00', endTime: '20:00' }
        ];
        
        useEffect(() => {
          const hasValidTimes = startTime && endTime;
          const hasReason = blockReason.trim().length > 0;
          const hasCourts = selectedCourts.length > 0;
          
          let timeIsValid = true;
          if (hasValidTimes) {
            if (startTime !== 'now') {
              const start = new Date();
              const end = new Date();
              const [startHours, startMinutes] = startTime.split(':');
              const [endHours, endMinutes] = endTime.split(':');
              
              start.setHours(parseInt(startHours), parseInt(startMinutes), 0);
              end.setHours(parseInt(endHours), parseInt(endMinutes), 0);
              
              if (end <= start) {
                timeIsValid = false;
              }
            }
          }
          
          setIsValid(hasValidTimes && hasReason && hasCourts && timeIsValid);
        }, [selectedCourts, blockReason, startTime, endTime]);
        
        const handleTemplateSelect = (template) => {
          setBlockReason(template.reason);
          if (template.duration) {
            setStartTime('now');
            const end = new Date();
            end.setMinutes(end.getMinutes() + template.duration);
            setEndTime(end.toTimeString().slice(0, 5));
          } else {
            setStartTime(template.startTime);
            setEndTime(template.endTime);
          }
          setShowTemplates(false);
        };
        
        const handleBlockCourts = () => {
          const blocks = [];
          const now = new Date();
          
          if (!recurrence) {
            blocks.push({ date: selectedDate });
          } else {
            let currentDate = new Date(selectedDate);
            let occurrenceCount = 0;
            
            while (true) {
              blocks.push({ date: new Date(currentDate) });
              occurrenceCount++;
              
              if (recurrence.endType === 'after' && occurrenceCount >= recurrence.occurrences) {
                break;
              }
              if (recurrence.endType === 'date' && currentDate > new Date(recurrence.endDate)) {
                break;
              }
              
              if (recurrence.pattern === 'daily') {
                currentDate.setDate(currentDate.getDate() + recurrence.frequency);
              } else if (recurrence.pattern === 'weekly') {
                currentDate.setDate(currentDate.getDate() + (7 * recurrence.frequency));
              } else if (recurrence.pattern === 'monthly') {
                currentDate.setMonth(currentDate.getMonth() + recurrence.frequency);
              }
              
              if (occurrenceCount > 365) break;
            }
          }
          
          const appliedBlocks = [];
          
          blocks.forEach(blockInfo => {
            selectedCourts.forEach(courtNum => {
              let actualStartTime;
              if (startTime === 'now') {
                actualStartTime = now;
              } else {
                actualStartTime = new Date(blockInfo.date);
                const [hours, minutes] = startTime.split(':');
                actualStartTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
              }
              
              const actualEndTime = new Date(blockInfo.date);
              const [endHours, endMinutes] = endTime.split(':');
              actualEndTime.setHours(parseInt(endHours), parseInt(endMinutes), 0, 0);
              
              if (actualEndTime < actualStartTime) {
                actualEndTime.setDate(actualEndTime.getDate() + 1);
              }
              
              appliedBlocks.push({
                id: Date.now().toString() + Math.random(),
                courtNumber: courtNum,
                reason: blockReason,
                title: eventTitle || blockReason, // Always preserve the title
                startTime: actualStartTime.toISOString(),
                endTime: actualEndTime.toISOString(),
                isEvent: isEvent,
                eventDetails: isEvent ? {
                  title: eventTitle || blockReason,
                  type: eventType,
                  courts: selectedCourts
                } : null,
                createdAt: new Date().toISOString()
              });
            });
          });
          
       // If editing, remove the old block first
           if (editingBlock) {
             handleRemoveBlock(editingBlock.id);
           }



           console.log('🔍 Sending to applyBlocks:', appliedBlocks);
          onApplyBlocks(appliedBlocks);
          
          // Reset form
          setSelectedCourts([]);
          setBlockReason('');
          setStartTime('');
          setEndTime('');
          setSelectedDate(new Date());
          setRecurrence(null);
          setEditingBlock(null);
          setIsEvent(false);
          setEventType('event');
          setEventTitle('');
        };
        
        const handleRemoveBlock = async (blockId) => {
    console.log('🗑️ Trying to delete block with ID:', blockId);
        try {
    let existingBlocks = [];
    try { existingBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]'); }
    catch { /* transient partial write; use empty array */ }
    console.log('📋 All blocks before deletion:', existingBlocks);
    console.log('🔍 Looking for block with ID:', blockId);
    
    const foundBlock = existingBlocks.find(block => block.id === blockId);
    console.log('✅ Found block?', foundBlock);
    
    const updatedBlocks = existingBlocks.filter(block => block.id !== blockId);
    console.log('📋 Blocks after filter:', updatedBlocks);
    console.log('📊 Length before:', existingBlocks.length, 'Length after:', updatedBlocks.length);
    
    await Tennis.BlocksService.saveBlocks(updatedBlocks);
    console.log('✅ Delete operation completed');
    setRefreshTrigger(prev => prev + 1);
  } catch (error) {
    console.error('Error removing block:', error);
  }
};
        
        const toggleCourtSelection = (courtNum) => {
          setSelectedCourts(prev => 
            prev.includes(courtNum) 
              ? prev.filter(c => c !== courtNum)
              : [...prev, courtNum]
          );
        };

        const handleEditBlock = (block) => {
          setEditingBlock(block);
          setSelectedCourts([block.courtNumber]);
          setBlockReason(block.reason);
          
          const startDate = new Date(block.startTime);
          const endDate = new Date(block.endTime);
          
          setSelectedDate(startDate);
          
          if (startDate > currentTime) {
            setStartTime(startDate.toTimeString().slice(0, 5));
          } else {
            setStartTime('now');
          }
          
          setEndTime(endDate.toTimeString().slice(0, 5));
          setActiveView('create');
        };

        const handleDuplicateBlock = (block) => {
          setSelectedCourts([]);
          setBlockReason(block.reason);
          
          const start = new Date(block.startTime);
          const end = new Date(block.endTime);
          const durationMs = end - start;
          
          setStartTime('now');
          const newEnd = new Date(Date.now() + durationMs);
          setEndTime(newEnd.toTimeString().slice(0, 5));
          
          setActiveView('create');
        };

        const handleQuickReason = (reason) => {
  setBlockReason(reason);
  
  // Auto-set event type based on reason
  const autoEventType = getEventTypeFromReason(reason);
  if (autoEventType) {
    setEventType(autoEventType);
    setIsEvent(true); // Default to showing on calendar
    // Auto-generate event title
    if (!eventTitle || eventTitle.includes('(Copy)')) {
      setEventTitle(reason.toLowerCase().replace(/\b\w/g, l => l.toUpperCase()));
    }
  } else {
    // Only WET COURT and similar should be hidden by default
    setIsEvent(false);
    setEventTitle('');
  }
};
     return (
          <div className="space-y-6">
            <div className="flex items-center justify-between">              
              {editingBlock && activeView === 'create' && (
                <div className="flex items-center gap-2 text-sm text-blue-600">
                  <Edit2 size={16} />
                  <span>Editing block on Court {editingBlock.courtNumber}</span>
                  <button
                    onClick={() => {
                      setEditingBlock(null);
                      setSelectedCourts([]);
                      setBlockReason('');
                      setStartTime('');
                      setEndTime('');
                      setSelectedDate(new Date());
                      setRecurrence(null);
                    }}
                    className="text-gray-500 hover:text-gray-700"
                  >
                    <X size={16} />
                  </button>
                </div>
              )}
            </div>

            {activeView === 'timeline' && (
  <BlockTimeline
    courts={courts}
    currentTime={currentTime}
    onEditBlock={handleEditBlock}
    onRemoveBlock={handleRemoveBlock}
    onDuplicateBlock={handleDuplicateBlock}
    refreshTrigger={refreshTrigger}
  />
)}

            {activeView === 'calendar' && (
  <EventCalendarEnhanced
    courts={courts}
    currentTime={currentTime}
    refreshTrigger={refreshTrigger}
    onRefresh={() => setRefreshTrigger(prev => prev + 1)}
    onEditEvent={(blockToEdit) => {

      // Switch to create view and populate form
      setActiveView('create');
      setEditingBlock(blockToEdit);
      setSelectedCourts([blockToEdit.courtNumber]);
      setBlockReason(blockToEdit.reason);
      
      const startDate = new Date(blockToEdit.startTime);
      const endDate = new Date(blockToEdit.endTime);
      
      setSelectedDate(startDate);
      setStartTime(startDate.toTimeString().slice(0, 5));
      setEndTime(endDate.toTimeString().slice(0, 5));
      
      // Set event details if it's an event
      if (blockToEdit.isEvent) {
        setIsEvent(true);
        setEventTitle(blockToEdit.eventDetails?.title || '');
        setEventType(blockToEdit.eventDetails?.type || 'event');
      }
    }}
  
    onDuplicateEvent={(event) => {
      // Switch to create view with duplicated data
      setActiveView('create');
      setEditingBlock(null); // Not editing, creating new
      setSelectedCourts(event.courtNumbers || []);
      setBlockReason(event.reason);

      // Set current time as start time
      setStartTime('now');
      
      // Calculate end time based on original duration
      const originalStart = new Date(event.startTime);
      const originalEnd = new Date(event.endTime);
      const durationMs = originalEnd - originalStart;
      const newEnd = new Date(Date.now() + durationMs);
      setEndTime(newEnd.toTimeString().slice(0, 5));
      
      setSelectedDate(new Date()); // Today's date
      
      // Set event details if it's an event
      if (event.isEvent && event.eventDetails) {
        setIsEvent(true);
        setEventTitle(event.eventDetails.title + ' (Copy)');
        setEventType(event.eventDetails.type);
      } else {
        setIsEvent(false);
        setEventTitle('');
        setEventType('event');
      }
    }}
  />
)}
            
            {activeView === 'create' && (
              <div className="grid grid-cols-3 gap-6">
                <div className="col-span-2" style={{display: 'flex', flexDirection: 'column', gap: '1.5rem'}}>
                  <div style={{order: 4}}>
                    <div className="bg-white rounded-lg border border-gray-200 p-4 shadow-sm">
                      <div className="flex justify-between items-center mb-3 pb-2 border-b border-gray-100">
                        <h3 className="text-lg font-semibold text-gray-800">Quick Templates</h3>
                        <button
                          onClick={() => setShowTemplates(!showTemplates)}
                          className="text-sm text-blue-600 hover:text-blue-700 flex items-center gap-1"
                        >
                          <span>{showTemplates ? 'Hide' : 'Show'}</span>
                          <span className="text-xs">
                            {showTemplates ? '△' : '▽'}
                          </span>
                        </button>
                      </div>

                      {showTemplates && (
                        <div className="grid grid-cols-2 gap-3">
                          {blockTemplates.map((template, idx) => (
                            <button
                              key={idx}
                              onClick={() => handleTemplateSelect(template)}
                              className="p-3 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors text-left border border-gray-200"
                            >
                              <p className="font-medium text-gray-800">{template.name}</p>
                              <p className="text-sm text-gray-600">{template.reason}</p>
                            </button>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                  
                  <div style={{order: 1}}>
                    <div className="bg-white rounded-lg border border-gray-200 p-4 shadow-sm">
                      <h3 className="text-lg font-semibold mb-3 text-gray-800 border-b border-gray-100 pb-2" style={{marginTop: '0', lineHeight: '1.75rem'}}>Select Courts to Block</h3>
                      <div className="grid grid-cols-6 gap-2">
                        {[...Array(12)].map((_, idx) => {
                          const courtNum = idx + 1;
                          const isSelected = selectedCourts.includes(courtNum);
                          
                          return (
                            <button
                              key={courtNum}
                              onClick={() => toggleCourtSelection(courtNum)}
                              disabled={editingBlock && editingBlock.courtNumber !== courtNum}
                              className={`py-2 px-3 rounded-lg font-medium transition-all shadow-sm border ${
                                isSelected
                                  ? 'bg-blue-600 text-white border-blue-700 shadow-md'
                                  : editingBlock && editingBlock.courtNumber !== courtNum
                                  ? 'bg-gray-50 text-gray-400 cursor-not-allowed border-gray-200'
                                  : 'bg-white hover:bg-gray-50 text-gray-700 border-gray-300 hover:border-gray-400'
                              }`}
                            >
                              Court {courtNum}
                            </button>
                          );
                        })}
                      </div>
                      {!editingBlock && (
                        <div className="mt-3 flex gap-2 pt-2 border-t border-gray-100">
                          <button
                            onClick={() => setSelectedCourts([...Array(12)].map((_, i) => i + 1))}
                            className="text-sm text-blue-600 hover:text-blue-700"
                          >
                            Select All
                          </button>
                          <button
                            onClick={() => setSelectedCourts([])}
                            className="text-sm text-gray-600 hover:text-gray-700"
                          >
                            Clear Selection
                          </button>
                        </div>
                      )}
                    </div>
                  </div>

                  <div style={{order: 2}}>
                    <div className="bg-white rounded-lg border border-gray-200 p-4 shadow-sm">
                      <h3 className="text-lg font-semibold mb-3 text-gray-800 border-b border-gray-100 pb-2">Block Reason</h3>
                      
                      <div className="space-y-3">
                        <div className="flex flex-wrap gap-2">
                          {quickReasons.map((reason) => {
                            const Icon = reason.icon;
                            return (
                              <button
                                 key={reason.label}
                                 onClick={() => {
                                   handleQuickReason(reason.label);
                                   setShowCustomReason(false);
                                 }}
                                className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-colors ${
                                   blockReason === reason.label
                                     ? 'bg-blue-600 text-white'
                                     : reason.color
                               }`}
                             >
                               <Icon size={18} />
                               {reason.label}
                             </button>
                           );
                         })}
                    
                         <button
                           onClick={() => {
                             setShowCustomReason(true);
                             setBlockReason('');
                           }}
                           className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-colors shadow-sm border ${
                              showCustomReason
                                ? 'bg-blue-600 text-white border-blue-700'
                                : 'bg-white hover:bg-gray-50 text-gray-700 border-gray-300 hover:border-gray-400'
                          }`}
                        >
                           <Plus size={18} />
                          Other
                       </button>
                    </div>
                        
                    {showCustomReason && (
                       <input
                         ref={(input) => input && input.focus()}
                         type="text"
                         value={blockReason}
                         onChange={(e) => setBlockReason(e.target.value)}
                         placeholder="Enter custom reason..."
                         className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                      />
                    )}    
                      </div>
                    </div>
                  </div>
                  
                  <div style={{order: 3}}>
                    <div className="bg-white rounded-lg border border-gray-200 p-4 shadow-sm">
                      <VisualTimeEntry
                        key={selectedDate.toISOString()}
                        startTime={startTime}
                        endTime={endTime}
                        onStartTimeChange={setStartTime}
                        onEndTimeChange={setEndTime}
                        selectedDate={selectedDate}
                        selectedCourts={selectedCourts}
                        blockReason={blockReason}
                        timePickerMode={timePickerMode}
                        setTimePickerMode={setTimePickerMode}
                        hideToggleButton={true}
                      />
                    </div>
                  </div>

<ConflictDetector
  courts={courts}
  selectedCourts={selectedCourts}
  startTime={startTime}
  endTime={endTime}
  selectedDate={selectedDate}
  editingBlock={editingBlock}
/>               
                </div>
                
                <div className="space-y-6">
                  <div className="bg-white rounded-lg border border-gray-200 p-4 shadow-sm">
                    <h3 className="text-lg font-semibold mb-3 text-gray-800 border-b border-gray-100 pb-2" style={{marginTop: '0', lineHeight: '1.75rem'}}>Select Date</h3>
                    
                    <MiniCalendar
  selectedDate={selectedDate}
  onDateSelect={setSelectedDate}
/>
                 
                    <div className="mt-3 p-3 bg-gray-50 rounded-lg border border-gray-200">
                      <div className="flex items-center gap-2 text-sm">
                        <CalendarDays size={16} className="text-gray-600" />
                        <span className="font-medium">
                          {selectedDate.toLocaleDateString('en-US', { 
                            weekday: 'long', 
                            month: 'long', 
                            day: 'numeric',
                            year: 'numeric'
                          })}
                        </span>
                      </div>
                    </div>
                  </div>

                  {/* Wet Court Management Panel */}
                  {wetCourtsActive && (
                    <div className="p-4 bg-red-50 border border-red-200 rounded-lg mb-4">
                      <div className="flex items-center justify-between mb-3">
                        <h4 className="font-medium text-red-900">🌧️ Wet Court Conditions</h4>
                        <span className="text-sm text-red-700">
                          {12 - wetCourts.size}/12 courts operational
                        </span>
                      </div>
                      
                      <p className="text-sm text-red-800 mb-4">
                        Click courts below as they dry to resume normal operations.
                      </p>
                      
                      {/* Court Grid */}
                      <div className="grid grid-cols-4 gap-2 mb-4">
                        {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map(courtNum => {
                          const isWet = wetCourts.has(courtNum);
                          return (
                            <button
                              key={courtNum}
                              onClick={() => clearWetCourt(courtNum)}
                              className={`p-2 rounded text-sm font-medium transition-all ${
                                isWet
                                  ? 'bg-blue-500 text-white hover:bg-blue-600'
                                  : 'bg-blue-100 text-blue-800 hover:bg-blue-200'
                              }`}
                            >
                              Court {courtNum}
                              <div className="text-xs mt-1">
                                {isWet ? '💧 Wet' : '☀️ Dry'}
                              </div>
                            </button>
                          );
                        })}
                      </div>

                      {/* Quick Action */}
                      <button
                        onClick={() => {
                          setWetCourts(new Set());
                          setWetCourtsActive(false);
                          removeAllWetCourtBlocks();
                        }}
                        className="w-full py-2 px-3 bg-green-600 text-white rounded text-sm hover:bg-green-700 font-medium"
                      >
                        ✅ All Courts Dry - Resume Normal Operations
                      </button>
                    </div>
                  )}

                  {(selectedCourts.length > 0 || blockReason || startTime || endTime) && (
                    <div className="p-4 bg-blue-50 rounded-lg">
                      <h4 className="font-medium text-blue-900 mb-3">Block Summary</h4>
                      <div className="space-y-2 text-sm text-blue-800">
                        {selectedCourts.length > 0 && (
                          <div>
                            <span className="font-medium">Courts:</span> {selectedCourts.sort((a, b) => a - b).join(', ')}
                          </div>
                        )}
                        {blockReason && (
                          <div>
                            <span className="font-medium">Reason:</span> {blockReason}
                          </div>
                        )}
                        {startTime && endTime && (
                          <div>
                            <span className="font-medium">Time:</span> {
                              startTime === 'now' ? 'Now' : startTime
                            } - {endTime}
                          </div>
                        )}
                        {recurrence && (
                          <div>
                            <span className="font-medium">Repeats:</span> {recurrence.pattern}ly for {
                              recurrence.endType === 'after' 
                                ? `${recurrence.occurrences} times`
                                : `until ${recurrence.endDate}`
                            }
                          </div>
                        )}
                        {isEvent && (
                          <div>
                            <span className="font-medium">Event Calendar:</span> Yes ({eventType})
                          </div>
                        )}
                      </div>
                    </div>
                  )}
             
                  <div>
                    <h3 className="text-lg font-semibold mb-3">Event Title</h3>
                    <input
                      type="text"
                      value={eventTitle}
                      onChange={(e) => setEventTitle(e.target.value)}
                      placeholder="e.g., Summer League - Division A"
                      className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                 </div>

                 <div className="flex items-center gap-4">
  <label className="flex items-center gap-3">
    <input
      type="checkbox"
      checked={!isEvent}
      onChange={(e) => setIsEvent(!e.target.checked)}
      className="w-4 h-4 text-red-600 rounded"
    />
    <span className="font-medium">Hide on Calendar View</span>
  </label>
  
  <button
    onClick={() => setShowRecurrence(!showRecurrence)}
    className="py-2 px-3 rounded-lg font-medium transition-all shadow-sm border bg-white hover:bg-blue-50 text-gray-700 border-blue-300 hover:border-blue-400"
  >
    <div className="flex items-center gap-2">
      <span>Repeat</span>
      <span className="text-sm text-blue-600">
        {showRecurrence ? '△' : '▽'}
      </span>
    </div>
  </button>
</div>

{showRecurrence && (
  <RecurrenceConfig
    recurrence={recurrence}
    onRecurrenceChange={setRecurrence}
  />
)}
                  <div className="bg-white rounded-lg border border-gray-200 p-4 shadow-sm">
                    <button
                      onClick={handleBlockCourts}
                      disabled={!isValid}
                      className={`w-full py-3 rounded-lg font-medium transition-colors ${
                        isValid
                          ? 'bg-blue-600 text-white hover:bg-blue-700'
                          : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                      }`}
                    >
                      {editingBlock ? 'Update' : 'Apply'} Block to {
                        selectedCourts.length <= 3 
                          ? `Court${selectedCourts.length !== 1 ? 's' : ''} ${selectedCourts.sort((a, b) => a - b).join(', ')}`
                          : `${selectedCourts.length} Courts`
                      }
                      {recurrence && ` (${recurrence.pattern}ly)`}
                    </button>

                    <button
                      onClick={wetCourtsActive ? deactivateWetCourts : handleEmergencyWetCourt}
                      className={`w-full mt-3 flex items-center justify-center gap-2 px-3 py-2 rounded-lg font-medium transition-all border ${
                        wetCourtsActive
                          ? 'bg-gray-600 text-white border-blue-400 ring-1 ring-blue-400 shadow-md'
                          : 'bg-blue-50 hover:bg-blue-100 text-gray-700 border-blue-300 hover:border-blue-400'
                      }`}
                    >
                      <Droplets size={16} />
                      WET COURTS
                      {wetCourtsActive && wetCourts.size > 0 && (
                        <span className="ml-1 px-1.5 py-0.5 bg-blue-500 text-white text-xs rounded-full">
                          {wetCourts.size}
                        </span>
                      )}
                    </button>
                  </div>

                </div>
              </div>
            )}
          </div>
        );
      };

// Mock AI Admin Component - Add this to your tennis app
const MockAIAdmin = ({ onClose, dataStore, courts, loadData, clearCourt, clearAllCourts, moveCourt, settings, updateBallPrice, waitingGroups, refreshData }) => {
  const [messages, setMessages] = useState([
    { 
      role: 'assistant', 
      content: 'Hi! I can help you manage the courts. Try commands like:\n• "Block court 5 for maintenance"\n• "Who\'s playing right now?"\n• "Clear court 3"\n• "Move players from court 12 to court 6"\n• "Show waitlist"\n• "Set ball price to $6.50"'
    }
  ]);
  const [input, setInput] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [pendingAction, setPendingAction] = useState(null);
  const messagesEndRef = useRef(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // Mock command parser
  const parseCommand = (command) => {
    const lower = command.toLowerCase();
    
    // Block court commands
    if (lower.includes('block')) {
      const courtMatch = lower.match(/court[s]?\s+(\d+(?:\s*(?:,|and|&)\s*\d+)*)/);
      const timePattern = /(\d{1,2})\s*(?::|to|-)\s*(\d{1,2})\s*(?:am|pm)?/i;
      const timeMatch = lower.match(timePattern);
      const tomorrowMatch = lower.includes('tomorrow');
      const reasonMatch = lower.match(/for\s+(\w+)/);
      
      if (courtMatch) {
        // Parse court numbers (handles "1", "1,2", "1 and 2", "1, 3, and 5")
        const courtsText = courtMatch[1];
        const courtNumbers = courtsText.match(/\d+/g).map(n => parseInt(n));
        
        // Determine reason
        let reason = 'BLOCKED';
        if (lower.includes('maintenance') || lower.includes('work')) reason = 'MAINTENANCE';
        else if (lower.includes('lesson')) reason = 'LESSON';
        else if (lower.includes('wet') || lower.includes('rain')) reason = 'WET COURT';
        else if (reasonMatch) reason = reasonMatch[1].toUpperCase();
        
        // Parse times
        let startTime, endTime;
        const now = new Date();
        
        if (timeMatch) {
          const [_, start, end] = timeMatch;
          startTime = `${start}:00`;
          endTime = `${end}:00`;
        } else if (lower.includes('hour')) {
          const hourMatch = lower.match(/(\d+)\s*hour/);
          const hours = hourMatch ? parseInt(hourMatch[1]) : 2;
          startTime = now.toTimeString().slice(0, 5);
          const endDate = new Date(now.getTime() + hours * 60 * 60 * 1000);
          endTime = endDate.toTimeString().slice(0, 5);
        } else {
          // Default: 2 hours from now
          startTime = now.toTimeString().slice(0, 5);
          const endDate = new Date(now.getTime() + 2 * 60 * 60 * 1000);
          endTime = endDate.toTimeString().slice(0, 5);
        }
        
        return {
          action: 'blockCourts',
          courts: courtNumbers,
          reason: reason,
          startTime: startTime,
          endTime: endTime,
          date: tomorrowMatch ? 'tomorrow' : 'today',
          confirmMessage: `Block court${courtNumbers.length > 1 ? 's' : ''} ${courtNumbers.join(', ')} ${tomorrowMatch ? 'tomorrow' : 'today'} from ${startTime} to ${endTime} for ${reason.toLowerCase()}`
        };
      }
    }
    
    // Clear court commands
    if (lower.includes('clear')) {
      if (lower.includes('all')) {
        return {
          action: 'clearAllCourts',
          confirmMessage: 'Clear all courts (this will make all courts immediately available)'
        };
      }
      if (lower.includes('waitlist')) {
        return {
          action: 'clearWaitlist',
          confirmMessage: 'Remove all groups from the waitlist'
        };
      }
      const courtMatch = lower.match(/court\s+(\d+)/);
      if (courtMatch) {
        return {
          action: 'clearCourt',
          courtNumber: parseInt(courtMatch[1]),
          confirmMessage: `Clear court ${courtMatch[1]}`
        };
      }
    }
    
    // Move players command
    if (lower.includes('move')) {
      const fromMatch = lower.match(/(?:from\s+)?court\s+(\d+)/);
      const toMatch = lower.match(/to\s+court\s+(\d+)/);
      
      if (fromMatch && toMatch) {
        return {
          action: 'movePlayers',
          fromCourt: parseInt(fromMatch[1]),
          toCourt: parseInt(toMatch[1]),
          confirmMessage: `Move players from court ${fromMatch[1]} to court ${toMatch[1]}`
        };
      }
    }
    
    // Status/query commands
    if (lower.includes('who') && (lower.includes('play') || lower.includes('court'))) {
      return { action: 'showStatus' };
    }
    
    if (lower.includes('waitlist') || lower.includes('waiting')) {
      return { action: 'showWaitlist' };
    }
    
    // Ball price command
    if (lower.includes('ball') && lower.includes('price')) {
      const priceMatch = lower.match(/\$?(\d+\.?\d*)/);
      if (priceMatch) {
        return {
          action: 'setBallPrice',
          price: parseFloat(priceMatch[1]),
          confirmMessage: `Set tennis ball price to $${parseFloat(priceMatch[1]).toFixed(2)}`
        };
      }
    }
    
    // Ball sales report
    if (lower.includes('ball') && (lower.includes('sale') || lower.includes('sold'))) {
      return { action: 'showBallSales' };
    }
    
    return { action: 'unknown' };
  };

  // Execute mock commands
  const executeCommand = async (action) => {
    // Get current data from dataStore
    const data = await dataStore.get('tennisClubData') || { courts: [], waitingGroups: [] };
    
    switch (action.action) {
      case 'blockCourts':
        // Create block times
        const now = new Date();
        let startDateTime = new Date();
        let endDateTime = new Date();
        
        if (action.date === 'tomorrow') {
          startDateTime.setDate(startDateTime.getDate() + 1);
          endDateTime.setDate(endDateTime.getDate() + 1);
        }
        
        const [startHour, startMin] = action.startTime.split(':');
        const [endHour, endMin] = action.endTime.split(':');
        
        startDateTime.setHours(parseInt(startHour), parseInt(startMin), 0, 0);
        endDateTime.setHours(parseInt(endHour), parseInt(endMin), 0, 0);
        
        // read form values from existing variables
        const name = action.reason || 'Block'; // use reason as name for mock commands
        const reason = action.reason || '';
        const durationMinutes = Math.round((endDateTime - startDateTime) / (1000 * 60));
        const selectedCourts = action.courts;

        // validate minimally
        if (!name || !reason || !Number.isFinite(durationMinutes) || durationMinutes <= 0 || !Array.isArray(selectedCourts) || selectedCourts.length === 0) {
          alert('Please provide name, reason, positive duration, and at least one court.');
          return;
        }

        const template = { name, reason, duration: Number(durationMinutes), courts: selectedCourts };
        // const now = new Date(); // Already declared at line 4665

        // domain: build blocks (one per court)
        const newBlocks = BL.applyTemplate({ template, now }); // <-- correct call shape

        // load/persist using existing key
        const key = Storage.STORAGE.BLOCKS; // "courtBlocks"
        const existing = Storage.readJSON(key) || [];

        // Prevent conflicts: if any new block overlaps an existing block on the same court, abort with a clear message.
        const conflicts = [];
        for (const nb of newBlocks) {
          for (const b of existing) {
            if (b.courtNumber === nb.courtNumber && BL.overlaps(nb, b)) {
              conflicts.push(nb.courtNumber);
              break;
            }
          }
        }
        if (conflicts.length) {
          alert(`Cannot add blocks. Overlaps on courts: ${[...new Set(conflicts)].sort((a,b)=>a-b).join(', ')}`);
          return;
        }

        // Preserve additional properties
        for (const nb of newBlocks) {
          nb.id = `block-${Date.now()}-${nb.courtNumber}`;
          nb.createdAt = new Date().toISOString();
        }

        const next = existing.concat(newBlocks);
        Storage.writeJSON(key, next);
        Events.emitDom('tennisDataUpdate', { key, data: next }); // notify other pages
        console.log('[Admin] wrote blocks:', newBlocks);
        
        refreshData();
        
        return `✓ Blocked court${action.courts.length > 1 ? 's' : ''} ${action.courts.join(', ')}`;
        
      case 'clearCourt':
        const result = await clearCourt(action.courtNumber);
        return result.success ? `✓ Cleared court ${action.courtNumber}` : `✗ ${result.error || 'Failed to clear court'}`;
        
      case 'clearAllCourts':
        await clearAllCourts();
        return '✓ All courts cleared';
        
      case 'clearWaitlist':
        // Clear waitlist via service
        const TD = window.TennisDataService || window.Tennis?.DataService || window.Tennis?.Services?.Data;
        if (typeof TD?.clearWaitlist === 'function') {
          await TD.clearWaitlist({ source: 'admin' });
        } else {
          throw new Error('No clearWaitlist service available');
        }
        refreshData();
        return '✓ Waitlist cleared';
        
      case 'movePlayers':
        const moveResult = await moveCourt(action.fromCourt, action.toCourt);
        return moveResult.success ? 
          `✓ Moved players from court ${action.fromCourt} to court ${action.toCourt}` : 
          `✗ ${moveResult.error || 'Failed to move players'}`;
        
      case 'setBallPrice':
        try {
          await updateBallPrice(action.price.toString());
          return `✓ Ball price set to $${action.price.toFixed(2)}`;
        } catch (e) {
          return '✗ Failed to update ball price';
        }
        
      case 'showStatus':
        const occupied = [];
        data.courts.forEach((court, idx) => {
          if (court && (court.players?.length > 0 || court.current?.players?.length > 0)) {
            const players = court.current?.players || court.players || [];
            occupied.push({
              court: idx + 1,
              players: players.map(p => p.name.split(' ').pop()).join(', ')
            });
          }
        });
        
        if (occupied.length === 0) {
          return 'All courts are currently available.';
        }
        
        return `Currently ${occupied.length} courts occupied:\n` + 
          occupied.map(c => `• Court ${c.court}: ${c.players}`).join('\n') +
          `\n\n${courts.length - occupied.length} courts available.`;
        
      case 'showWaitlist':
        if (waitingGroups.length === 0) {
          return 'No groups currently waiting.';
        }
        
        return `${waitingGroups.length} groups waiting:\n` +
          waitingGroups.map((g, i) => 
            `${i + 1}. ${g.players.map(p => p.name.split(' ').pop()).join(', ')}`
          ).join('\n');
          
      case 'showBallSales':
        let sales = [];
        try { sales = JSON.parse(localStorage.getItem('tennisBallPurchases') || '[]'); }
        catch { /* transient partial write; use empty array */ }
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        const todaySales = sales.filter(s => new Date(s.timestamp) >= today);
        const total = todaySales.reduce((sum, s) => sum + s.totalAmount, 0);
        
        return `Ball sales today:\n• ${todaySales.length} purchases\n• Total: $${total.toFixed(2)}`;
        
      default:
        return '✗ Command not recognized';
    }
  };

  const handleSend = async () => {
    if (!input.trim() || isProcessing) return;
    
    // Add user message
    setMessages(prev => [...prev, { role: 'user', content: input }]);
    setInput('');
    setIsProcessing(true);
    
    // Simulate processing delay
    setTimeout(async () => {
      const parsed = parseCommand(input);
      
      if (parsed.action === 'unknown') {
        setMessages(prev => [...prev, {
          role: 'assistant',
          content: `I didn't understand that command. Try:\n• "Block court 5 from 2-4pm"\n• "Who's playing?"\n• "Clear court 3"\n• "Move court 12 to court 6"\n• "Set ball price to $6.50"`,
          error: true
        }]);
      } else if (parsed.confirmMessage) {
        // Needs confirmation
        setMessages(prev => [...prev, {
          role: 'assistant',
          content: parsed.confirmMessage + '?',
          warning: parsed.action.includes('clear')
        }]);
        setPendingAction(parsed);
      } else {
        // Execute immediately (status queries)
        const result = await executeCommand(parsed);
        setMessages(prev => [...prev, {
          role: 'assistant',
          content: result
        }]);
      }
      
      setIsProcessing(false);
    }, 600);
  };

  const handleConfirm = async () => {
    if (pendingAction) {
      const result = await executeCommand(pendingAction);
      setMessages(prev => [...prev, {
        role: 'system',
        content: result
      }]);
      setPendingAction(null);
    }
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-900 rounded-xl w-full max-w-3xl h-[600px] flex flex-col mx-4">
        {/* Header */}
        <div className="p-4 border-b border-gray-700 flex justify-between items-center">
          <div>
            <h2 className="text-xl font-bold text-white">AI Admin Assistant</h2>
            <p className="text-sm text-gray-400">Natural language court management</p>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-white transition-colors"
          >
            <X size={24} />
          </button>
        </div>
        
        {/* Messages */}
        <div className="flex-1 overflow-y-auto p-4 space-y-4">
          {messages.map((message, index) => (
            <div
              key={index}
              className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
            >
              <div
                className={`max-w-[80%] rounded-lg p-3 ${
                  message.role === 'user'
                    ? 'bg-blue-600 text-white'
                    : message.role === 'system'
                    ? 'bg-green-800 text-green-100'
                    : message.warning
                    ? 'bg-orange-800 text-orange-100'
                    : message.error
                    ? 'bg-red-800 text-red-100'
                    : 'bg-gray-700 text-gray-100'
                }`}
              >
                <div className="whitespace-pre-wrap">{message.content}</div>
              </div>
            </div>
          ))}
          
          {isProcessing && (
            <div className="flex justify-start">
              <div className="bg-gray-700 text-gray-100 rounded-lg p-3">
                <div className="flex items-center gap-2">
                  <div className="animate-spin h-4 w-4 border-2 border-gray-300 border-t-white rounded-full"></div>
                  <span>Processing...</span>
                </div>
              </div>
            </div>
          )}
          
          {pendingAction && (
            <div className="flex justify-center gap-2 mt-4">
              <button
                onClick={handleConfirm}
                className="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700 transition-colors flex items-center gap-2"
              >
                <Check size={16} />
                Confirm
              </button>
              <button
                onClick={() => setPendingAction(null)}
                className="bg-gray-600 text-white px-6 py-2 rounded-lg hover:bg-gray-700 transition-colors flex items-center gap-2"
              >
                Cancel
              </button>
            </div>
          )}
          
          <div ref={messagesEndRef} />
        </div>
        
        {/* Input */}
        <div className="p-4 border-t border-gray-700">
          <div className="flex gap-2">
            <input
              type="text"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyPress={(e) => e.key === 'Enter' && handleSend()}
              placeholder="Type a command..."
              className="flex-1 bg-gray-800 text-white px-4 py-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={isProcessing}
              autoFocus
            />
            <button
              onClick={handleSend}
              disabled={!input.trim() || isProcessing}
              className="bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <ChevronRight size={20} />
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

// Game History Search Component
const GameHistorySearch = () => {
  const [searchFilters, setSearchFilters] = useState({
    courtNumber: '',
    playerName: '',
    startDate: '',
    endDate: ''
  });
  const [searchResults, setSearchResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);
  const [hasSearched, setHasSearched] = useState(false);

  const handleSearch = () => {
    setIsSearching(true);
    setHasSearched(true);
    
    // Build filters object
    const filters = {};
    if (searchFilters.courtNumber) filters.courtNumber = parseInt(searchFilters.courtNumber);
    if (searchFilters.playerName) filters.playerName = searchFilters.playerName;
    if (searchFilters.startDate) filters.startDate = searchFilters.startDate;
    if (searchFilters.endDate) filters.endDate = searchFilters.endDate;

    // Use shared utils to search historical games
    const results = U.searchHistoricalGames ? U.searchHistoricalGames(filters) : [];
    setSearchResults(results);
    setIsSearching(false);
  };

  const handleClearFilters = () => {
    setSearchFilters({
      courtNumber: '',
      playerName: '',
      startDate: '',
      endDate: ''
    });
    setSearchResults([]);
    setHasSearched(false);
  };

  const formatTime = (dateString) => {
    return new Date(dateString).toLocaleTimeString([], { 
      hour: 'numeric', 
      minute: '2-digit',
      hour12: true 
    });
  };

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString([], { 
      month: 'short', 
      day: 'numeric',
      year: 'numeric'
    });
  };

  return (
    <div className="bg-white rounded-lg shadow-sm p-6">
      <h3 className="text-lg font-semibold text-gray-800 mb-6">Game History Search</h3>
      
      {/* Search Filters */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">Court Number</label>
          <select
            value={searchFilters.courtNumber}
            onChange={(e) => setSearchFilters(prev => ({ ...prev, courtNumber: e.target.value }))}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="">All Courts</option>
            {[...Array(12)].map((_, i) => (
              <option key={i + 1} value={i + 1}>Court {i + 1}</option>
            ))}
          </select>
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">Player Name</label>
          <input
            type="text"
            placeholder="Search by player name..."
            value={searchFilters.playerName}
            onChange={(e) => setSearchFilters(prev => ({ ...prev, playerName: e.target.value }))}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">Start Date</label>
          <input
            type="date"
            value={searchFilters.startDate}
            onChange={(e) => setSearchFilters(prev => ({ ...prev, startDate: e.target.value }))}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">End Date</label>
          <input
            type="date"
            value={searchFilters.endDate}
            onChange={(e) => setSearchFilters(prev => ({ ...prev, endDate: e.target.value }))}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>
      </div>

      {/* Search Actions */}
      <div className="flex gap-3 mb-6">
        <button
          onClick={handleSearch}
          disabled={isSearching}
          className="px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50"
        >
          {isSearching ? 'Searching...' : 'Search Games'}
        </button>
        <button
          onClick={handleClearFilters}
          className="px-6 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500"
        >
          Clear Filters
        </button>
      </div>

      {/* Search Results */}
      {hasSearched && (
        <div className="border-t pt-6">
          <h4 className="text-md font-semibold text-gray-800 mb-4">
            Search Results ({searchResults.length} games found)
          </h4>
          
          {searchResults.length === 0 ? (
            <div className="text-center py-8 text-gray-500">
              <FileText size={48} className="mx-auto mb-2 opacity-50" />
              <p>No games found matching your criteria.</p>
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Court
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Date
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Time
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Players
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Duration
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {searchResults.map((game, idx) => (
                    <tr key={game.id || idx} className="hover:bg-gray-50">
                      <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                        Court {game.courtNumber}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {formatDate(game.startTime)}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {formatTime(game.startTime)} - {formatTime(game.endTime)}
                      </td>
                      <td className="px-6 py-4 text-sm text-gray-900">
                        <div className="space-y-1">
                          {game.players.map((player, pidx) => (
                            <div key={pidx} className="text-sm">
                              {player.name || player}
                            </div>
                          ))}
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {(() => {
                          const duration = Math.round((new Date(game.endTime) - new Date(game.startTime)) / (1000 * 60));
                          return `${duration} min`;
                        })()}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

// Main Admin Panel Component
const AdminPanelV2 = ({ onExit }) => {
    // AdminPanelV2 component initializing

  const [activeTab, setActiveTab] = useState('status');
  const [courts, setCourts] = useState([]);
  const [waitingGroups, setWaitingGroups] = useState([]);
  const [blockTemplates, setBlockTemplates] = useState([]);
  const [settings, setSettings] = useState({});
  const [notification, setNotification] = useState(null);
  const [currentTime, setCurrentTime] = useState(new Date());
  const [wetCourtsActive, setWetCourtsActive] = useState(false);
  const [wetCourts, setWetCourts] = useState(new Set());
  const [suspendedBlocks, setSuspendedBlocks] = useState([]);
  const [refreshTrigger, setRefreshTrigger] = useState(0);
  const [blockingView, setBlockingView] = useState('create');
  const [courtBlocks, setCourtBlocks] = useState([]);
  const [calendarView, setCalendarView] = useState('day');
  const [showAIAssistant, setShowAIAssistant] = useState(false);
  const [selectedDate, setSelectedDate] = useState(new Date());
  const ENABLE_WET_COURTS = true;

  const handleEmergencyWetCourt = async () => {
  console.log('🌧️ Emergency wet court activated');
  
  // Set all courts as wet in state immediately
  const allCourts = new Set();
  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].forEach(courtNum => {
    WC.markWet(allCourts, courtNum);
  });
  setWetCourts(allCourts);
  setWetCourtsActive(true);

  // Notify (preserve legacy event name for other pages)
  const nextWet = Array.from(allCourts).sort((a,b)=>a-b);
  Events.emitDom('tennisDataUpdate', { key: 'wetCourts', data: nextWet });
  
  try {
    const now = new Date().toISOString();
    let existingBlocks = [];
    try { existingBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]'); }
    catch { /* transient partial write; use empty array */ }
    
    // Create wet court blocks for all courts (1-12)
    const wetCourtBlocks = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map(courtNum => ({
      id: `wet-court-${courtNum}-${Date.now()}`,
      courtNumber: courtNum,
      reason: 'WET COURT',
      startTime: now,
      endTime: (() => {
        const today = new Date();
        const endTime = new Date(today);
        endTime.setHours(22, 0, 0, 0); // 10:00 PM today
        
        if (today.getHours() >= 22) {
          endTime.setDate(endTime.getDate() + 1);
        }
        
        return endTime.toISOString();
      })(),
      isEvent: false,
      isWetCourt: true,
      createdAt: now
    }));
    
    const updatedBlocks = [...existingBlocks, ...wetCourtBlocks];
    await Tennis.BlocksService.saveBlocks(updatedBlocks);
    setRefreshTrigger(prev => prev + 1);
  } catch (error) {
    console.error('Error creating wet court blocks:', error);
  }
};

const handleEditBlockFromStatus = (block) => {
  // Switch to Court Blocking tab and edit mode
  setActiveTab('blocking');
  setBlockingView('create');
  
  // TODO: Pass the block to CompleteBlockManagerEnhanced
  setTimeout(() => {
    console.log('Edit block:', block);
    // You'll need to implement passing this to CompleteBlockManagerEnhanced
  }, 100);
};

const removeAllWetCourtBlocks = async () => {
  if (!ENABLE_WET_COURTS) return;
  
  try {
    let existingBlocks = [];
    try { existingBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]'); }
    catch { /* transient partial write; use empty array */ }
    
    // Remove all wet court blocks
    const updatedBlocks = existingBlocks.filter(block => !block.isWetCourt);
    
    await Tennis.BlocksService.saveBlocks(updatedBlocks);
    setRefreshTrigger(prev => prev + 1);

    console.log('🧹 Removed all wet court blocks');
  } catch (error) {
    console.error('Error removing wet court blocks:', error);
  }
};

const clearWetCourt = async (courtNumber) => {
  console.log(`☀️ Clearing wet court ${courtNumber}`);
  
  const newWetCourts = new Set(wetCourts);
  WC.clearWet(newWetCourts, courtNumber);
  setWetCourts(newWetCourts);

  // Notify (preserve legacy event name for other pages)
  const nextWet = Array.from(newWetCourts).sort((a,b)=>a-b);
  Events.emitDom('tennisDataUpdate', { key: 'wetCourts', data: nextWet });

  // Remove wet court block for this court
  try {
    let existingBlocks = [];
    try { existingBlocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]'); }
    catch { /* transient partial write; use empty array */ }
    const updatedBlocks = existingBlocks.filter(block => 
      !(block.isWetCourt && block.courtNumber === courtNumber)
    );
    await Tennis.BlocksService.saveBlocks(updatedBlocks);
    setRefreshTrigger(prev => prev + 1);
  } catch (error) {
    console.error('Error removing wet court block:', error);
  }

  // If all courts are dry, deactivate system
  if (newWetCourts.size === 0) {
    setWetCourtsActive(false);
    console.log('✅ All courts dry - wet court system deactivated');
  }
};

const deactivateWetCourts = () => {
  if (!ENABLE_WET_COURTS) return;
  
  console.log('🔄 Manually deactivating wet court system');
  setWetCourtsActive(false);
  setWetCourts(new Set());
  setSuspendedBlocks([]);

  // Remove all wet court blocks
  removeAllWetCourtBlocks();
};


  // Load data from localStorage
  const loadData = useCallback(async () => {
    try {
      // Load court data
      const courtData = await dataStore.get(TENNIS_CONFIG.STORAGE.KEY);
      if (courtData) {
        setCourts(courtData.courts || []);
        setWaitingGroups(courtData.waitingGroups || []);
      }

      // Load templates
      const templates = await dataStore.get(TENNIS_CONFIG.STORAGE.BLOCK_TEMPLATES_KEY);
      if (templates) {
        setBlockTemplates(templates);
      }

      // Load settings
      const settingsData = await dataStore.get(TENNIS_CONFIG.STORAGE.SETTINGS_KEY);
      if (settingsData) {
        setSettings(settingsData);
      }
    } catch (error) {
      console.error('Failed to load data:', error);
      onNotification('Failed to load data', 'error');
    }
  }, []);

  window.refreshAdminView = loadData; // export for coalescer & tests
  
  // Event-driven refresh bridge listener
  React.useEffect(() => {
    const onAdminRefresh = () => { loadData(); };
    window.addEventListener('ADMIN_REFRESH', onAdminRefresh);
    return () => window.removeEventListener('ADMIN_REFRESH', onAdminRefresh);
  }, []);

  // Save data to localStorage
  const saveData = useCallback(async (newCourts, newWaitingGroups) => {
    try {
      const data = {
        courts: newCourts || courts,
        waitingGroups: newWaitingGroups || waitingGroups,
        recentlyCleared: []
      };
      
      await dataStore.set(TENNIS_CONFIG.STORAGE.KEY, data, { immediate: true });
      window.dispatchEvent(new Event(TENNIS_CONFIG.STORAGE.UPDATE_EVENT));
      
      showNotification('Changes saved successfully', 'success');
    } catch (error) {
      console.error('Failed to save data:', error);
      showNotification('Failed to save changes', 'error');
    }
  }, [courts, waitingGroups]);

  // Show notification
  const showNotification = (message, type = 'info') => {
    setNotification({ message, type });
    addTimer(setTimeout(() => setNotification(null), 3000), 'timeout');
  };

 // Load data on mount and poll for updates
 useEffect(() => {
    loadData();
    
    // prevent duplicate attachment if this component re-mounts
    if (_one('__ADMIN_LISTENERS_INSTALLED')) return;
    
    // Poll for data changes every 2 seconds
    const pollInterval = addTimer(setInterval(() => {
      console.log('Polling for updates...');
      loadData();
    }, 2000));
    
    // Use coalesced refresh instead of direct handler
    const handleStorageUpdate = scheduleAdminRefresh;

    // Listen for storage events from other apps/tabs
    const handleStorageEvent = (e) => {
      if (e.key === TENNIS_CONFIG.STORAGE.KEY || e.key === 'courtBlocks') {
        console.log('Cross-app storage update detected for:', e.key);
        // Invalidate cache for this key
        dataStore.cache.delete(e.key);
        loadData();
      }
    };
    
    window.addEventListener('tennisDataUpdate', window.scheduleAdminRefresh, { passive: true });
    window.addEventListener('DATA_UPDATED', window.scheduleAdminRefresh, { passive: true });
    window.addEventListener('storage', handleStorageEvent, { passive: true });
    
    // defensive cleanup on unload as well
    window.addEventListener('beforeunload', () => {
      try { clearAllTimers(); } catch {}
      try { window.removeEventListener('tennisDataUpdate', scheduleAdminRefresh); } catch {}
      try { window.removeEventListener('DATA_UPDATED', scheduleAdminRefresh); } catch {}
      try { window.removeEventListener('storage', handleStorageEvent); } catch {}
    }, { once: true });
    
    return () => {
      try { clearInterval(pollInterval); } catch {}
      try { window.removeEventListener('tennisDataUpdate', scheduleAdminRefresh); } catch {}
      try { window.removeEventListener('DATA_UPDATED', scheduleAdminRefresh); } catch {}
      try { window.removeEventListener('storage', handleStorageEvent); } catch {}
    };
  }, [loadData]);

  // Load court blocks from localStorage (ADD HERE)
useEffect(() => {
  const loadBlocks = async () => {
    try {
      const blocks = await dataStore.get('courtBlocks') || [];
      setCourtBlocks(blocks);
    } catch (error) {
      console.error('Error loading court blocks:', error);
    }
  };

  loadBlocks();
  
  // prevent duplicate block listeners
  if (_one('__ADMIN_BLOCK_LISTENERS_INSTALLED')) return;
  
  // Listen for block updates
  const handleBlockUpdate = debounce(() => loadBlocks(), 150);
  
  // Listen for storage events from other apps/tabs
  const handleBlockStorageEvent = (e) => {
    if (e.key === 'courtBlocks') {
      console.log('Cross-app storage update detected for court blocks');
      // Invalidate cache for this key
      dataStore.cache.delete('courtBlocks');
      loadBlocks();
    }
  };
  
  window.addEventListener(TENNIS_CONFIG.STORAGE.UPDATE_EVENT, handleBlockUpdate, { passive: true });
  window.addEventListener('storage', handleBlockStorageEvent, { passive: true });
  
  // defensive cleanup on unload
  window.addEventListener('beforeunload', () => {
    try { window.removeEventListener(TENNIS_CONFIG.STORAGE.UPDATE_EVENT, handleBlockUpdate); } catch {}
    try { window.removeEventListener('storage', handleBlockStorageEvent); } catch {}
  }, { once: true });
  
  return () => {
    try { window.removeEventListener(TENNIS_CONFIG.STORAGE.UPDATE_EVENT, handleBlockUpdate); } catch {}
    try { window.removeEventListener('storage', handleBlockStorageEvent); } catch {}
  };
}, []);

// Update current time every second
useEffect(() => {
    const timer = addTimer(setInterval(() => {
      setCurrentTime(new Date());
    }, 1000));
    
    return () => { try { clearInterval(timer); } catch {} };
  }, []);

  // Court operations
  const clearCourt = async (courtNumber) => {
  // Use TennisDataService API which handles history preservation
  try {
    const TD = window.TennisDataService || window.Tennis?.DataService || window.Tennis?.Services?.Data;
    if (typeof TD?.clearCourt === 'function') {
      await TD.clearCourt(courtNumber, { source: 'admin' });
    } else if (typeof TD?.unassignCourt === 'function') {
      await TD.unassignCourt(courtNumber, { source: 'admin' });
    } else {
      throw new Error('No clearCourt/unassignCourt service available');
    }
    loadData(); // Refresh admin display
  } catch (error) {
    console.error('Error clearing court:', error);
    showNotification('Failed to clear court', 'error');
  }
};

  const moveCourt = async (from, to) => {
    const TD = window.TennisDataService || window.Tennis?.DataService;
    const f = Number(from), t = Number(to);

    if (!TD?.moveCourt) {
      Tennis?.UI?.toast?.('Move is temporarily unavailable', { type:'error' });
      return { success:false, error:'Service unavailable' };
    }

    const res = await TD.moveCourt(f, t);

    if (!res?.success) {
      Tennis?.UI?.toast?.(res?.error || 'Failed to move court', { type:'error' });
      return res;
    }

    Tennis?.UI?.toast?.(`Moved from Court ${res.from} to Court ${res.to}`, { type:'success' });

    // Belt & suspenders: coalescer should refresh, but trigger explicit refresh too.
    window.refreshAdminView?.();

    return res;
  };

  const clearAllCourts = () => {
  const confirmMessage = 'Are you sure you want to clear ALL courts?\n\n' +
    'This will remove:\n' +
    '• All current games\n' +
    '• All court blocks\n' +
    '• All wet court statuses\n\n' +
    'This action cannot be undone!';
    
  if (window.confirm(confirmMessage)) {
    // Clear all courts
    const newCourts = Array(TENNIS_CONFIG.COURTS.TOTAL_COUNT).fill(null);
    saveData(newCourts, waitingGroups);
    
    // Clear all blocks from localStorage
    dataStore.set('courtBlocks', [], { immediate: true });
    
    // Trigger update
    window.dispatchEvent(new Event(TENNIS_CONFIG.STORAGE.UPDATE_EVENT));
    setRefreshTrigger(prev => prev + 1);
    
    showNotification('All courts cleared successfully', 'success');
  }
};

// Add existingBlocks calculation
const existingBlocks = courts.filter(c => c?.blocked).map((c, i) => ({
  court: i + 1,
  ...c.blocked
}));


  // Block operations
  const applyBlocks = async (blocks) => {
    if (!blocks || !Array.isArray(blocks)) {
      return;
    }

    let successCount = 0;
    
    // Process all blocks and courts
    for (const block of blocks) {
      // read form values from existing variables
      const name = block.title || block.name || '';
      const reason = block.reason || '';
      const startTime = new Date(block.startTime);
      const endTime = new Date(block.endTime);
      const durationMinutes = Math.round((endTime - startTime) / (1000 * 60));
      const selectedCourts = Array.isArray(block.courts) ? block.courts : [block.courtNumber];

      // validate minimally
      if (!name || !reason || !Number.isFinite(durationMinutes) || durationMinutes <= 0 || !Array.isArray(selectedCourts) || selectedCourts.length === 0) {
        alert('Please provide name, reason, positive duration, and at least one court.');
        return;
      }

      const template = { name, reason, duration: Number(durationMinutes), courts: selectedCourts };
      const now = new Date();

      // domain: build blocks (one per court)
      const newBlocks = BL.applyTemplate({ template, now }); // <-- correct call shape

      // load/persist using existing key
      const key = Storage.STORAGE.BLOCKS; // "courtBlocks"
      const existing = Storage.readJSON(key) || [];

      // optional: prevent overlaps (keeps current UX; skip if you already do this elsewhere)
      const conflicts = [];
      for (const nb of newBlocks) {
        for (const b of existing) {
          if (b.courtNumber === nb.courtNumber && BL.overlaps(nb, b)) { conflicts.push(nb.courtNumber); break; }
        }
      }
      if (conflicts.length) {
        alert(`Cannot add blocks. Overlaps on courts: ${[...new Set(conflicts)].sort((a,b)=>a-b).join(', ')}`);
        return;
      }

      // Preserve additional properties from original block
      for (const nb of newBlocks) {
        nb.id = block.id || Date.now() + Math.random();
        nb.title = block.title; // Preserve the custom title
        nb.isEvent = block.isEvent;
        nb.eventDetails = block.eventDetails;
        nb.createdAt = new Date().toISOString();
      }

      const next = existing.concat(newBlocks);
      Storage.writeJSON(key, next);
      Events.emitDom('tennisDataUpdate', { key, data: next }); // notify other pages
      console.log('[Admin] wrote blocks:', newBlocks);

      successCount += newBlocks.length;
    }

    showNotification(`Applied ${successCount} block(s) successfully`, 'success');
  };

  // Template operations
  const saveTemplate = async (template) => {
    const newTemplates = [...blockTemplates, template];
    setBlockTemplates(newTemplates);
    await dataStore.set(TENNIS_CONFIG.STORAGE.BLOCK_TEMPLATES_KEY, newTemplates, { immediate: true });
    onNotification('Template saved', 'success');
  };

  const deleteTemplate = async (id) => {
    const newTemplates = blockTemplates.filter(t => t.id !== id);
    setBlockTemplates(newTemplates);
    await dataStore.set(TENNIS_CONFIG.STORAGE.BLOCK_TEMPLATES_KEY, newTemplates, { immediate: true });
    onNotification('Template deleted', 'success');
  };

  const applyTemplate = (template) => {
    const now = new Date();
    const [hours, minutes] = now.toTimeString().split(':');
    
    applyBlocks([{
      date: now.toISOString().split('T')[0],
      time: `${hours}:${minutes}`,
      duration: template.duration,
      courts: template.courts,
      reason: template.reason
    }]);
  };

  // Waitlist operations
  const removeFromWaitlist = (index) => {
    const newWaitingGroups = waitingGroups.filter((_, i) => i !== index);
    saveData(courts, newWaitingGroups);
  };

  const moveInWaitlist = (from, to) => {
    const newWaitingGroups = [...waitingGroups];
    const [group] = newWaitingGroups.splice(from, 1);
    newWaitingGroups.splice(to, 0, group);
    saveData(courts, newWaitingGroups);
  };

  // Settings operations
  const updateBallPrice = async (price) => {
    const newSettings = { ...settings, tennisBallPrice: parseFloat(price) };
    setSettings(newSettings);
    await dataStore.set(TENNIS_CONFIG.STORAGE.SETTINGS_KEY, newSettings, { immediate: true });
    onNotification('Ball price updated', 'success');
  };
// AdminPanelV2 rendering complete
  return (
    <div className="min-h-screen bg-gray-100">

     {/* Tab Navigation */}
<div className="bg-gray-50 sticky top-0 z-40">
  <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <div className="flex justify-between items-center">
      {/* Tabs Container */}
      <div className="flex items-end gap-2 py-4">
        {/* Court Status Tab */}
        <button
          onClick={() => setActiveTab('status')}
          className={`flex items-center gap-2 px-4 py-3 font-medium transition-all duration-200 ${
            activeTab === 'status'
              ? 'bg-white text-gray-900 rounded-lg shadow-lg shadow-blue-200 border border-blue-200 transform -translate-y-px'
              : 'bg-gray-200 text-gray-600 rounded-lg hover:bg-gray-300'
          }`}
        >
          <span style={activeTab !== 'status' ? greyFilter : {}}>
            {React.createElement(Grid, { size: 24 })}
          </span>
          <span>Court Status</span>
        </button>

        {/* Event Calendar Tab - No sub-tabs */}
        <button
          onClick={() => setActiveTab('calendar')}
          className={`flex items-center gap-2 px-4 py-3 font-medium transition-all duration-200 ${
            activeTab === 'calendar'
              ? 'bg-white text-gray-900 rounded-lg shadow-lg shadow-blue-200 border border-blue-200 transform -translate-y-px'
              : 'bg-gray-200 text-gray-600 rounded-lg hover:bg-gray-300'
          }`}
        >
          <span style={activeTab !== 'calendar' ? greyFilter : {}}>
            {React.createElement(Calendar, { size: 24 })}
          </span>
          <span>Event Calendar</span>
        </button>

        {/* Court Blocking Tab */}
        <button
          onClick={() => {
            setActiveTab('blocking');
            setBlockingView('create');
          }}
          className={`flex items-center gap-2 px-4 py-3 font-medium transition-all duration-200 ${
            activeTab === 'blocking'
              ? 'bg-white text-gray-900 rounded-lg shadow-lg shadow-blue-200 border border-blue-200 transform -translate-y-px'
              : 'bg-gray-200 text-gray-600 rounded-lg hover:bg-gray-300'
          }`}
        >
          <span style={activeTab !== 'blocking' ? greyFilter : {}}>
            {React.createElement(Calendar, { size: 24 })}
          </span>
          <span>Court Blocking</span>
        </button>

        {/* Analytics Tab */}
        <button
          onClick={() => setActiveTab('analytics')}
          className={`flex items-center gap-2 px-4 py-3 font-medium transition-all duration-200 ${
            activeTab === 'analytics'
              ? 'bg-white text-gray-900 rounded-lg shadow-lg shadow-blue-200 border border-blue-200 transform -translate-y-px'
              : 'bg-gray-200 text-gray-600 rounded-lg hover:bg-gray-300'
          }`}
        >
          <span style={activeTab !== 'analytics' ? greyFilter : {}}>
            {React.createElement(BarChart, { size: 24 })}
          </span>
          <span>Analytics</span>
        </button>
        
        {/* Game History Tab */}
        <button
          onClick={() => setActiveTab('history')}
          className={`flex items-center gap-2 px-4 py-3 font-medium transition-all duration-200 ${
            activeTab === 'history'
              ? 'bg-white text-gray-900 rounded-lg shadow-lg shadow-blue-200 border border-blue-200 transform -translate-y-px'
              : 'bg-gray-200 text-gray-600 rounded-lg hover:bg-gray-300'
          }`}
        >
          <span style={activeTab !== 'history' ? greyFilter : {}}>
            <FileText size={24} />
          </span>
          <span>Game History</span>
        </button>

        {/* System Tab */}
        <button
          onClick={() => setActiveTab('system')}
          className={`flex items-center gap-2 px-4 py-3 font-medium transition-all duration-200 ${
            activeTab === 'system'
              ? 'bg-white text-gray-900 rounded-lg shadow-lg shadow-blue-200 border border-blue-200 transform -translate-y-px'
              : 'bg-gray-200 text-gray-600 rounded-lg hover:bg-gray-300'
          }`}
        >
          <span style={activeTab !== 'system' ? greyFilter : {}}>
            {React.createElement(Settings, { size: 24 })}
          </span>
          <span>System</span>
        </button>
      </div>
      
      {/* Exit button on the right */}
      <button
        onClick={onExit}
        className="flex items-center gap-2 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
      >
        <ChevronLeft size={20} />
        Exit Admin
      </button>
    </div>
  </div>
  
  {/* Sub-tabs container - Only for Court Blocking now */}
  <div className={`bg-gray-100 border-t border-gray-200 transition-all duration-500 ease-in-out overflow-hidden ${
    activeTab === 'blocking' ? 'max-h-20' : 'max-h-0'
  }`}>
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div className="flex gap-2 py-2">
        {/* Blocking Sub-tabs */}
        {activeTab === 'blocking' && (
          <>
            <button
              onClick={() => setBlockingView('create')}
              className={`px-4 py-2 rounded-lg transition-all duration-200 whitespace-nowrap ${
                blockingView === 'create'
                  ? 'font-bold text-gray-900 bg-blue-50 border border-blue-200'
                  : 'font-normal text-gray-600 hover:bg-gray-50 hover:text-gray-800'
              }`}
            >
              Create Blocks
            </button>
            <button
              onClick={() => setBlockingView('future')}
              className={`px-4 py-2 rounded-lg transition-all duration-200 whitespace-nowrap ${
                blockingView === 'future'
                  ? 'font-bold text-gray-900 bg-blue-50 border border-blue-200'
                  : 'font-normal text-gray-600 hover:bg-gray-50 hover:text-gray-800'
              }`}
            >
              Blocked Time
            </button>
            <button
              onClick={() => setBlockingView('list')}
              className={`px-4 py-2 rounded-lg transition-all duration-200 whitespace-nowrap ${
                blockingView === 'list'
                  ? 'font-bold text-gray-900 bg-blue-50 border border-blue-200'
                  : 'font-normal text-gray-600 hover:bg-gray-50 hover:text-gray-800'
              }`}
            >
              List
            </button>
          </>
        )}
      </div>
    </div>
  </div>
  
  {/* Bottom border line */}
  <div className="h-px bg-gray-200"></div>
</div>
     

  
      {/* Notification */}
      {notification && (
        <div className={`fixed top-4 right-4 z-50 px-6 py-3 rounded-lg shadow-lg ${
          notification.type === 'success' ? 'bg-green-500 text-white' :
          notification.type === 'error' ? 'bg-red-500 text-white' :
          'bg-blue-500 text-white'
        }`}>
          {notification.message}
        </div>
      )}

     

      {/* Content */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="bg-white rounded-lg shadow-sm -mt-px">  {/* ADD THIS LINE */}


        {activeTab === 'status' && (
  <div className="space-y-6 p-6">

    {/* Date Navigation */}
    <div className="bg-white rounded-lg shadow-sm p-4 mb-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <h3 className="text-lg font-semibold text-gray-800">Court Status</h3>
        </div>
        
        <div className="flex items-center gap-3">
          <button 
            onClick={() => {
              const newDate = new Date(selectedDate);
              newDate.setDate(newDate.getDate() - 1);
              setSelectedDate(newDate);
            }}
            className="p-2 hover:bg-gray-100 rounded"
          >
            <ChevronLeft size={20} />
          </button>

          <span className="px-4 py-2 bg-blue-50 text-blue-800 rounded-lg font-medium min-w-[120px] text-center">
            {selectedDate.toDateString() === new Date().toDateString() 
              ? 'Today' 
              : selectedDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })}
          </span>

          <button 
            onClick={() => {
              const newDate = new Date(selectedDate);
              newDate.setDate(newDate.getDate() + 1);
              setSelectedDate(newDate);
            }}
            className="p-2 hover:bg-gray-100 rounded"
          >
            <ChevronRight size={20} />
          </button>
        </div>

        <div className="flex items-center gap-2">
          <button
            onClick={() => setSelectedDate(new Date())}
            className="px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700"
          >
            Today
          </button>
        </div>
      </div>
    </div>

    <CourtStatusGrid
      courts={courts}
      courtBlocks={courtBlocks}
      selectedDate={selectedDate}
      onClearCourt={clearCourt}
      onMoveCourt={moveCourt}
      currentTime={currentTime}
      onEditBlock={handleEditBlockFromStatus}  
      onEmergencyWetCourt={handleEmergencyWetCourt}
      onClearAllCourts={clearAllCourts}
      wetCourtsActive={wetCourtsActive}
      handleEmergencyWetCourt={handleEmergencyWetCourt}
      wetCourts={wetCourts}
      deactivateWetCourts={deactivateWetCourts}
      onClearWetCourt={clearWetCourt}
      onClearAllWetCourts={deactivateWetCourts}
    />
    
    {/* Waitlist Section */}
    <div className={`bg-white rounded-lg shadow-sm ${waitingGroups.length === 0 ? 'p-4' : 'p-6'}`}>

      {waitingGroups.length > 0 && (
  <h3 className="text-lg font-semibold text-gray-800 mb-4">
    Waiting Groups ({waitingGroups.length})
  </h3>
)}
    
      {waitingGroups.length === 0 ? (
        <div className="flex items-center justify-between">
  <h3 className="text-lg font-semibold text-gray-800">Waiting Groups (0)</h3>
  <span className="text-sm text-gray-500">No groups waiting</span>
</div>
      ) : (

        <div className="space-y-3">
          {waitingGroups.map((group, index) => (
            <div key={index} className="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
              <div>
                <p className="font-medium">
                  Position {index + 1}: {group.players.map(p => p.name).join(', ')}
                </p>
                <p className="text-sm text-gray-600">
                  {group.players.length} player{group.players.length > 1 ? 's' : ''}
                </p>
              </div>
              <div className="flex gap-2">
                {index > 0 && (
                  <button
                    onClick={() => moveInWaitlist(index, index - 1)}
                    className="p-1 text-blue-600 hover:bg-blue-50 rounded"
                  >
                    <ChevronLeft size={20} />
                  </button>
                )}
                {index < waitingGroups.length - 1 && (
                  <button
                    onClick={() => moveInWaitlist(index, index + 1)}
                    className="p-1 text-blue-600 hover:bg-blue-50 rounded"
                  >
                    <ChevronRight size={20} />
                  </button>
                )}
                <button
                  onClick={() => removeFromWaitlist(index)}
                  className="p-1 text-red-600 hover:bg-red-50 rounded"
                >
                  <Trash2 size={20} />
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  </div>
)}

{activeTab === 'calendar' && (
  <EventCalendarEnhanced
    courts={courts}
    currentTime={currentTime}
    refreshTrigger={refreshTrigger}
    defaultView={calendarView}
  />
)}

{activeTab === 'blocking' && (
  <div className="space-y-6 p-6 ">
    

    {/* Sub-tab Content */}
    {blockingView === 'create' && (
      <CompleteBlockManagerEnhanced
        courts={courts}
        onApplyBlocks={applyBlocks}
        existingBlocks={existingBlocks}
        wetCourtsActive={wetCourtsActive}
        setWetCourtsActive={setWetCourtsActive}
        wetCourts={wetCourts}
        setWetCourts={setWetCourts}
        suspendedBlocks={suspendedBlocks}
        setSuspendedBlocks={setSuspendedBlocks}
        ENABLE_WET_COURTS={ENABLE_WET_COURTS}
        onNotification={showNotification}
        defaultView="create"
      />
    )}

    {blockingView === 'future' && (
      <CompleteBlockManagerEnhanced
        courts={courts}
        onApplyBlocks={applyBlocks}
        existingBlocks={existingBlocks}
        wetCourtsActive={wetCourtsActive}
        setWetCourtsActive={setWetCourtsActive}
        wetCourts={wetCourts}
        setWetCourts={setWetCourts}
        suspendedBlocks={suspendedBlocks}
        setSuspendedBlocks={setSuspendedBlocks}
        ENABLE_WET_COURTS={ENABLE_WET_COURTS}
        onNotification={showNotification}
        defaultView="calendar"
      />
    )}

    {blockingView === 'list' && (
  <CompleteBlockManagerEnhanced
    courts={courts}
    onApplyBlocks={applyBlocks}
    existingBlocks={existingBlocks}
    wetCourtsActive={wetCourtsActive}
    setWetCourtsActive={setWetCourtsActive}
    wetCourts={wetCourts}
    setWetCourts={setWetCourts}
    suspendedBlocks={suspendedBlocks}
    setSuspendedBlocks={setSuspendedBlocks}
    ENABLE_WET_COURTS={ENABLE_WET_COURTS}
    onNotification={showNotification}
    defaultView="timeline"
  />
)}

  </div>
)}

        {activeTab === 'waitlist' && (
          <div className="bg-white rounded-lg shadow-sm p-6">
            <h3 className="text-lg font-semibold text-gray-800 mb-4">
              Waiting Groups ({waitingGroups.length})
            </h3>
            
            {waitingGroups.length === 0 ? (
              <p className="text-gray-500 text-center py-8">No groups waiting</p>
            ) : (
              <div className="space-y-3">
                {waitingGroups.map((group, index) => (
                  <div key={index} className="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                    <div>
                      <p className="font-medium">
                        Position {index + 1}: {group.players.map(p => p.name).join(', ')}
                      </p>
                      <p className="text-sm text-gray-600">
                        {group.players.length} player{group.players.length > 1 ? 's' : ''}
                      </p>
                    </div>
                    <div className="flex gap-2">
                      {index > 0 && (
                        <button
                          onClick={() => moveInWaitlist(index, index - 1)}
                          className="p-1 text-blue-600 hover:bg-blue-50 rounded"
                        >
                          <ChevronLeft size={20} />
                        </button>
                      )}
                      {index < waitingGroups.length - 1 && (
                        <button
                          onClick={() => moveInWaitlist(index, index + 1)}
                          className="p-1 text-blue-600 hover:bg-blue-50 rounded"
                        >
                          <ChevronRight size={20} />
                        </button>
                      )}
                      <button
                        onClick={() => removeFromWaitlist(index)}
                        className="p-1 text-red-600 hover:bg-red-50 rounded"
                      >
                        <Trash2 size={20} />
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

        {activeTab === 'analytics' && (
          typeof AnalyticsDashboard !== 'undefined' ? (
            <AnalyticsDashboard onClose={null} />
          ) : (
            <div className="p-8 text-center">
              <h3 className="text-lg font-semibold text-gray-600">Analytics Dashboard</h3>
              <p className="text-gray-500 mt-2">Analytics component not available</p>
            </div>
          )
        )}

        {activeTab === 'history' && (
  <GameHistorySearch />
)}

        {activeTab === 'system' && (
          <div className="bg-white rounded-lg shadow-sm p-6">
            <h3 className="text-lg font-semibold text-gray-800 mb-4">System Settings</h3>
            
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Tennis Ball Price
                </label>
                <div className="flex items-center gap-2">
                  <span className="text-gray-500">$</span>
                  <input
                    type="number"
                    step="0.01"
                    value={settings.tennisBallPrice || TENNIS_CONFIG.PRICING.TENNIS_BALLS}
                    onChange={(e) => updateBallPrice(e.target.value)}
                    className="w-32 p-2 border rounded"
                  />
                </div>
              </div>
            </div>
          </div>
        )}
        </div>
      </div>

      {/* AI Assistant Button and Modal */}
      {(activeTab === 'status' || activeTab === 'blocking' || activeTab === 'calendar') && (
        <>
          {/* Floating AI Assistant Button */}
          <div className="fixed bottom-8 right-8 z-40">
            <button
              onClick={() => setShowAIAssistant(true)}
              className="bg-purple-600 text-white p-4 rounded-full shadow-lg hover:bg-purple-700 transition-all transform hover:scale-110"
              title="AI Assistant - Use natural language commands"
            >
              <MessageCircle size={24} />
            </button>
          </div>

          {/* AI Assistant Modal */}
          {showAIAssistant && (
            <MockAIAdmin 
              onClose={() => setShowAIAssistant(false)} 
              dataStore={dataStore}
              courts={courts}
              loadData={loadData}
              clearCourt={clearCourt}
              clearAllCourts={clearAllCourts}
              moveCourt={moveCourt}
              settings={settings}
              updateBallPrice={updateBallPrice}
              waitingGroups={waitingGroups}
              refreshData={() => {
                loadData();
                setRefreshTrigger(prev => prev + 1);
              }}
            />
          )}
        </>
      )}
    </div>
  );
};
    
    
    // ============================================
    // PASTE YOUR AnalyticsDashboard COMPONENT CODE HERE  
    // (Remove the imports and export statements)
    // Start from "// Utility Functions" and paste everything until just before "export default AnalyticsDashboard"
    // ============================================
    
// Utility Functions
const formatDateTime = (date) => {
  return new Date(date).toLocaleString('en-US', {
    month: '2-digit',
    day: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    hour12: true
  });
};

const formatHour = (hour) => {
  if (hour === 0) return '12 AM';
  if (hour === 12) return '12 PM';
  if (hour < 12) return `${hour} AM`;
  return `${hour - 12} PM`;
};

const getEventEmoji = (type) => {
  switch (type) {
    case 'league':
      return '🏆';
    case 'tournament':
      return '⭐';
    case 'clinic':
      return '🎓';
    case 'lesson':
      return '👥';
    case 'maintenance':
      return '🔧';
    default:
      return '📅';
  }
};

const downloadCSV = (data, filename) => {
  const csv = convertToCSV(data);
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  window.URL.revokeObjectURL(url);
};

const convertToCSV = (data) => {
  if (!data || data.length === 0) return '';
  
  const headers = Object.keys(data[0]);
  const csvHeaders = headers.join(',');
  
  const csvRows = data.map(row => {
    return headers.map(header => {
      const value = row[header];
      // Escape quotes and wrap in quotes if contains comma
      const escaped = String(value).replace(/"/g, '""');
      return escaped.includes(',') ? `"${escaped}"` : escaped;
    }).join(',');
  });
  
  return [csvHeaders, ...csvRows].join('\n');
};

// Court Usage Heatmap Component
const UsageHeatmap = ({ analyticsData }) => {
  const heatmapData = useMemo(() => {
    const heatmap = {};
    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    
    // Initialize heatmap
    for (let day = 0; day < 7; day++) {
      heatmap[day] = {};
      for (let hour = 7; hour <= 21; hour++) {
        heatmap[day][hour] = 0;
      }
    }
    
    // Populate with data
    analyticsData.forEach(entry => {
      const date = new Date(entry.startTime);
      const day = date.getDay();
      const hour = date.getHours();
      if (hour >= 7 && hour <= 21) {
        heatmap[day][hour] = (heatmap[day][hour] || 0) + 1;
      }
    });
    
    // Find max for color scaling
    let maxUsage = 0;
    Object.values(heatmap).forEach(dayData => {
      Object.values(dayData).forEach(count => {
        if (count > maxUsage) maxUsage = count;
      });
    });
    
    return { heatmap, maxUsage, days };
  }, [analyticsData]);
  
  const getHeatColor = (count) => {
    if (count === 0) return 'bg-gray-100';
    const intensity = count / heatmapData.maxUsage;
    if (intensity < 0.2) return 'bg-green-200';
    if (intensity < 0.4) return 'bg-green-300';
    if (intensity < 0.6) return 'bg-green-400';
    if (intensity < 0.8) return 'bg-green-500';
    return 'bg-green-600';
  };
  
  return (
    <div className="bg-white rounded-lg shadow p-4">
      <h3 className="text-lg font-semibold mb-4">Peak Usage Times</h3>
      <div className="overflow-x-auto">
        <div className="min-w-[600px]">
          {/* Hour headers */}
          <div className="flex mb-2">
            <div className="w-16"></div>
            {[...Array(15)].map((_, i) => (
              <div key={i} className="flex-1 text-center text-xs text-gray-600">
                {formatHour(i + 7)}
              </div>
            ))}
          </div>
          
          {/* Heatmap grid */}
          {heatmapData.days.map((day, dayIndex) => (
            <div key={day} className="flex mb-1">
              <div className="w-16 text-sm font-medium text-gray-700 flex items-center">
                {day}
              </div>
              {[...Array(15)].map((_, hourIndex) => {
                const hour = hourIndex + 7;
                const count = heatmapData.heatmap[dayIndex][hour] || 0;
                return (
                  <div
                    key={hour}
                    className={`flex-1 h-8 mx-0.5 rounded ${getHeatColor(count)} relative group`}
                  >
                    {count > 0 && (
                      <div className="absolute inset-0 flex items-center justify-center text-xs font-medium text-gray-800">
                        {count}
                      </div>
                    )}
                    <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 bg-gray-800 text-white text-xs rounded opacity-0 group-hover:opacity-100 pointer-events-none whitespace-nowrap">
                      {count} sessions
                    </div>
                  </div>
                );
              })}
            </div>
          ))}
        </div>
      </div>
      
      <div className="mt-4 flex items-center gap-4 text-xs text-gray-600">
        <span>Less Usage</span>
        <div className="flex gap-1">
          <div className="w-4 h-4 bg-gray-100 rounded"></div>
          <div className="w-4 h-4 bg-green-200 rounded"></div>
          <div className="w-4 h-4 bg-green-300 rounded"></div>
          <div className="w-4 h-4 bg-green-400 rounded"></div>
          <div className="w-4 h-4 bg-green-500 rounded"></div>
          <div className="w-4 h-4 bg-green-600 rounded"></div>
        </div>
        <span>More Usage</span>
      </div>
    </div>
  );
};

// Court Utilization Chart
const UtilizationChart = ({ analyticsData, dateRange }) => {
  const stats = useMemo(() => {
    const totalHours = TENNIS_CONFIG.COURTS.TOTAL_COUNT * 15.5; // 6:30 AM to 10 PM
    const daysInRange = Math.ceil((dateRange.end - dateRange.start) / (1000 * 60 * 60 * 24)) || 1;
    const totalAvailableHours = totalHours * daysInRange;
    
    let totalUsedMinutes = 0;
    analyticsData.forEach(entry => {
      const duration = entry.duration || 90; // Default 90 minutes if not specified
      totalUsedMinutes += duration;
    });
    
    const totalUsedHours = totalUsedMinutes / 60;
    const utilizationPercent = (totalUsedHours / totalAvailableHours) * 100;
    
    return {
      totalAvailableHours,
      totalUsedHours: totalUsedHours.toFixed(1),
      utilizationPercent: utilizationPercent.toFixed(1),
      avgHoursPerDay: (totalUsedHours / daysInRange).toFixed(1)
    };
  }, [analyticsData, dateRange]);
  
  return (
    <div className="bg-white rounded-lg shadow p-4">
      <h3 className="text-lg font-semibold mb-4">Court Utilization</h3>
      
      <div className="mb-4">
        <div className="flex justify-between text-sm text-gray-600 mb-1">
          <span>Overall Utilization</span>
          <span>{stats.utilizationPercent}%</span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-4">
          <div 
            className="bg-green-500 h-4 rounded-full"
            style={{ width: `${Math.min(stats.utilizationPercent, 100)}%` }}
          ></div>
        </div>
      </div>
      
      <div className="grid grid-cols-2 gap-4 text-sm">
        <div>
          <p className="text-gray-600">Total Hours Used</p>
          <p className="text-2xl font-semibold">{stats.totalUsedHours}</p>
        </div>
        <div>
          <p className="text-gray-600">Avg Hours/Day</p>
          <p className="text-2xl font-semibold">{stats.avgHoursPerDay}</p>
        </div>
      </div>
    </div>
  );
};

// Wait Time Analysis
const WaitTimeAnalysis = ({ waitlistData }) => {
  const stats = useMemo(() => {
    if (!waitlistData || waitlistData.length === 0) {
      return {
        avgWaitTime: 0,
        maxWaitTime: 0,
        totalGroupsServed: 0,
        peakWaitHour: 'N/A'
      };
    }
    
    const waitTimes = waitlistData.map(entry => entry.waitTime || 0);
    const avgWaitTime = waitTimes.reduce((a, b) => a + b, 0) / waitTimes.length;
    const maxWaitTime = Math.max(...waitTimes);
    
    // Find peak wait hour
    const hourCounts = {};
    waitlistData.forEach(entry => {
      const hour = new Date(entry.joinTime).getHours();
      hourCounts[hour] = (hourCounts[hour] || 0) + 1;
    });
    
    let peakHour = 0;
    let peakCount = 0;
    Object.entries(hourCounts).forEach(([hour, count]) => {
      if (count > peakCount) {
        peakCount = count;
        peakHour = parseInt(hour);
      }
    });
    
    return {
      avgWaitTime: Math.round(avgWaitTime),
      maxWaitTime,
      totalGroupsServed: waitlistData.length,
      peakWaitHour: formatTime(peakHour)
    };
  }, [waitlistData]);
  
  return (
    <div className="bg-white rounded-lg shadow p-4">
      <h3 className="text-lg font-semibold mb-4">Wait Time Analysis</h3>
      
      <div className="grid grid-cols-2 gap-4">
        <div className="text-center">
          <p className="text-3xl font-bold text-blue-600">{stats.avgWaitTime}</p>
          <p className="text-sm text-gray-600">Avg Wait (min)</p>
        </div>
        <div className="text-center">
          <p className="text-3xl font-bold text-red-600">{stats.maxWaitTime}</p>
          <p className="text-sm text-gray-600">Max Wait (min)</p>
        </div>
        <div className="text-center">
          <p className="text-3xl font-bold text-green-600">{stats.totalGroupsServed}</p>
          <p className="text-sm text-gray-600">Groups Served</p>
        </div>
        <div className="text-center">
          <p className="text-3xl font-bold text-purple-600">{stats.peakWaitHour}</p>
          <p className="text-sm text-gray-600">Peak Hour</p>
        </div>
      </div>
    </div>
  );
};

// Ball Purchase Log Component
const BallPurchaseLog = ({ purchases, dateRange }) => {
  const [sortField, setSortField] = useState('timestamp');
  const [sortOrder, setSortOrder] = useState('desc');
  
  const filteredPurchases = useMemo(() => {
    return purchases.filter(purchase => {
      const purchaseDate = new Date(purchase.timestamp);
      return purchaseDate >= dateRange.start && purchaseDate <= dateRange.end;
    });
  }, [purchases, dateRange]);
  
  const sortedPurchases = useMemo(() => {
    return [...filteredPurchases].sort((a, b) => {
      let aVal = a[sortField];
      let bVal = b[sortField];
      
      if (sortField === 'timestamp') {
        aVal = new Date(aVal);
        bVal = new Date(bVal);
      }
      
      if (sortOrder === 'asc') {
        return aVal > bVal ? 1 : -1;
      } else {
        return aVal < bVal ? 1 : -1;
      }
    });
  }, [filteredPurchases, sortField, sortOrder]);
  
  const handleSort = (field) => {
    if (sortField === field) {
      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortOrder('desc');
    }
  };
  
  const handleExport = () => {
    const exportData = sortedPurchases.flatMap(purchase => {
      // Handle old format (single memberNumber/memberName fields)
      if (!purchase.players || purchase.players.length === 0) {
        return {
          'Date/Time': formatDateTime(purchase.timestamp),
          'Member Number': purchase.memberNumber || '****',
          'Member Name': purchase.memberName || 'Unknown',
          'Amount': `$${(purchase.amount || 0).toFixed(2)}`
        };
      }
      
      // For new format with players array, create a row for each player
      return purchase.players.map(player => ({
        'Date/Time': formatDateTime(purchase.timestamp),
        'Member Number': player.memberNumber || '****',
        'Member Name': player.name || 'Unknown',
        'Amount': `$${(purchase.amount || 0).toFixed(2)}`
      }));
    });
    
    const filename = `ball_purchases_${dateRange.start.toISOString().split('T')[0]}_to_${dateRange.end.toISOString().split('T')[0]}.csv`;
    downloadCSV(exportData, filename);
  };
  
  return (
    <div className="bg-white rounded-lg shadow p-4">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-semibold">Ball Purchase Log</h3>
        <button
          onClick={handleExport}
          className="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
        >
          <Download size={16} />
          Export CSV
        </button>
      </div>
      
      <div className="overflow-x-auto">
        <table className="w-full">
          <thead>
            <tr className="border-b">
              <th 
                className="text-left p-2 cursor-pointer hover:bg-gray-50"
                onClick={() => handleSort('timestamp')}
              >
                Date/Time {sortField === 'timestamp' && (sortOrder === 'asc' ? '↑' : '↓')}
              </th>
              <th 
                className="text-left p-2 cursor-pointer hover:bg-gray-50"
                onClick={() => handleSort('memberNumber')}
              >
                Member # {sortField === 'memberNumber' && (sortOrder === 'asc' ? '↑' : '↓')}
              </th>
              <th 
                className="text-left p-2 cursor-pointer hover:bg-gray-50"
                onClick={() => handleSort('memberName')}
              >
                Member Name {sortField === 'memberName' && (sortOrder === 'asc' ? '↑' : '↓')}
              </th>
              <th 
                className="text-left p-2 cursor-pointer hover:bg-gray-50"
                onClick={() => handleSort('amount')}
              >
                Amount {sortField === 'amount' && (sortOrder === 'asc' ? '↑' : '↓')}
              </th>
            </tr>
          </thead>
          <tbody>
            {sortedPurchases.length === 0 ? (
              <tr>
                <td colSpan="4" className="text-center p-4 text-gray-500">
                  No purchases in selected date range
                </td>
              </tr>
            ) : (
              sortedPurchases.flatMap((purchase, purchaseIndex) => {
                // Handle old format (single memberNumber/memberName fields)
                if (!purchase.players || purchase.players.length === 0) {
                  return (
                    <tr key={purchase.id || purchaseIndex} className="border-b hover:bg-gray-50">
                      <td className="p-2">{formatDateTime(purchase.timestamp)}</td>
                      <td className="p-2">{purchase.memberNumber || '****'}</td>
                      <td className="p-2">{purchase.memberName || 'Unknown'}</td>
                      <td className="p-2">${(purchase.amount || 0).toFixed(2)}</td>
                    </tr>
                  );
                }
                
                // For new format with players array, create a row for each player
                return purchase.players.map((player, playerIndex) => (
                  <tr key={`${purchase.id || purchaseIndex}-${playerIndex}`} className="border-b hover:bg-gray-50">
                    <td className="p-2">{formatDateTime(purchase.timestamp)}</td>
                    <td className="p-2">{player.memberNumber || '****'}</td>
                    <td className="p-2">{player.name || 'Unknown'}</td>
                    <td className="p-2">${(purchase.amount || 0).toFixed(2)}</td>
                  </tr>
                ));
              })
            )}
          </tbody>
        </table>
      </div>
      
      <div className="mt-4 text-sm text-gray-600">
        Showing {sortedPurchases.reduce((count, purchase) => {
          if (purchase.players && purchase.players.length > 0) {
            return count + purchase.players.length;
          }
          return count + 1;
        }, 0)} charges from {sortedPurchases.length} purchase{sortedPurchases.length !== 1 ? 's' : ''}
      </div>
    </div>
  );
};

// Guest Charge Log Component
const GuestChargeLog = ({ charges, dateRange }) => {
  const [sortField, setSortField] = useState('timestamp');
  const [sortOrder, setSortOrder] = useState('desc');
  
  const filteredCharges = useMemo(() => {
    return charges.filter(charge => {
      const chargeDate = new Date(charge.timestamp);
      return chargeDate >= dateRange.start && chargeDate <= dateRange.end;
    });
  }, [charges, dateRange]);
  
  const sortedCharges = useMemo(() => {
    return [...filteredCharges].sort((a, b) => {
      let aVal = a[sortField];
      let bVal = b[sortField];
      
      if (sortField === 'timestamp') {
        aVal = new Date(aVal);
        bVal = new Date(bVal);
      }
      
      if (sortOrder === 'asc') {
        return aVal > bVal ? 1 : -1;
      } else {
        return aVal < bVal ? 1 : -1;
      }
    });
  }, [filteredCharges, sortField, sortOrder]);
  
  const handleSort = (field) => {
    if (sortField === field) {
      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortOrder('desc');
    }
  };
  
  const handleExport = () => {
    const exportData = sortedCharges.map(charge => ({
      'Date/Time': formatDateTime(charge.timestamp),
      'Guest Name': charge.guestName || 'Unknown',
      'Sponsor Name': charge.sponsorName || 'Unknown',
      'Sponsor #': charge.sponsorNumber || '****',
      'Amount': `$${(charge.amount || 15.00).toFixed(2)}`
    }));
    
    const filename = `guest_charges_${dateRange.start.toISOString().split('T')[0]}_to_${dateRange.end.toISOString().split('T')[0]}.csv`;
    downloadCSV(exportData, filename);
  };
  
  return (
    <div className="bg-white rounded-lg shadow p-4">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-semibold">Guest Charge Log</h3>
        <div className="flex gap-2">
          <button
            onClick={async () => {
              console.log('🔍 DEBUG: Manual localStorage check...');
              const localData = localStorage.getItem(TENNIS_CONFIG.STORAGE.GUEST_CHARGES_KEY);
              console.log('🔍 Raw localStorage data:', localData);
              if (localData) {
                const parsed = JSON.parse(localData);
                console.log('🔍 Parsed data:', parsed);
                console.log('🔍 Number of charges:', parsed.length);
                parsed.forEach((charge, i) => {
                  console.log(`🔍 Charge ${i + 1}:`, charge);
                });
              } else {
                console.log('🔍 No data in localStorage for key:', TENNIS_CONFIG.STORAGE.GUEST_CHARGES_KEY);
              }
              
              // Check dataStore too
              const dataStoreData = await dataStore.get(TENNIS_CONFIG.STORAGE.GUEST_CHARGES_KEY);
              console.log('🔍 DataStore data:', dataStoreData);
              
              // Check current component state
              console.log('🔍 Current component state charges:', charges.length);
            }}
            className="flex items-center gap-2 px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
          >
            🔍 Debug
          </button>
          <button
            onClick={handleExport}
            className="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
          >
            <Download size={16} />
            Export CSV
          </button>
        </div>
      </div>
      
      <div className="overflow-x-auto">
        <table className="w-full">
          <thead>
            <tr className="border-b">
              <th 
                className="text-left p-2 cursor-pointer hover:bg-gray-50"
                onClick={() => handleSort('timestamp')}
              >
                Date/Time {sortField === 'timestamp' && (sortOrder === 'asc' ? '↑' : '↓')}
              </th>
              <th 
                className="text-left p-2 cursor-pointer hover:bg-gray-50"
                onClick={() => handleSort('guestName')}
              >
                Guest Name {sortField === 'guestName' && (sortOrder === 'asc' ? '↑' : '↓')}
              </th>
              <th 
                className="text-left p-2 cursor-pointer hover:bg-gray-50"
                onClick={() => handleSort('sponsorName')}
              >
                Sponsor Name {sortField === 'sponsorName' && (sortOrder === 'asc' ? '↑' : '↓')}
              </th>
              <th 
                className="text-left p-2 cursor-pointer hover:bg-gray-50"
                onClick={() => handleSort('sponsorNumber')}
              >
                Sponsor # {sortField === 'sponsorNumber' && (sortOrder === 'asc' ? '↑' : '↓')}
              </th>
              <th 
                className="text-left p-2 cursor-pointer hover:bg-gray-50"
                onClick={() => handleSort('amount')}
              >
                Amount {sortField === 'amount' && (sortOrder === 'asc' ? '↑' : '↓')}
              </th>
            </tr>
          </thead>
          <tbody>
            {sortedCharges.length === 0 ? (
              <tr>
                <td colSpan="5" className="text-center p-4 text-gray-500">
                  No guest charges in selected date range
                </td>
              </tr>
            ) : (
              sortedCharges.map((charge, index) => (
                <tr key={charge.id || index} className="border-b hover:bg-gray-50">
                  <td className="p-2">{formatDateTime(charge.timestamp)}</td>
                  <td className="p-2">{charge.guestName || 'Unknown'}</td>
                  <td className="p-2">{charge.sponsorName || 'Unknown'}</td>
                  <td className="p-2">{charge.sponsorNumber || '****'}</td>
                  <td className="p-2">${(charge.amount || 15.00).toFixed(2)}</td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
      
      <div className="mt-4 text-sm text-gray-600">
        Showing {sortedCharges.length} guest charge{sortedCharges.length !== 1 ? 's' : ''}
      </div>
    </div>
  );
};

// Main Analytics Dashboard Component
const AnalyticsDashboard = ({ onClose }) => {
  const [activeTab, setActiveTab] = useState('usage');
  const [dateRange, setDateRange] = useState({
    start: new Date(new Date().setDate(new Date().getDate() - 7)),
    end: new Date()
  });
  const [analyticsData, setAnalyticsData] = useState([]);
  const [waitlistData, setWaitlistData] = useState([]);
  const [ballPurchases, setBallPurchases] = useState([]);
  const [guestCharges, setGuestCharges] = useState([]);

  // Load data from localStorage with auto-refresh
  useEffect(() => {
    const loadAnalyticsData = async () => {
      // Load analytics data
      const storedAnalytics = await dataStore.get(TENNIS_CONFIG.STORAGE.ANALYTICS_KEY);
      if (storedAnalytics) {
        setAnalyticsData(storedAnalytics);
      }
      
      // Load ball purchases
      const storedPurchases = await dataStore.get(TENNIS_CONFIG.STORAGE.BALL_SALES_KEY);
      if (storedPurchases) {
        setBallPurchases(storedPurchases);
      }
      
      // Load guest charges - use localStorage as source of truth for real-time updates
      console.log('📊 Loading guest charges...');
      const localStorageCharges = localStorage.getItem(TENNIS_CONFIG.STORAGE.GUEST_CHARGES_KEY);
      let guestChargesData = [];
      if (localStorageCharges) {
        try { guestChargesData = JSON.parse(localStorageCharges); }
        catch { /* transient partial write; use empty array */ }
      }
      
      console.log('📊 Guest charges found:', guestChargesData.length);
      setGuestCharges(guestChargesData);
      
      // Generate sample data if none exists (for testing)
      if (!storedAnalytics) {
        generateSampleAnalytics();
      }
      // Don't generate sample purchases - only show real data
      // if (!storedPurchases) {
      //   generateSamplePurchases();
      // }
    };
    
    // Initial load
    loadAnalyticsData();
    
    // Set up event listener for real-time updates
    const handleDataUpdate = debounce(() => {
      console.log('📡 Analytics received data update event, reloading...');
      loadAnalyticsData();
    }, 150);
    
    window.addEventListener(TENNIS_CONFIG.STORAGE.UPDATE_EVENT, handleDataUpdate);
    window.addEventListener(EVENTS.UPDATE, handleDataUpdate);
    
    // Set up auto-refresh every 30 seconds as backup (reduced frequency since we have event listeners)
    const refreshInterval = addTimer(setInterval(loadAnalyticsData, 30000));
    
    return () => {
      try { clearInterval(refreshInterval); } catch {};
      window.removeEventListener(TENNIS_CONFIG.STORAGE.UPDATE_EVENT, handleDataUpdate);
      window.removeEventListener('tennisDataUpdate', handleDataUpdate);
    };
  }, []);

  // Generate sample analytics data for testing
  const generateSampleAnalytics = () => {
    const sampleData = [];
    const now = new Date();
    
    for (let days = 0; days < 30; days++) {
      const date = new Date(now);
      date.setDate(date.getDate() - days);
      
      // Generate 20-40 sessions per day
      const sessionsPerDay = 20 + Math.floor(Math.random() * 20);
      
      for (let i = 0; i < sessionsPerDay; i++) {
        const hour = 7 + Math.floor(Math.random() * 14); // 7 AM to 9 PM
        const startTime = new Date(date);
        startTime.setHours(hour, Math.floor(Math.random() * 60), 0, 0);
        
        sampleData.push({
          id: `session_${days}_${i}`,
          courtNumber: Math.floor(Math.random() * 12) + 1,
          startTime: startTime.toISOString(),
          duration: 60 + Math.floor(Math.random() * 60), // 60-120 minutes
          playerCount: Math.floor(Math.random() * 3) + 2, // 2-4 players
          dayOfWeek: startTime.getDay(),
          hourOfDay: startTime.getHours()
        });
      }
    }
    
    dataStore.set(TENNIS_CONFIG.STORAGE.ANALYTICS_KEY, sampleData, { immediate: true });
    setAnalyticsData(sampleData);
  };

  // Generate sample purchase data for testing - DISABLED to only show real data
  // const generateSamplePurchases = () => {
  //   const samplePurchases = [];
  //   const memberNames = [
  //     'John Smith', 'Jane Doe', 'Bob Johnson', 'Alice Williams',
  //     'Charlie Brown', 'Diana Prince', 'Edward Norton', 'Fiona Apple'
  //   ];
  //   
  //   for (let i = 0; i < 50; i++) {
  //     const daysAgo = Math.floor(Math.random() * 30);
  //     const purchaseDate = new Date();
  //     purchaseDate.setDate(purchaseDate.getDate() - daysAgo);
  //     purchaseDate.setHours(8 + Math.floor(Math.random() * 12));
  //     
  //     const memberIndex = Math.floor(Math.random() * memberNames.length);
  //     const isSplit = Math.random() > 0.7;
  //     
  //     samplePurchases.push({
  //       id: `purchase_${i}`,
  //       timestamp: purchaseDate.toISOString(),
  //       memberNumber: `${1000 + memberIndex}`,
  //       memberName: memberNames[memberIndex],
  //       amount: isSplit ? 2.75 : 5.50
  //     });
  //   }
  //   
  //   dataStore.set(TENNIS_CONFIG.STORAGE.BALL_SALES_KEY, samplePurchases, { immediate: true });
  //   setBallPurchases(samplePurchases);
  // };

  // Filter data by date range
  const filteredAnalytics = useMemo(() => {
    return analyticsData.filter(entry => {
      const entryDate = new Date(entry.startTime);
      return entryDate >= dateRange.start && entryDate <= dateRange.end;
    });
  }, [analyticsData, dateRange]);

  const handleDateRangeChange = (preset) => {
    const end = new Date();
    let start = new Date();
    
    switch (preset) {
      case 'today':
        start.setHours(0, 0, 0, 0);
        break;
      case 'week':
        start.setDate(start.getDate() - 7);
        break;
      case 'month':
        start.setMonth(start.getMonth() - 1);
        break;
      case 'year':
        start.setFullYear(start.getFullYear() - 1);
        break;
      default:
        break;
    }
    
    setDateRange({ start, end });
  };

  return (
    <div className="min-h-screen bg-gray-100">
      {/* Header */}
      <div className="bg-white shadow-sm">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center py-4">
            <h1 className="text-2xl font-bold text-gray-900">Analytics Dashboard</h1>
            {onClose && (
              <button
                onClick={onClose}
                className="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300"
              >
                Close
              </button>
            )}
          </div>
        </div>
      </div>

      {/* Date Range Selector */}
      <div className="bg-white border-b">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-3">
          <div className="flex items-center gap-4">
            <span className="text-sm font-medium">Date Range:</span>
            <div className="flex gap-2">
              {['today', 'week', 'month', 'year'].map(preset => (
                <button
                  key={preset}
                  onClick={() => handleDateRangeChange(preset)}
                  className="px-3 py-1 bg-gray-100 rounded hover:bg-gray-200 text-sm capitalize"
                >
                  {preset}
                </button>
              ))}
            </div>
            <div className="flex items-center gap-2 ml-4">
              <input
                type="date"
                value={dateRange.start.toISOString().split('T')[0]}
                onChange={(e) => setDateRange({ ...dateRange, start: new Date(e.target.value) })}
                className="px-2 py-1 border rounded text-sm"
              />
              <span>to</span>
              <input
                type="date"
                value={dateRange.end.toISOString().split('T')[0]}
                onChange={(e) => setDateRange({ ...dateRange, end: new Date(e.target.value) })}
                className="px-2 py-1 border rounded text-sm"
              />
            </div>
          </div>
        </div>
      </div>

      {/* Tab Navigation */}
      <div className="bg-white border-b">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex gap-8">
            <button
              onClick={() => setActiveTab('usage')}
              className={`py-4 px-2 border-b-2 font-medium text-sm ${
                activeTab === 'usage'
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700'
              }`}
            >
              Court Usage
            </button>
            <button
              onClick={() => setActiveTab('purchases')}
              className={`py-4 px-2 border-b-2 font-medium text-sm ${
                activeTab === 'purchases'
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700'
              }`}
            >
              Ball Purchases
            </button>
            <button
              onClick={() => setActiveTab('guests')}
              className={`py-4 px-2 border-b-2 font-medium text-sm ${
                activeTab === 'guests'
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700'
              }`}
            >
              Guest Charges
            </button>
          </div>
        </div>
      </div>

      {/* Content */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {activeTab === 'usage' && (
          <div className="space-y-6">
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <UtilizationChart analyticsData={filteredAnalytics} dateRange={dateRange} />
              <WaitTimeAnalysis waitlistData={waitlistData} />
            </div>
            <UsageHeatmap analyticsData={filteredAnalytics} />
          </div>
        )}

        {activeTab === 'purchases' && (
          <BallPurchaseLog purchases={ballPurchases} dateRange={dateRange} />
        )}

        {activeTab === 'guests' && (
          <GuestChargeLog charges={guestCharges} dateRange={dateRange} />
        )}
      </div>
    </div>
  );
};

    
    
    // Test Menu Component
    const TestMenu = () => {
      const [view, setView] = useState('menu');
      
      if (view === 'menu') {
        return (
          <div className="min-h-screen bg-gray-100 flex items-center justify-center">
            <div className="bg-white rounded-lg shadow-lg p-8 max-w-md w-full">
              <h1 className="text-2xl font-bold mb-6">Tennis Admin Test</h1>
              
              <div className="space-y-4">
                <button
                  onClick={() => setView('admin')}
                  className="w-full py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600"
                >
                  Open Admin Panel
                </button>
                
                <button
                  onClick={() => setView('analytics')}
                  className="w-full py-3 bg-green-500 text-white rounded-lg hover:bg-green-600"
                >
                  Open Analytics
                </button>
              </div>
            <div className="mt-6 p-4 bg-gray-100 rounded">
                <p className="text-sm text-gray-600">
                  Status: {dataStore.cache.has('tennisClubData') ? '✓ Data Loaded' : '✗ No Data'}
                </p>
                <div className="mt-2 text-xs text-blue-600">
                  📊 DataStore: {dataStore.getMetrics().cacheHitRate}% cache hit rate | {dataStore.getMetrics().totalOperations} ops
                </div>
              </div>
            </div>
          </div>
        );
      }
      
      if (view === 'admin') {
  // Check AdminPanelV2 availability
  
  try {
    if (typeof AdminPanelV2 !== 'undefined') {
      return <AdminPanelV2 onExit={() => setView('menu')} />;
    } else {
      // AdminPanelV2 component not available
      return <div className="p-8">AdminPanelV2 component not found</div>;
    }
  } catch (error) {
    // Error occurred while rendering AdminPanelV2
    console.error('AdminPanelV2 render error:', error);
    return (
      <div className="p-8">
        <h1 className="text-xl font-bold text-red-600">Error loading Admin Panel</h1>
        <p className="mt-2">{error.message}</p>
        <button 
          onClick={() => setView('menu')}
          className="mt-4 px-4 py-2 bg-gray-500 text-white rounded"
        >
          Back to Menu
        </button>
      </div>
    );
  }
}
      
      if (view === 'analytics' && typeof AnalyticsDashboard !== 'undefined') {
        return <AnalyticsDashboard onClose={() => setView('menu')} />;
      }
      
      // Fallback if components aren't pasted yet
      return (
        <div className="min-h-screen bg-gray-100 flex items-center justify-center">
          <div className="bg-white rounded-lg shadow-lg p-8 max-w-md w-full">
            <h1 className="text-2xl font-bold mb-4">Component Not Found</h1>
            <p className="mb-4">Please paste your component code in the marked sections above.</p>
            <button 
              onClick={() => setView('menu')}
              className="px-4 py-2 bg-gray-500 text-white rounded"
            >
              Back to Menu
            </button>
          </div>
        </div>
      );
    };
    
  // Mount the app
  const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<TestMenu />);
    } // This closes the initializeApp function
  </script>

  <script>
    // Final, idempotent export shim (runs after Admin has booted)
    (function ensureAdminExport() {
      const candidate =
        window.refreshAdminView ||
        window.loadData ||
        window.refreshData;

      if (typeof candidate === 'function') {
        window.refreshAdminView = candidate;
      }

      // quick self-test
      console.log('[Admin] refreshAdminView exported:',
        typeof window.refreshAdminView === 'function');
    })();
  </script>

  <!-- Debug Panel - Only visible when ?debug=1 -->
  <script>
  (function() {
    const params = new URLSearchParams(location.search);
    if (params.get('debug') !== '1') return;

    const debugPanel = document.createElement('div');
    debugPanel.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      width: 350px;
      max-height: 500px;
      background: rgba(0, 0, 0, 0.85);
      color: #0f0;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      padding: 10px;
      border-radius: 4px;
      overflow-y: auto;
      z-index: 99999;
      pointer-events: auto;
      border: 1px solid #0f0;
    `;
    debugPanel.innerHTML = `
      <div style="color: #ff0; margin-bottom: 5px;">DEBUG MODE - Events Log</div>
      <div style="margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 8px;">
        <button id="runSelfTests" style="background: #333; color: #0f0; border: 1px solid #0f0; padding: 4px 8px; border-radius: 3px; font-family: inherit; font-size: 10px; cursor: pointer;">Run self-tests</button>
        <span style="color: #666; font-size: 10px; margin-left: 8px;">Press 't' to run</span>
        <div id="selfTestResults" style="margin-top: 5px; font-size: 10px;"></div>
      </div>
      <div id="debugContent"></div>
    `;
    document.body.appendChild(debugPanel);

    const updateDebugPanel = () => {
      if (!window.Tennis || !window.Tennis.Events || !window.Tennis.Events.debug) return;
      
      const events = window.Tennis.Events.debug.getLog();
      const content = document.getElementById('debugContent');
      if (!content) return;

      content.innerHTML = events.map((event, i) => {
        const time = new Date(event.timestamp).toLocaleTimeString();
        return `<div style="margin-bottom: 5px; padding-bottom: 5px; border-bottom: 1px solid #333;">
          <div style="color: #ff0;">[${time}] ${event.type}</div>
          <div style="color: #0ff;">${event.eventName}</div>
          ${event.data ? `<div style="color: #fff; font-size: 10px;">${JSON.stringify(event.data, null, 2)}</div>` : ''}
        </div>`;
      }).join('');
    };

    // Safe wrapper for self-tests
    function runSelfTestsSafe() {
      const fn = window.Tennis?.selfTest?.runAll;
      if (typeof fn !== 'function') {
        return {
          passed: 0, failed: 1,
          results: [{ name: 'SelfTest not available', ok: false, notes: 'Tennis.selfTest.runAll missing' }]
        };
      }
      try { return fn(); }
      catch (e) {
        return {
          passed: 0, failed: 1,
          results: [{ name: 'Run failed', ok: false, notes: String(e?.message || e) }]
        };
      }
    }

    function renderSelfTestResults(result) {
      const resultsDiv = document.getElementById('selfTestResults');
      if (!resultsDiv) return;
      
      const timestamp = new Date().toLocaleTimeString();
      const passed = result.passed || 0;
      const failed = result.failed || 0;
      
      // Summary with color coding
      const summaryColor = failed > 0 ? '#f00' : '#0f0';
      let html = `<div style="color: ${summaryColor}; font-weight: bold;">${passed} passed / ${failed} failed</div>`;
      html += `<div style="color: #666; font-size: 9px;">Last run: ${timestamp}</div>`;
      
      // Compact table
      if (result.results && result.results.length > 0) {
        html += '<div style="margin-top: 5px; max-height: 150px; overflow-y: auto;">';
        html += '<table style="width: 100%; font-size: 9px; border-collapse: collapse;">';
        html += '<tr style="color: #ff0;"><th style="text-align: left; padding: 2px;">Test</th><th style="text-align: center; padding: 2px;">OK</th><th style="text-align: left; padding: 2px;">Notes</th></tr>';
        
        result.results.forEach(test => {
          const okColor = test.ok ? '#0f0' : '#f00';
          const okText = test.ok ? '✓' : '✗';
          html += `<tr style="border-top: 1px solid #333;">`;
          html += `<td style="padding: 2px; color: #fff;">${test.name || test.Test || ''}</td>`;
          html += `<td style="padding: 2px; text-align: center; color: ${okColor};">${okText}</td>`;
          html += `<td style="padding: 2px; color: #aaa;">${(test.notes || test.Notes || '').slice(0, 30)}${(test.notes || test.Notes || '').length > 30 ? '...' : ''}</td>`;
          html += `</tr>`;
        });
        html += '</table></div>';
      }
      
      resultsDiv.innerHTML = html;
    }

    let running = false;
    async function handleRunSelfTests() {
      if (running) return;
      running = true;
      try {
        const resultsDiv = document.getElementById('selfTestResults');
        if (resultsDiv) {
          resultsDiv.innerHTML = '<div style="color: #ff0;">Running tests...</div>';
        }
        const result = await runSelfTestsSafe();
        renderSelfTestResults(result);
      } finally {
        running = false;
      }
    }
    
    // Button click handler
    const runButton = document.getElementById('runSelfTests');
    if (runButton) {
      runButton.addEventListener('click', handleRunSelfTests);
    }
    
    // Keyboard shortcut (t key)
    window.addEventListener('keydown', (e) => {
      if ((e.key || '').toLowerCase() === 't') {
        e.preventDefault();
        handleRunSelfTests();
      }
    }, { passive: false });

    // Update every 500ms
    setInterval(updateDebugPanel, 500);
    
    // Initial update
    setTimeout(updateDebugPanel, 100);
  })();
  </script>

</body>
</html>