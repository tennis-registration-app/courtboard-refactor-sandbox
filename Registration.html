<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tennis Registration - DataStore Integrated</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .scrollbar-hide {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .scrollbar-hide::-webkit-scrollbar {
      display: none;
    }
    /* Mobile-specific styles */
    @media (max-width: 640px) {
      /* Ensure modals don't exceed viewport */
      .modal-mobile-full {
        max-height: 100vh;
        max-height: 100dvh; /* Dynamic viewport height for mobile browsers */
      }
    }

 /* Very small screen button fixes */
 @media (max-width: 380px) {
      /* Force smaller buttons on very small screens */
      .bottom-nav-buttons button {
        padding-top: 0.375rem !important;    /* 6px */
        padding-bottom: 0.375rem !important; /* 6px */
        padding-left: 0.5rem !important;     /* 8px */
        padding-right: 0.5rem !important;    /* 8px */
        font-size: 0.75rem !important;       /* 12px */
      }
    }

  </style>
</head>
<body>
  <div id="root"></div>
  
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Shared utils (schema + helpers; no UI changes) -->
  <script src="./shared-utils.js"></script>
  <!-- Preflight self-heal (normalize storage shape before app code runs) -->
  <script>try{ window.APP_UTILS && window.APP_UTILS.readDataSafe(); }catch(e){}</script>
  
  <!-- Mobile Bridge Script -->
  <script>
    (function registrationMobileBridge(){
      const MOBILE = (window.top !== window.self);

      // Do nothing if not embedded; desktop/iPad remains unchanged
      if (!MOBILE) return;

      window.__mobileFlow = false;
      window.__mobileCourt = null;

      // Public helpers if not already present
      window.RegistrationUI = window.RegistrationUI || {};
      window.RegistrationUI.setSelectedCourt = function(n) {
        // This will be implemented when we find the UI object
        console.log('Mobile: Setting selected court to', n);
      };
      window.RegistrationUI.startRegistration = function(n) {
        // open "Enter name…" and focus input
        console.log('Mobile: Starting registration for court', n);
      };

      // 1) Start flow on message from Mobile shell
      window.addEventListener('message', e => {
        const d = e?.data; if (!d || d.type !== 'register') return;
        const n = Number(d.courtNumber);
        window.__mobileFlow = true;
        window.__mobileCourt = Number.isFinite(n) ? n : null;

        console.log('Mobile: Received register message for court', n);

        // Preselect tapped court if still free (safe check)
        try {
          const data = readJSON('tennisClubData') || getEmptyData();
          const now = new Date();
          const c = data?.courts?.[n-1];
          const occ = !!c?.current;
          const blocks = readJSON('courtBlocks') || [];
          const blk = blocks.some(b => b.courtNumber===n && new Date(b.startTime)<now && now<new Date(b.endTime));
          if (Number.isFinite(n) && !occ && !blk) {
            window.RegistrationUI.setSelectedCourt(n);
          }
        } catch(e) {
          console.log('Mobile: Error checking court availability:', e);
        }

        window.RegistrationUI.startRegistration(n);
      });

      // 2) Success handler - will be attached when UI is ready
      window.__mobileSuccessHandler = function(courtNumber) {
        if (!window.__mobileFlow) return;
        const n = Number(courtNumber) || Number(window.__mobileCourt) || null;
        try { 
          window.parent.postMessage({ type:'registration:success', courtNumber: n }, '*'); 
        } catch(e) {
          console.log('Mobile: Error sending success message:', e);
        }
        window.__mobileFlow = false; 
        window.__mobileCourt = null;
      };
    })();
  </script>
  
  <!-- Mobile Guards Script -->
  <script>
    (function mobileGuards(){
      // --- tiny state accessors (adapt if your state shape differs)
      function hasPrimaryPlayer(){
        try {
          const s = window.UI?.state || {};
          // common patterns: single "playerName" OR players[0]
          if (s.playerName && String(s.playerName).trim().length) return true;
          if (Array.isArray(s.players) && s.players[0] && String(s.players[0].name||s.players[0]).trim().length) return true;
          
          // Check React state for currentGroup
          if (window.__reactState && Array.isArray(window.__reactState.currentGroup) && window.__reactState.currentGroup.length > 0) {
            const firstPlayer = window.__reactState.currentGroup[0];
            if (firstPlayer && firstPlayer.name && String(firstPlayer.name).trim().length) {
              return true;
            }
          }
          
          // Check search input as well
          const searchInput = document.querySelector('#main-search-input');
          if (searchInput && searchInput.value && String(searchInput.value).trim().length > 0) {
            return true;
          }
        } catch {}
        return false;
      }

      // Ensure the "Enter name" UI opens and focuses
      function ensureNameEntryOpen(){
        try { window.UI?.openRegistrationPanel?.(); } catch {}
        requestAnimationFrame(() => {
          const input = document.querySelector('#mobile-group-search-input')
                   || document.querySelector('#main-search-input')
                   || document.querySelector('[data-role="player-input"]')
                   || document.querySelector('#playerNameInput')
                   || document.querySelector('input[type="text"]');
          input?.focus?.({ preventScroll:true });
          try { const v=input.value||''; input.setSelectionRange(v.length, v.length); } catch {}
        });
      }

      // 1A) Patch the stepper so "group" is blocked until a player exists (mobile only)
      (function patchStepperGuard(){
        const api = window.UI || window;
        const go  = api.goToStep || api.setStep || api.navigate || null;
        if (!go) return;

        const wrapped = function(next){
          // map/skip welcome + court picker as before
          if (window.__mobileFlow) {
            const s = String(next||'').toLowerCase();
            if (s.includes('welcome') || s.includes('home')) next = 'group';
            if (s.includes('select') && s.includes('court')) next = 'group';
            // NEW GUARD: don't allow group if no primary player yet
            if (s.includes('group') && !hasPrimaryPlayer()) {
              next = 'group'; // Stay on group but ensure name input is focused
              // open the name panel if it's not visible
              setTimeout(ensureNameEntryOpen, 0);
            }
          }
          return go.call(this, next);
        };

        if (api.goToStep) api.goToStep = wrapped;
        else if (api.setStep) api.setStep = wrapped;
        else if (api.navigate) api.navigate = wrapped;
      })();

      // 1B) When the user submits their name, jump to Group (mobile only)
      (function patchNameSubmit(){
        const api = window.UI || window;
        if (typeof api.onNameSubmitted === 'function' && !api.__nameToGroupPatched){
          const orig = api.onNameSubmitted;
          api.onNameSubmitted = function(...args){
            const res = orig.apply(this, args);
            if (window.__mobileFlow) {
              // only proceed if a player really exists now
              if (hasPrimaryPlayer()) {
                (api.goToStep || api.setStep || api.navigate)?.call(api, 'group');
              } else {
                // keep user on name entry until valid
                setTimeout(ensureNameEntryOpen, 0);
              }
            }
            return res;
          };
          api.__nameToGroupPatched = true;
        }
      })();
    })();
  </script>
  
  <!-- Mobile Success Signal Script -->
  <script>
    (function mobileSuccessSignal(){
      const MOBILE = (window.top !== window.self);
      if (!MOBILE) return;

      function sendSuccess(){
        const api = window.UI || window;
        const n   = Number(window.__mobileCourt) || Number(api?.state?.selectedCourt) || window.__preselectedCourt || null;

        dbg('Registration: Sending success signal for court', n, 'mobile flow:', window.__mobileFlow);
        try {
          window.parent.postMessage({ type: 'registration:success', courtNumber: n }, '*');
          dbg('Registration: Success message sent successfully');
        } catch(e) {
          if (DEBUG) console.log('Registration: Error sending success message:', e);
        }

        // clear mobile flags (so standalone flows remain clean)
        window.__mobileFlow  = false;
        window.__mobileCourt = null;
      }

      const api = window.UI || window;
      if (typeof api.onRegistrationSuccess === 'function' && !api.__mobileSuccessBridge){
        const orig = api.onRegistrationSuccess;
        api.onRegistrationSuccess = function(...args){
          const res = orig.apply(this, args);
          // IMPORTANT: call after internal success state is set
          setTimeout(sendSuccess, 0);
          return res;
        };
        api.__mobileSuccessBridge = true;
      } else {
        // If there isn't a centralized success hook, attach to global
        window.UI = window.UI || {};
        window.UI.__mobileSendSuccess__ = () => setTimeout(sendSuccess, 0);
      }

      // OPTIONAL: disable or delay any auto-reset-to-home when in mobile flow
      // If you have a success auto-reset timer, gate it:
      if (api.setAutoResetMs && !api.__mobileResetGuard){
        const origSet = api.setAutoResetMs;
        api.setAutoResetMs = function(ms){
          if (window.__mobileFlow) return; // ignore resets in mobile overlay
          return origSet.call(this, ms);
        };
        api.__mobileResetGuard = true;
      }
    })();
  </script>
  
  <!-- Load shared modules before app script -->
  <script src="./shared/config.js"></script>
  <script src="./shared/storage.js"></script>
  <script src="./shared/events.js"></script>
  <script src="./shared/datastore.js"></script>
  <script src="./shared/maintenance.js"></script>
  <script src="./shared/dataservice.js"></script>
  
  <!-- Load domain modules -->
  <script src="./domain/time.js"></script>
  <script src="./domain/availability.js"></script>
  <script src="./domain/waitlist.js"></script>
  <script src="./domain/blocks.js"></script>
  <script src="./domain/wetCourts.js"></script>
  <script src="./domain/selfTest.js"></script>
  
  <script>
(function(){
  // Define global helper
  window.computeEtaPreview = function computeEtaPreview() {
    try {
      const Storage = window.Tennis.Storage;
      const Avail   = window.Tennis.Domain.availability || window.Tennis.Domain.Availability;
      const Wait    = window.Tennis.Domain.waitlist     || window.Tennis.Domain.Waitlist;
      const Time    = window.Tennis.Domain.time         || window.Tennis.Domain.Time;

      // ensure placeholder exists (self-healing)
      let el = document.getElementById('etaPreview');
      if (!el) {
        const make = () => {
          const d = document.createElement('div');
          d.id = 'etaPreview';
          d.setAttribute('aria-live', 'polite');
          d.style.marginTop = '8px';
          d.style.fontSize = '0.95rem';
          d.style.opacity = '0.9';
          return d;
        };
        // Try common containers, then fall back to <body>
        const container =
          document.querySelector('form') ||
          document.querySelector('#main, #app, #root, main') ||
          document.body;
        el = make();
        container.appendChild(el);
      }

      const now    = new Date();
      const data   = Storage.readDataSafe();
      const blocks = Storage.readJSON(Storage.STORAGE.BLOCKS) || [];
      const wetSet = new Set(
        blocks.filter(b => b?.isWetCourt && new Date(b.startTime) <= now && new Date(b.endTime) > now)
              .map(b => b.courtNumber)
      );
      const nextTimes = Avail.getNextFreeTimes({ data, now, blocks });
      const info      = Avail.getFreeCourtsInfo({ data, now, blocks, wetSet });
      const freeCount = Array.isArray(info?.free) ? info.free.length : 0;

      // robust queue length detection
      const qLen =
        (Array.isArray(data?.waitlist) && data.waitlist.length) ||
        (Array.isArray(data?.queue) && data.queue.length) ||
        (Array.isArray(data?.registration?.waitlist) && data.registration.waitlist.length) ||
        0;
      const position = qLen + 1;

      const etas = Wait.estimateWaitForPositions({
        positions: [position],
        currentFreeCount: freeCount,
        nextFreeTimes: nextTimes,
        avgGameMinutes: window.Tennis.Config.Timing.AVG_GAME
      });
      const minutes = Array.isArray(etas) ? etas[0] : null;
      const label   = (minutes == null) ? '—'
                     : (minutes <= 0)   ? 'Now'
                     : `${minutes} min`;

      if (el) {
        el.textContent = `Estimated wait if you join now: ${label}`;
        el.setAttribute('data-eta-minutes', minutes ?? '');
      } else {
        dbg('[Registration ETA preview]', { position, minutes, label, freeCount, qLen });
      }
    } catch (e) {
      console.warn('ETA preview error:', e);
    }
  };

  // Call once on load, and wire event when available
  function initEta() {
    if (typeof window.computeEtaPreview === 'function') {
      window.computeEtaPreview();
    }
    const E = window.Tennis && window.Tennis.Events;
    if (E && typeof E.onDom === 'function') {
      E.onDom('tennisDataUpdate', () => window.computeEtaPreview());
    } else {
      // Retry a few times in case Events isn't ready yet
      let tries = 0;
      const id = setInterval(() => {
        const Ev = window.Tennis && window.Tennis.Events;
        if (Ev && typeof Ev.onDom === 'function') {
          clearInterval(id);
          Ev.onDom('tennisDataUpdate', () => window.computeEtaPreview());
        }
        if (++tries > 20) clearInterval(id);
      }, 150);
    }
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initEta);
  } else {
    initEta();
  }
})();
</script>

  <script>
(function registerAutoClear() {
  const DEBUG = false;
  const dbg = (...a) => DEBUG && console.log(...a);
  const run = () => {
    try {
      const fn = window.__autoClearOverdueSessions;
      if (typeof fn === 'function') {
        const n = fn(); // may clear 0+
        dbg('[AutoClear@Registration] cleared', n, 'overdue sessions');
      }
    } catch (e) { /* swallow in prod */ }
  };
  // run once on boot
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(run, 0);
  } else {
    window.addEventListener('DOMContentLoaded', run, { once: true });
  }
  // run every 5 minutes (cooperative with Board/Admin; safe to double-run)
  const FIVE_MIN = 5 * 60 * 1000;
  window.__autoClearRegTimer && clearInterval(window.__autoClearRegTimer);
  window.__autoClearRegTimer = setInterval(run, FIVE_MIN);
})();
</script>
  
  <script type="text/babel">
    // Access shared utils (optional convenience)
    const U = window.APP_UTILS || {};
    
    // === Shared Core Integration Flag ===
    const USE_SHARED_CORE = true;
    const USE_SHARED_DOMAIN = true;
    const USE_DOMAIN_ETA_PREVIEW = true;
    const DEBUG = false; // Gate noisy logs
    const dbg = (...args) => { if (DEBUG) console.log(...args); };
    
    // Coalesce multiple update events into a single refresh
    let __refreshPending = false;
    function scheduleAvailabilityRefresh() {
      if (__refreshPending) return;
      __refreshPending = true;
      setTimeout(() => {
        __refreshPending = false;
        // Resolve the refresh function safely
        const fn =
          (typeof window.loadData === 'function' && window.loadData) ||
          (typeof loadData === 'function' && loadData) ||
          null;
        if (fn) fn();
      }, 0);
    }
    
    const Config  = USE_SHARED_CORE ? window.Tennis.Config  : null;
    const Storage = window.Tennis.Storage;
    const Events  = window.Tennis.Events;
    const A       = window.Tennis.Domain.availability || window.Tennis.Domain.Availability;
    const USE_DOMAIN_SELECTABLE = true; // feature flag
    // DataStore will be initialized later with the original class if USE_SHARED_CORE is false
    let dataStore = USE_SHARED_CORE ? window.Tennis.DataStore : null;
    
    // Domain module handles
    const Time    = window.Tennis.Domain.time         || window.Tennis.Domain.Time;
    const Avail   = window.Tennis.Domain.availability || window.Tennis.Domain.Availability;
    const Wait    = window.Tennis.Domain.waitlist     || window.Tennis.Domain.Waitlist;
    const W       = window.Tennis.Domain.waitlist || window.Tennis.Domain.Waitlist;
    
    // Individual function/constant redirects for backward compatibility
    const readJSON = USE_SHARED_CORE ? Storage.readJSON : ((key) => { try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : null; } catch { return null; } });
    const writeJSON = USE_SHARED_CORE ? Storage.writeJSON : ((key, val) => { try { localStorage.setItem(key, JSON.stringify(val)); return true; } catch { return false; } });
    const readDataSafe = USE_SHARED_CORE ? Storage.readDataSafe : (() => readJSON(STORAGE_ORIGINAL.DATA) || getEmptyData());
    const getEmptyData = USE_SHARED_CORE ? Storage.getEmptyData : (() => ({ __schema: 1, courts: Array(12).fill(null), waitingGroups: [], recentlyCleared: [], calculatedAvailability: null }));
    const STORAGE = USE_SHARED_CORE ? Storage.KEYS : STORAGE_ORIGINAL;
    const EVENTS = { UPDATE: 'tennisDataUpdate' };

    function validateGroupCompat(players, guests) {
      const W = (window.Tennis.Domain.waitlist || window.Tennis.Domain.Waitlist);
      const norm = (ok, errs) => ({ ok: !!ok, errors: Array.isArray(errs) ? errs : (errs ? [errs] : []) });
      if (!W || typeof W.validateGroup !== 'function') return norm(true, []);

      // Try new API (object)
      try {
        const out = W.validateGroup({ players, guests });
        if (out && (typeof out.ok === 'boolean' || Array.isArray(out.errors))) {
          return norm(out.ok, out.errors);
        }
      } catch(_) {}

      // Candidate arrays for legacy API
      const cands = [
        players,                                                  // [{id,name}, ...] or similar
        Array.isArray(players) ? players.map(p => p?.name).filter(Boolean) : [], // ['Name', ...]
        Array.isArray(players) ? players.map(p => p?.id).filter(Boolean)   : [], // ['ID', ...]
      ].filter(arr => Array.isArray(arr) && arr.length > 0);

      for (const cand of cands) {
        try {
          const out = W.validateGroup(cand);
          if (out && typeof out.valid === 'boolean') {
            return norm(out.valid, out.error || []);
          }
          if (Array.isArray(out)) {
            return norm(out.length === 0, out);
          }
          if (typeof out === 'string') {
            return norm(false, out);
          }
        } catch(_) {}
      }
      // Conservative default if all attempts are ambiguous
      return norm(true, []);
    }
    
    // ---- Original Storage & Event keys (kept intact but unused when USE_SHARED_CORE=true) ----
    const STORAGE_ORIGINAL = {
      DATA: 'tennisClubData',
      SETTINGS: 'tennisClubSettings',
      BLOCKS: 'courtBlocks',
      UPDATE_TICK: 'tennisDataUpdateTick'
    };
    
    // ---- Original JSON storage helpers removed (now using shadowed versions above) ----
    
    // ---- Core constants (declared only; not replacing existing usages) ----
    const APP = {
      COURT_COUNT: 12,
      PLAYERS: { MIN: 1, MAX: 4 },
      DURATION_MIN: { SINGLES: 60, DOUBLES: 90, MAX: 240 }
    };
    
    // ---- Dev flag & assert (no UI change) ----
    const DEV = (typeof location !== 'undefined') && /localhost|127\.0\.0\.1/.test(location.host);
    const assert = (cond, msg, obj) => { if (DEV && !cond) console.warn('ASSERT:', msg, obj||''); };
    
    // ---- Logger (no UI change) ----
    const LOG_LEVEL = (DEV ? 'debug' : 'warn'); // 'debug'|'info'|'warn'|'silent'
    const _PREFIX = '[Registration]';
    const log = {
      debug: (...a)=> { if (['debug'].includes(LOG_LEVEL)) console.debug(_PREFIX, ...a); },
      info:  (...a)=> { if (['debug','info'].includes(LOG_LEVEL)) console.info(_PREFIX, ...a); },
      warn:  (...a)=> { if (['debug','info','warn'].includes(LOG_LEVEL)) console.warn(_PREFIX, ...a); },
    };
    
    const { useState, useEffect, useRef } = React;

// ============================================================
// Section: Data access & persistence
// ============================================================

// Initialize DataStore immediately
class TennisCourtDataStore {
  constructor() {
    this.cache = new Map();
    this.metrics = {
      cacheHits: 0,
      cacheMisses: 0,
      totalOperations: 0,
      totalResponseTime: 0,
      storageOperationsSaved: 0
    };
    
    // Initialize immediately
    this.warmCache();
  }

  warmCache() {
    const keys = ['tennisClubData', 'tennisClubSettings', 'tennisBlockTemplates', 'tennisRecurringBlocks', 'tennisBallPurchases', 'tennisAnalytics', 'courtBlocks', 'tennisGuestCharges'];
    keys.forEach(key => {
      const data = localStorage.getItem(key);
      if (data) {
        try {
          this.cache.set(key, JSON.parse(data));
        } catch (e) {
          console.warn(`Failed to parse ${key}:`, e);
        }
      }
    });
  }

  async get(key) {
    const startTime = performance.now();
    this.metrics.totalOperations++;
    
    if (this.cache.has(key)) {
      this.metrics.cacheHits++;
      const responseTime = performance.now() - startTime;
      this.metrics.totalResponseTime += responseTime;
      return this.cache.get(key);
    }
    
    this.metrics.cacheMisses++;
    this.metrics.storageOperationsSaved++;
    
    const data = localStorage.getItem(key);
    let parsed = null;
    if (data) {
      try {
        parsed = JSON.parse(data);
        this.cache.set(key, parsed);
      } catch (e) {
        console.warn(`Failed to parse ${key}:`, e);
      }
    }
    
    const responseTime = performance.now() - startTime;
    this.metrics.totalResponseTime += responseTime;
    return parsed;
  }

  async set(key, data, options = {}) {
    const startTime = performance.now();
    this.metrics.totalOperations++;
    
    this.cache.set(key, data);
    
    if (options.immediate || key === 'tennisClubData' || key === 'courtBlocks') {
      localStorage.setItem(key, JSON.stringify(data));
    }
    
    const responseTime = performance.now() - startTime;
    this.metrics.totalResponseTime += responseTime;
    
    // Dispatch update event for real-time sync
    if (USE_SHARED_CORE && Events) {
      Events.emitDom(EVENTS.UPDATE, { key, data });
    } else {
      window.dispatchEvent(new CustomEvent(EVENTS.UPDATE, { detail: { key, data } }));
    }
  }

  getMetrics() {
    const avgResponseTime = this.metrics.totalOperations > 0 
      ? this.metrics.totalResponseTime / this.metrics.totalOperations 
      : 0;
    
    const cacheHitRate = this.metrics.totalOperations > 0 
      ? (this.metrics.cacheHits / this.metrics.totalOperations) * 100 
      : 0;

    return {
      ...this.metrics,
      avgResponseTime: parseFloat(avgResponseTime.toFixed(3)),
      cacheHitRate: parseFloat(cacheHitRate.toFixed(1))
    };
  }
}

// Initialize original DataStore instance (will be unused if USE_SHARED_CORE is true)
const dataStoreOriginal = new (window.APP_UTILS?.TennisCourtDataStore || class {})();
// Use shadowed dataStore or fallback to original
if (!USE_SHARED_CORE) {
  dataStore = dataStoreOriginal;
}

// Boot data assertion
const _bootData = (U.readDataSafe ? U.readDataSafe() : (readJSON(STORAGE.DATA) || getEmptyData()));
assert(!_bootData || Array.isArray(_bootData.courts), 'Expected data.courts array on boot', _bootData);

// Emoji Icons (matching AdminPanelV2 pattern)
const Users = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>👥</span>;
const Bell = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>🔔</span>;
const Clock = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>⏰</span>;
const UserPlus = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>👤➕</span>;
const ChevronRight = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>▶️</span>;
const Check = ({ size = 24 }) => <span style={{ fontSize: `${size}px` }}>✅</span>;

// Original Configuration (kept intact but unused when USE_SHARED_CORE=true)
const TENNIS_CONFIG_ORIGINAL = {
  COURTS: {
    TOTAL_COUNT: 12,
    TOP_ROW: [1, 2, 3, 4, 5, 6, 7, 8],
    BOTTOM_ROW: [12, 11, 10, 9]
  },
  TIMING: {
    MAX_PLAY_DURATION_MS: 210 * 60 * 1000, // 3.5 hours in milliseconds
    MAX_PLAY_DURATION_MIN: 210, // 3.5 hours in minutes
    TIMEOUT_WARNING_MIN: 180, // 3 hours in minutes for warning
    SINGLES_DURATION_MIN: 60, // 60 minutes for < 4 players
    DOUBLES_DURATION_MIN: 90, // 90 minutes for 4 players
    AVG_GAME_TIME_MIN: 75, // Average game time for wait calculations
    POLL_INTERVAL_MS: 5000, // Poll for updates every 5 seconds
    UPDATE_INTERVAL_MS: 1000, // Update time every second
    SESSION_TIMEOUT_MS: 120000, // 2 minutes in milliseconds
    SESSION_WARNING_MS: 90000, // 90 seconds in milliseconds
    CHANGE_COURT_TIMEOUT_SEC: 30, // 30 seconds to change court
    AUTO_RESET_SUCCESS_MS: 30000, // 30 seconds auto-reset on success screen
    ALERT_DISPLAY_MS: 3000, // 3 seconds for alerts
    AUTO_RESET_CLEAR_MS: 5000 // 5 seconds auto-reset after clearing court
  },
  DISPLAY: {
    MAX_WAITING_DISPLAY: 6, // Maximum waiting groups to display
    MAX_AUTOCOMPLETE_RESULTS: 8,
    MAX_FREQUENT_PARTNERS: 6,
    HEADER_MARGIN_LEFT: '300px' // For centering the clock
  },
  PLAYERS: {
    MAX_PER_GROUP: 4,
    MIN_PER_GROUP: 1
  },

    STORAGE: {
  KEY: 'tennisClubData',
  UPDATE_EVENT: 'tennisDataUpdate',
  SETTINGS_KEY: 'tennisClubSettings',
  BALL_SALES_KEY: 'tennisBallPurchases',  // ADD THIS LINE
  GUEST_CHARGES_KEY: 'tennisGuestCharges'  // For tracking guest fees
},
  ADMIN: {
    ACCESS_CODE: '9999'
  },
  PRICING: {
    TENNIS_BALLS: 5.50 // Default price for tennis balls
  },
  GEOLOCATION: {
    ENABLED: false,  // ADD THIS LINE - Set to false for development
    CLUB_CENTER: {
      latitude: 29.919030,
      longitude: -90.114767
    },
    ALLOWED_RADIUS_METERS: 200,
    DENIAL_MESSAGE: "Please register on the tablet at the sign in desk",
    CHECKING_MESSAGE: "Verifying location...",
    ERROR_MESSAGE: "Location services required. Please register on the tablet at the sign in desk",
    TIMEOUT_MS: 10000
  }
};

// Shadowed TENNIS_CONFIG (routes to shared core or original based on USE_SHARED_CORE flag)
const TENNIS_CONFIG = USE_SHARED_CORE ? {
  COURTS: {
    TOTAL_COUNT: Config.Courts.TOTAL_COUNT,
    TOP_ROW: Config.Courts.TOP_ROW,
    BOTTOM_ROW: Config.Courts.BOTTOM_ROW
  },
  TIMING: {
    MAX_PLAY_DURATION_MS: Config.Timing.MAX_PLAY * 60 * 1000,
    MAX_PLAY_DURATION_MIN: Config.Timing.MAX_PLAY,
    TIMEOUT_WARNING_MIN: 180,
    SINGLES_DURATION_MIN: Config.Timing.SINGLES,
    DOUBLES_DURATION_MIN: Config.Timing.DOUBLES,
    AVG_GAME_TIME_MIN: Config.Timing.AVG_GAME,
    POLL_INTERVAL_MS: 5000,
    UPDATE_INTERVAL_MS: 1000,
    SESSION_TIMEOUT_MS: 120000,
    SESSION_WARNING_MS: 90000,
    CHANGE_COURT_TIMEOUT_SEC: 30,
    AUTO_RESET_SUCCESS_MS: 30000,
    ALERT_DISPLAY_MS: 3000,
    AUTO_RESET_CLEAR_MS: 5000
  },
  DISPLAY: {
    MAX_WAITING_DISPLAY: Config.Display.MAX_WAITING_DISPLAY,
    MAX_AUTOCOMPLETE_RESULTS: 8,
    MAX_FREQUENT_PARTNERS: 6,
    HEADER_MARGIN_LEFT: '300px'
  },
  PLAYERS: {
    MAX_PER_GROUP: 4,
    MIN_PER_GROUP: 1
  },
  STORAGE: {
    KEY: Storage.KEYS.DATA,
    UPDATE_EVENT: EVENTS.UPDATE,
    SETTINGS_KEY: Storage.KEYS.SETTINGS,
    BLOCK_TEMPLATES_KEY: 'tennisBlockTemplates',
    RECURRING_BLOCKS_KEY: 'tennisRecurringBlocks',
    BALL_SALES_KEY: 'tennisBallPurchases',
    ANALYTICS_KEY: 'tennisAnalytics',
    GUEST_CHARGES_KEY: 'tennisGuestCharges'
  },
  ADMIN: {
    ACCESS_CODE: '9999'
  },
  PRICING: {
    TENNIS_BALLS: 5.50
  },
  GEOLOCATION: {
    ENABLED: false,
    CLUB_CENTER: {
      latitude: 29.9511,
      longitude: -90.0715
    },
    ALLOWED_RADIUS_METERS: 200,
    CHECKING_MESSAGE: "Checking your location...",
    DENIAL_MESSAGE: "You must be at the club to register for courts. Please register on the tablet at the sign in desk.",
    ERROR_MESSAGE: "Location services required. Please register on the tablet at the sign in desk",
    TIMEOUT_MS: 10000
  }
} : TENNIS_CONFIG_ORIGINAL;

// Data Validation Utilities (in real app, import from './utils/validation')
const DataValidation = {
  isValidCourtNumber(courtNumber) {
    return Number.isInteger(courtNumber) && 
           courtNumber >= 1 && 
           courtNumber <= TENNIS_CONFIG.COURTS.TOTAL_COUNT;
  },

  isValidPlayer(player) {
    return player && 
           typeof player === 'object' &&
           typeof player.id === 'number' &&
           typeof player.name === 'string' &&
           player.name.trim().length > 0;
  },

  isValidGroup(group) {
    return Array.isArray(group) &&
           group.length >= 0 && // Changed from MIN_PER_GROUP to allow empty arrays for blocked courts
           group.length <= TENNIS_CONFIG.PLAYERS.MAX_PER_GROUP &&
           group.every(player => this.isValidPlayer(player));
  },

  isValidDuration(duration) {
    return Number.isInteger(duration) && duration > 0 && duration <= 240; // Max 4 hours
  },

  isValidDate(date) {
    return date instanceof Date && !isNaN(date.getTime());
  },

  isValidCourtData(court) {
    if (!court) return true; // null/empty court is valid
    
    // Special case for cleared courts
    if (court.wasCleared) {
      return court &&
             typeof court === 'object' &&
             this.isValidGroup(court.players) &&
             this.isValidDate(new Date(court.startTime)) &&
             this.isValidDate(new Date(court.endTime));
    }
    
    // Special case for NEW STRUCTURE with current and history
    if (court.current || court.history) {
      // Validate the new structure
      const hasValidHistory = !court.history || Array.isArray(court.history);
      const hasValidCurrent = !court.current || (
        court.current &&
        typeof court.current === 'object' &&
        this.isValidGroup(court.current.players) &&
        this.isValidDate(new Date(court.current.startTime)) &&
        this.isValidDate(new Date(court.current.endTime))
      );
      
      return hasValidHistory && hasValidCurrent;
    }

    // Remove old block validation - blocks are now handled via courtBlocks localStorage
// Old court.blocked properties are no longer used
    
    // Regular court validation
    return court &&
           typeof court === 'object' &&
           this.isValidGroup(court.players) &&
           this.isValidDate(new Date(court.startTime)) &&
           this.isValidDate(new Date(court.endTime)) &&
           new Date(court.endTime) > new Date(court.startTime);
  },

  sanitizeStorageData(data) {
    // Ensure data has the correct structure
    const sanitized = {
      courts: Array(TENNIS_CONFIG.COURTS.TOTAL_COUNT).fill(null),
      waitingGroups: [],
      recentlyCleared: [] // Include in sanitized structure
    };

    // Validate and copy courts
    if (Array.isArray(data.courts)) {
      data.courts.forEach((court, index) => {
        if (index < TENNIS_CONFIG.COURTS.TOTAL_COUNT) {
          if (this.isValidCourtData(court)) {
            sanitized.courts[index] = court;
          }
        }
      });
    }

    // Validate and copy waiting groups
      if (Array.isArray(data.waitingGroups)) {
      sanitized.waitingGroups = data.waitingGroups.filter(group => {
        return group &&
               typeof group === 'object' &&
               this.isValidGroup(group.players) &&
               this.isValidDate(new Date(group.timestamp || new Date()));
      });
    }

    // Validate and copy recently cleared sessions
      if (Array.isArray(data.recentlyCleared)) {
      const now = new Date();
      sanitized.recentlyCleared = data.recentlyCleared.filter(session => {
        const isValid = session &&
               typeof session === 'object' &&
               this.isValidGroup(session.players) &&
               session.originalEndTime &&
               this.isValidDate(new Date(session.originalEndTime)) &&
               new Date(session.originalEndTime) > now; // Only keep future end times
        
     if (!isValid && session) {
          if (DEBUG) {
            log.debug("Filtered out session:", {
              session,
              hasValidGroup: session.players ? this.isValidGroup(session.players) : false,
              hasOriginalEndTime: !!session.originalEndTime,
              isValidDate: session.originalEndTime ? this.isValidDate(new Date(session.originalEndTime)) : false,
              isFutureEndTime: session.originalEndTime ? new Date(session.originalEndTime) > now : false
            });
          }
        }
        
        return isValid;
      });
    }

    return sanitized;
  }
};

// Tennis Data Service (in real app, import from './TennisDataService')
const TennisDataService = {
  STORAGE_KEY: TENNIS_CONFIG.STORAGE.KEY,
  COURT_COUNT: TENNIS_CONFIG.COURTS.TOTAL_COUNT,
  
  getEmptyData() {
    return {
      courts: Array(this.COURT_COUNT).fill(null),
      waitingGroups: [],
      recentlyCleared: [] // New array to track sessions cleared before their end time
    };
  },

  async loadData() {
    try {
      const data = await dataStore.get(this.STORAGE_KEY);
      if (!data) return this.getEmptyData();
      
      if (!data || typeof data !== 'object') return this.getEmptyData();
      
      // Use validation to ensure data integrity
      const sanitized = DataValidation.sanitizeStorageData(data);
      
      // Ensure recentlyCleared array exists
      if (!sanitized.recentlyCleared) {
        sanitized.recentlyCleared = [];
      }
      
      return sanitized;
    } catch (error) {
      console.error('Failed to load court data:', error);
      return this.getEmptyData();
    }
  },

  async saveData(data) {
  try {
    // PRE-CALCULATE availability data before saving
    data.calculatedAvailability = {
      waitTimes: await this.calculateWaitTimes(data),
      nextAvailable: await this.calculateNextAvailable(data),
      timestamp: new Date().toISOString()
    };
    
    log.debug("TennisDataService.saveData - data to save:", {
      courtsCount: data.courts ? data.courts.length : 0,
      waitingGroupsCount: data.waitingGroups ? data.waitingGroups.length : 0,
      recentlyClearedCount: data.recentlyCleared ? data.recentlyCleared.length : 0,
      calculatedWaitTimes: data.calculatedAvailability.waitTimes, // Debug log
      calculatedNextAvailable: data.calculatedAvailability.nextAvailable.length
    });
    
    // --- Guard: do not clobber active courts with an empty snapshot ---
    try {
      const now = new Date();
      const current = Tennis.Storage.readDataSafe();
      const currAssigned = (current?.courts || []).filter(c => !!c?.current).length;
      const nextAssigned = (data?.courts || []).filter(c => !!c?.current).length;

      // if we currently have active courts, and the candidate write has none,
      // AND at least one current court's endTime is still in the future, skip this write
      const hasFutureCurrent = (current?.courts || []).some(c => {
        const end = c?.current?.endTime ? new Date(c.current.endTime) : null;
          return end && !isNaN(end) && end > now;
      });

      if (currAssigned > 0 && nextAssigned === 0 && hasFutureCurrent) {
        console.warn('[saveData] Skip write: candidate snapshot has assigned=0 but live data has active courts with future end times');
        // still emit events so listeners can recompute without losing state
        Tennis.Events.emitDom('DATA_UPDATED', { key: Tennis.Storage.STORAGE.DATA, data: current });
        Tennis.Events.emitDom('tennisDataUpdate', { key: Tennis.Storage.STORAGE.DATA, data: current });
        return { success: true, skipped: true };
      }
    } catch (e) {
      console.warn('[saveData] Guard check failed:', e?.message);
    }
    // --- End guard ---
    
    await dataStore.set(this.STORAGE_KEY, data, { immediate: true });
    Tennis.Events.emitDom('tennisDataUpdate', { key: Tennis.Storage.STORAGE.DATA, data });
    return { success: true };
  } catch (error) {
    if (error.name === 'QuotaExceededError') {
      return { success: false, error: 'Storage is full. Please clear some browser data.' };
    }
    return { success: false, error: 'Failed to save data. Please try again.' };
  }
},

  // Service-local validation that tolerates legacy and new APIs
  serviceValidateGroupCompat(group) {
    const W = (window.Tennis?.Domain?.waitlist || window.Tennis?.Domain?.Waitlist);
    const norm = (ok, errs) => ({ ok: !!ok, errors: Array.isArray(errs) ? errs : (errs ? [errs] : []) });
    if (!W || typeof W.validateGroup !== 'function') return norm(true, []);

    const playersArr = Array.isArray(group?.players) ? group.players
                     : Array.isArray(group)          ? group
                     : [];
    // 1) Legacy: array of player objects (this branch is known-good from your trace)
    try {
      const out = W.validateGroup(playersArr);
      if (out && typeof out.valid === 'boolean') return norm(out.valid, out.error || []);
      if (Array.isArray(out))                    return norm(out.length === 0, out);
      if (typeof out === 'string')               return norm(false, out);
    } catch (_) {}

    // 2) New API: object shape
    try {
      const out = W.validateGroup({ players: playersArr, guests: group?.guests ?? 0 });
      if (out && (typeof out.ok === 'boolean' || Array.isArray(out.errors))) {
        return norm(out.ok, out.errors);
      }
    } catch (_) {}

    // 3) Names fallback (some older builds)
    try {
      const names = playersArr.map(p => p?.name).filter(Boolean);
      const out = W.validateGroup(names);
      if (out && typeof out.valid === 'boolean') return norm(out.valid, out.error || []);
      if (Array.isArray(out))                    return norm(out.length === 0, out);
      if (typeof out === 'string')               return norm(false, out);
    } catch (_) {}

    return norm(true, []); // conservative default
  },

  async assignCourt(courtNumber, group, duration) {
    // at the very top of assignCourt(courtNumber, group, duration)
    const groupObj = Array.isArray(group) ? { players: group, guests: 0 } : (group || {});
    const playersArray = Array.isArray(groupObj.players) ? groupObj.players : [];
    const guests = Number.isFinite(groupObj.guests) ? groupObj.guests : 0;
    
    // Validate inputs
    if (!DataValidation.isValidCourtNumber(courtNumber)) {
      return { success: false, error: `Invalid court number. Please select 1-${this.COURT_COUNT}.` };
    }
    
    // Group validation handled by serviceValidateGroupCompat

    const { ok, errors } = this.serviceValidateGroupCompat(groupObj);
    if (!ok) {
      return { success: false, error: (errors && errors.join(', ')) || 'Validation error' };
    }
    
    if (!DataValidation.isValidDuration(duration)) {
      return { success: false, error: 'Invalid duration. Please select a valid time period.' };
    }
    
    // Read the fresh snapshot
    const S = window.Tennis?.Storage;
    const DataStore = window.DataStore || window.Tennis?.DataStore;
    const latest = S.readDataSafe() || {};
    // deep clone (avoid mutating the cached object)
    const next = typeof structuredClone === 'function'
      ? structuredClone(latest)
      : JSON.parse(JSON.stringify(latest));

    // Ensure shape
    const courtCount = (window.Tennis?.Config?.Courts?.TOTAL_COUNT) || (next.courts?.length) || 12;
    next.courts = Array.isArray(next.courts) ? next.courts.slice() : Array.from({length: courtCount}, () => null);
    next.waitingGroups = Array.isArray(next.waitingGroups) ? next.waitingGroups.slice() : [];
    next.recentlyCleared = Array.isArray(next.recentlyCleared) ? next.recentlyCleared.slice() : [];

    // Compute assignment payload (keep existing duration logic)
    const idx = courtNumber - 1;
    const now = new Date();
    
    // Check if any player in this group recently cleared a court
    const originalEndTime = TennisBusinessLogic.getOriginalEndTimeForGroup(playersArray, next.recentlyCleared);
    
    let end;
    if (originalEndTime && new Date(originalEndTime) > now) {
      // Use the original end time to prevent time extension abuse
      end = new Date(originalEndTime);
      console.log(`Group contains players who recently cleared early. Using original end time: ${end.toLocaleTimeString()}`);
    } else {
      // Normal case - calculate end time based on duration
      end = new Date(now.getTime() + (duration * 60000));
    }
    
    const assignment = {
      players: playersArray,
      guests,
      startTime: now.toISOString(),
      endTime: end.toISOString(),
      assignedAt: now.toISOString(),
      duration
    };

    // Preserve other courts; only touch the target index
    const existingCourt = next.courts[idx];
    let replacedGroup = null;
    
    // If target court had a current session, capture it for return value
    if (existingCourt?.current) {
      replacedGroup = {
        players: existingCourt.current.players,
        endTime: existingCourt.current.endTime
      };
    }
    
    // Set the assignment on target court only
    next.courts[idx] = { ...(existingCourt || {}), current: assignment };
    
    // Remove the assigned group from waitlist if they were waiting
    const groupMemberIds = playersArray.map(p => p.id);
    next.waitingGroups = next.waitingGroups.filter(waitingGroup => {
      const waitingIds = waitingGroup.players.map(p => p.id);
      return !groupMemberIds.some(id => waitingIds.includes(id));
    });

    // Write via the unified path (uses StorageGuard + UPDATE_TICK + dual events)
    if (typeof DataStore?.set === 'function') {
      await DataStore.set(S.STORAGE.DATA, next);
    } else {
      // extremely unlikely fallback; prefer DataStore.set
      S.writeJSON(S.STORAGE.UPDATE_TICK, Date.now());
      S.writeJSON(S.STORAGE.DATA, next);
      window.Tennis?.Events?.emitDom?.('DATA_UPDATED', { key: S.STORAGE.DATA, data: next });
      window.Tennis?.Events?.emitDom?.('tennisDataUpdate', { key: S.STORAGE.DATA, data: next });
    }
    
    return { success: true, replacedGroup: replacedGroup };
  },

  // Add this helper method to TennisDataService
  convertToNewFormat(court) {
    if (!court) return null;
    
    // If it already has the new format, return as-is
    if (court.current || court.history) {
      return court;
    }
    
    // Convert old format to new format
    if (court.players) {
      return {
        current: {
          players: court.players,
          startTime: court.startTime,
          endTime: court.endTime,
          assignedAt: court.assignedAt,
          duration: court.duration
        },
        history: []
      };
    }
    
    return null;
  },

  async clearCourt(courtNumber) {
    // Fresh read & deep clone
    const raw = Tennis.Storage.readDataSafe() || {};
    const data = (typeof structuredClone === 'function')
      ? structuredClone(raw)
      : JSON.parse(JSON.stringify(raw));

    // Normalize arrays and index
    const idx = Math.max(0, (parseInt(courtNumber, 10) || 0) - 1);
    data.courts = Array.isArray(data.courts) ? data.courts : [];
    // Ensure court slot exists
    data.courts[idx] = data.courts[idx] || { history: [] };
    const court = data.courts[idx];
    court.history = Array.isArray(court.history) ? court.history : [];

    // If no current, return a helpful error (but do NOT lie about success)
    if (!court.current) {
      return { success: false, error: `Court ${idx+1} is already empty.` };
    }

    // Move current to history and end it "now" if needed
    const now = new Date();
    const cur = court.current;
    // Ensure endTime is not in the future after a manual clear
    const end = cur?.endTime ? new Date(cur.endTime) : null;
    if (!end || isNaN(end) || end > now) {
      cur.endTime = now.toISOString();
    }
    court.history.push(cur);
    court.current = null;

    // Persist via unified path (no direct localStorage.setItem)
    const key = Tennis.Storage.STORAGE.DATA;
    Tennis.DataStore.set(key, data); // this writes via guarded writeJSON, updates UPDATE_TICK, and emits both events
    return { success: true };
  },

  // Change court assignment (move group from one court to another)
  async changeCourt(fromCourtNumber, toCourtNumber, group, duration, originalCourtData) {
    if (fromCourtNumber < 1 || fromCourtNumber > this.COURT_COUNT || 
        toCourtNumber < 1 || toCourtNumber > this.COURT_COUNT) {
      return { success: false, error: `Invalid court number.` };
    }
    
    const data = await this.loadData();
    
    // Clear the previous court (or restore original overtime data)
    if (originalCourtData) {
      data.courts[fromCourtNumber - 1] = originalCourtData;
    } else {
      data.courts[fromCourtNumber - 1] = null;
    }
    
    // Assign the new court
    const now = new Date();
    const endTime = new Date();
    endTime.setMinutes(endTime.getMinutes() + duration);
    
    // Check if replacing an overtime court
    const previousCourt = data.courts[toCourtNumber - 1];
    let replacedGroup = null;
    
    if (previousCourt && new Date(previousCourt.endTime) <= now) {
      replacedGroup = {
        players: previousCourt.players,
        endTime: previousCourt.endTime
      };
      
      // Preserve the history of the overtime court
      if (previousCourt.players && previousCourt.players.length > 0 && !previousCourt.wasCleared) {
        // Update the existing court to mark it as cleared
        data.courts[toCourtNumber - 1].endTime = now.toISOString();
        data.courts[toCourtNumber - 1].wasCleared = true;
        
        // Save this state first to preserve history
        const historyResult = await this.saveData(data);
        if (!historyResult.success) {
          return historyResult; // Return the error
        }
        
        // Reload data to ensure consistency
        const updatedData = await this.loadData();
        data.courts = updatedData.courts;
      }
    }
    
    data.courts[toCourtNumber - 1] = {
      players: group,
      startTime: now,
      endTime: endTime,
      assignedAt: now,
      duration: duration
    };
    
    const result = await this.saveData(data);
    
    if (result.success) {
      return { 
        success: true, 
        replacedGroup: replacedGroup 
      };
    }
    
    return result;
  },

  async addToWaitlist(group) {
    // Build the group object from existing form fields / variables
    const players = group.map(p => ({
      id: String(p.id || '').trim(),
      name: String(p.name || '').trim()
    })).filter(p => p && p.id && p.name);

    const guests = group.filter(p => p.isGuest).length;

    const validation = W.validateGroup({ players, guests });
    const { ok, errors } = validation || { ok: false, errors: ['Validation failed'] };
    if (!ok) {
      return { success: false, error: (errors || ['Unknown validation error']).join('\n') };
    }
    
    const data = await this.loadData();
    data.waitingGroups.push({ 
      players: group, 
      timestamp: new Date() 
    });
    
    return await this.saveData(data);
  },

  async removeFromWaitlist(index) {
    const data = await this.loadData();
    
    if (index < 0 || index >= data.waitingGroups.length) {
      return { success: false, error: 'Invalid waitlist position.' };
    }
    
    data.waitingGroups.splice(index, 1);
    return await this.saveData(data);
  },

  async clearAllCourts() {
    const data = await this.loadData();
    data.courts = Array(this.COURT_COUNT).fill(null);
    return await this.saveData(data);
  },

  async clearWaitlist() {
    const data = await this.loadData();
    data.waitingGroups = [];
    return await this.saveData(data);
  },

  // Move court (admin function)
  async moveCourt(fromCourtNumber, toCourtNumber) {
    if (fromCourtNumber < 1 || fromCourtNumber > this.COURT_COUNT || 
        toCourtNumber < 1 || toCourtNumber > this.COURT_COUNT) {
      return { success: false, error: `Invalid court number.` };
    }
    
    const data = await this.loadData();
    
    // Check if source court is occupied
    if (!data.courts[fromCourtNumber - 1]) {
      return { success: false, error: `Court ${fromCourtNumber} is empty.` };
    }
    
    // Check if destination court is occupied
    if (data.courts[toCourtNumber - 1]) {
      return { success: false, error: `Court ${toCourtNumber} is already occupied.` };
    }
    
    // Move the court data
    data.courts[toCourtNumber - 1] = data.courts[fromCourtNumber - 1];
    data.courts[fromCourtNumber - 1] = null;
    
    return await this.saveData(data);
  },

  async resetSystem() {
    return await this.saveData(this.getEmptyData());
  },

  // NEW: Court Block Management
  async getCourtBlocks() {
    try {
      const blocks = await dataStore.get('courtBlocks');
      return blocks || [];
    } catch (error) {
      console.error('Failed to load court blocks:', error);
      return [];
    }
  },

  async saveCourtBlocks(blocks) {
    try {
      await dataStore.set('courtBlocks', blocks, { immediate: true });
      if (USE_SHARED_CORE && Events) {
        Events.emitDom(TENNIS_CONFIG.STORAGE.UPDATE_EVENT, {});
      } else {
        window.dispatchEvent(new Event(TENNIS_CONFIG.STORAGE.UPDATE_EVENT));
      }
      return { success: true };
    } catch (error) {
      return { success: false, error: 'Failed to save blocks' };
    }
  },

  async addCourtBlock(courtNumber, reason, startTime, endTime) {
    const blocks = await this.getCourtBlocks();
    
    // Remove any existing blocks for this court in the same time period
    const filtered = blocks.filter(block => {
      if (block.courtNumber !== courtNumber) return true;
      const blockEnd = new Date(block.endTime);
      const newStart = new Date(startTime);
      return blockEnd <= newStart || new Date(block.startTime) >= new Date(endTime);
    });
    
    // Add new block
    filtered.push({
      id: Date.now(),
      courtNumber,
      reason,
      startTime,
      endTime,
      createdAt: new Date().toISOString()
    });
    
    return await this.saveCourtBlocks(filtered);
  },

  async removeCourtBlock(blockId) {
    const blocks = await this.getCourtBlocks();
    const filtered = blocks.filter(block => block.id !== blockId);
    return await this.saveCourtBlocks(filtered);
  },

// For ACTIVE LOGIC - only current/future blocks
getActiveBlocksForCourt(courtNumber, currentTime = new Date()) {
  const blocks = JSON.parse(localStorage.getItem('courtBlocks') || '[]');
  return blocks
    .filter(block => 
      block.courtNumber === courtNumber && 
      new Date(block.endTime) >= currentTime
    )
    .sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
},

// For TIMELINE DISPLAY - all blocks for today
async getAllBlocksForCourt(courtNumber, date = new Date()) {
  const blocks = await this.getCourtBlocks();
  const startOfDay = new Date(date);
  startOfDay.setHours(0, 0, 0, 0);
  const endOfDay = new Date(date);
  endOfDay.setHours(23, 59, 59, 999);
  
  return blocks
    .filter(block => {
      if (block.courtNumber !== courtNumber) return false;
      const blockStart = new Date(block.startTime);
      return blockStart >= startOfDay && blockStart <= endOfDay;
    })
    .sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
},
  
  async getAvailableCourts() {
  console.log('TennisDataService.getAvailableCourts running!');
  const data = await this.loadData();
  const availableCourts = [];
  
  for (let index = 0; index < data.courts.length; index++) {
    const court = data.courts[index];
    const courtNumber = index + 1;
    
    // Check if currently blocked using new system
    const blockStatus = await getCourtBlockStatus(courtNumber);
    if (blockStatus && blockStatus.isCurrent) {
      continue; // Skip this court - it's blocked
    }
    
    let isOccupied = false;
    
    // Check new structure
    if (court?.current?.players?.length > 0) {
      isOccupied = true;
    }
    // Check old structure
    else if (court?.players?.length > 0) {
      isOccupied = true;
    }
    
    if (!isOccupied) {
      availableCourts.push(courtNumber);
    }
  }
  
  console.log('Available courts:', availableCourts);
  return availableCourts;
} ,

  

  async checkDataSize() {
    console.log('=== DATA SIZE CHECK ===');
  
  // Check court blocks
  const blocks = await dataStore.get('courtBlocks');
  if (blocks) {
    const now = new Date();
    const expiredBlocks = blocks.filter(b => new Date(b.endTime) < now);
    console.log(`Court Blocks: ${blocks.length} total (${expiredBlocks.length} expired)`);
  }
  
  // Check court history
  const data = this.loadData();
  let totalHistory = 0;
  let oldHistory = 0;
  const sevenDaysAgo = new Date();
  sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
  
  data.courts.forEach((court, i) => {
    if (court && court.history) {
      totalHistory += court.history.length;
      court.history.forEach(session => {
        if (new Date(session.startTime) < sevenDaysAgo) {
          oldHistory++;
        }
      });
    }
  });
  
  console.log(`Court History: ${totalHistory} total sessions (${oldHistory} older than 7 days)`);
  console.log('===================');
},

  async cleanupExpiredBlocks() {
    const blocks = await dataStore.get('courtBlocks');
    if (!blocks) return;
    const now = new Date();
    
    // Keep only current and future blocks
    const activeBlocks = blocks.filter(block => {
      const blockEnd = new Date(block.endTime);
      return blockEnd > now;
    });
    
    const removedCount = blocks.length - activeBlocks.length;
    
    if (removedCount > 0) {
      await dataStore.set('courtBlocks', activeBlocks, { immediate: true });
      console.log(`✅ Cleaned up ${removedCount} expired blocks. ${activeBlocks.length} active blocks remain.`);
    } else {
      console.log('✅ No expired blocks to clean up.');
    }
    
    return removedCount;
  },

// Add these functions inside TennisDataService object, after the existing functions

async calculateWaitTimes(data) {
  if (!data.waitingGroups || data.waitingGroups.length === 0) return [];
  
  const waitTimes = [];
  
  for (let index = 0; index < data.waitingGroups.length; index++) {
    const group = data.waitingGroups[index];
    const position = index + 1;
    const waitTime = await this.calculateEstimatedWaitTimeForGroup(position, data.courts, new Date());
    waitTimes.push(waitTime);
  }
  
  return waitTimes;
},


async calculateEstimatedWaitTimeForGroup(position, courts, currentTime) {
  if (!courts || !Array.isArray(courts) || position < 1) return 0;
  
  console.log(`DEBUG: Calculating wait time for position ${position} at ${currentTime.toLocaleTimeString()}`);
  
  const availabilitySlots = [];
  
  for (let index = 0; index < courts.length; index++) {
    const court = courts[index];
    const courtNumber = index + 1;
    const nextAvailableTime = await this.getCourtNextTrueAvailability(court, courtNumber, currentTime);
    
    console.log(`DEBUG: Court ${courtNumber} next available at:`, {
      timestamp: nextAvailableTime,
      localTime: new Date(nextAvailableTime).toLocaleTimeString(),
      minutesFromNow: Math.ceil((nextAvailableTime - currentTime.getTime()) / 60000)
    });
    
    if (nextAvailableTime > currentTime.getTime()) {
      availabilitySlots.push(nextAvailableTime);
    } else {
      // Available now
      availabilitySlots.push(currentTime.getTime());
    }
  }
  
  // Sort availability slots
  availabilitySlots.sort((a, b) => a - b);
  
  console.log(`DEBUG: Sorted availability slots:`, availabilitySlots.map(slot => ({
    localTime: new Date(slot).toLocaleTimeString(),
    minutesFromNow: Math.ceil((slot - currentTime.getTime()) / 60000)
  })));
  
  // Calculate wait time based on position
  if (availabilitySlots.length === 0 && position === 1) return 0;
  
  if (position <= availabilitySlots.length) {
    const waitMinutes = Math.ceil((availabilitySlots[position - 1] - currentTime.getTime()) / 60000);
    console.log(`DEBUG: Position ${position} wait time: ${waitMinutes} minutes`);
    return waitMinutes;
  }
  
  // Estimate cycles if position exceeds immediate slots
  const rounds = Math.ceil(position / courts.length);
  if (availabilitySlots.length > 0) {
    let waitTime = Math.ceil((availabilitySlots[0] - currentTime.getTime()) / 60000);
    waitTime += (rounds - 1) * 75;
    console.log(`DEBUG: Position ${position} (overflow) wait time: ${waitTime} minutes`);
    return waitTime;
  }
  
  const fallbackWait = Math.ceil(((position - 1) / courts.length) * 75);
  console.log(`DEBUG: Position ${position} (fallback) wait time: ${fallbackWait} minutes`);
  return fallbackWait;
},



async getCourtNextTrueAvailability(court, courtNumber, currentTime) {
  try {
    // Get all future blocks for this court
    const allBlocks = await this.getActiveBlocksForCourt(courtNumber, new Date(0));
    const filteredBlocks = allBlocks
      .filter(block => new Date(block.endTime) > currentTime)
      .sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
    
    // IMPORTANT: Work with local timestamps throughout
    let checkTime = currentTime.getTime();
    
    // If court has current session, start from session end
    if (court?.current?.endTime) {
      const sessionEndTime = new Date(court.current.endTime).getTime();
      checkTime = Math.max(checkTime, sessionEndTime);
    } else if (court?.endTime) {
      const sessionEndTime = new Date(court.endTime).getTime();
      checkTime = Math.max(checkTime, sessionEndTime);
    }
    
    // Process all blocks to find final availability
    for (const block of filteredBlocks) {
      // Convert block times to local timestamps for comparison
      const blockStart = new Date(block.startTime).getTime();
      const blockEnd = new Date(block.endTime).getTime();
      
      console.log(`DEBUG: Court ${courtNumber} block ${block.reason}:`, {
        blockStartLocal: new Date(blockStart).toLocaleTimeString(),
        blockEndLocal: new Date(blockEnd).toLocaleTimeString(),
        checkTimeLocal: new Date(checkTime).toLocaleTimeString(),
        currentTimeLocal: new Date(currentTime).toLocaleTimeString()
      });
      
      // If this block starts at or before our check time, move check time to block end
      if (blockStart <= checkTime) {
        checkTime = Math.max(checkTime, blockEnd);
        console.log(`DEBUG: Court ${courtNumber} check time moved to:`, new Date(checkTime).toLocaleTimeString());
      }
      // If there's a gap before this block, court is available at checkTime
      else {
        console.log(`DEBUG: Court ${courtNumber} gap found, available at:`, new Date(checkTime).toLocaleTimeString());
        break;
      }
    }
    
    console.log(`DEBUG: Court ${courtNumber} final availability:`, new Date(checkTime).toLocaleTimeString());
    return checkTime;
    
  } catch (error) {
    console.error('Error calculating court availability:', error);
    // Fallback logic
    if (court?.current?.endTime) {
      return new Date(court.current.endTime).getTime();
    } else if (court?.endTime) {
      return new Date(court.endTime).getTime();
    }
    return currentTime.getTime();
  }
},

async calculateNextAvailable(data) {
  const availableCourts = [];
  
  if (!data.courts || !Array.isArray(data.courts)) {
    return availableCourts;
  }
  
  const currentTime = new Date();
  
  for (let index = 0; index < data.courts.length; index++) {
    const court = data.courts[index];
    const courtNumber = index + 1;
    const nextAvailableTime = await this.getCourtNextTrueAvailability(court, courtNumber, currentTime);
    
    availableCourts.push({
      courtNumber: courtNumber,
      availableAt: new Date(nextAvailableTime).toISOString()
    });
  }
  
  return availableCourts.sort((a, b) => new Date(a.availableAt) - new Date(b.availableAt));
},

};  

// Tennis Business Logic (in real app, import from './TennisBusinessLogic')
const TennisBusinessLogic = {
  formatPlayerDisplayName(name) {
    if (!name) return '';
    const nameParts = name.trim().split(' ');
    const firstName = nameParts[0] || '';
    const lastName = nameParts[nameParts.length - 1] || firstName;
    return nameParts.length > 1 
      ? `${firstName.charAt(0)}. ${lastName}` 
      : firstName;
  },

  
  calculateEstimatedWaitTime(position, courts, currentTime, avgGameTime = 75) {
  if (!courts || !Array.isArray(courts) || position < 1) return 0;

  const courtEndTimes = courts
    .map(court => {
      if (!court) return null;

      // Prefer end time of current game if available
      if (court.current?.endTime) {
        return new Date(court.current.endTime).getTime();
      }

      // Check for blocks using new system
      const courtIndex = courts.indexOf(court);
      const blockStatus = getCourtBlockStatus(courtIndex + 1);
      if (blockStatus && blockStatus.endTime) {
        return new Date(blockStatus.endTime).getTime();
      }

      return null;
    })
    .filter(time => time && time > currentTime.getTime())
    .sort((a, b) => a - b);

  // No courts ending soon, and you're first in line
  if (courtEndTimes.length === 0 && position === 1) return 0;

  // If your position is within the count of courts, return estimated time for that slot
  if (position <= courtEndTimes.length) {
    return Math.ceil((courtEndTimes[position - 1] - currentTime.getTime()) / 60000);
  }

  // Estimate based on cycles (rounds) through courts
  const courtsAvailable = courts.length;
  const rounds = Math.ceil(position / courtsAvailable);

  if (courtEndTimes.length > 0) {
    let waitTime = Math.ceil((courtEndTimes[0] - currentTime.getTime()) / 60000);
    waitTime += (rounds - 1) * avgGameTime;
    return waitTime;
  } else {
    return Math.ceil(((position - 1) / courtsAvailable) * avgGameTime);
  }
},

    
  isPlayerAlreadyPlaying(playerId, data, currentGroup = []) {
    // Check courts
// Check courts
for (let i = 0; i < data.courts.length; i++) {
  const court = data.courts[i];
  
  // Check old structure
  if (court && court.players && court.players.some(player => player.id === playerId)) {
    const player = court.players.find(p => p.id === playerId);
    return { 
      isPlaying: true, 
      location: 'court', 
      courtNumber: i + 1,
      playerName: player ? player.name : 'Player'
    };
  }
  
  // Check new structure
  if (court && court.current && court.current.players && court.current.players.some(player => player.id === playerId)) {
    const player = court.current.players.find(p => p.id === playerId);
    return { 
      isPlaying: true, 
      location: 'court', 
      courtNumber: i + 1,
      playerName: player ? player.name : 'Player'
    };
  }
}
    // Check waiting groups
    for (let i = 0; i < data.waitingGroups.length; i++) {
      const group = data.waitingGroups[i];
      if (group.players.some(player => player.id === playerId)) {
        const player = group.players.find(p => p.id === playerId);
        return { 
          isPlaying: true, 
          location: 'waiting', 
          position: i + 1,
          playerName: player ? player.name : 'Player'
        };
      }
    }
    
    // Check current group
    if (currentGroup.some(player => player.id === playerId)) {
      const player = currentGroup.find(p => p.id === playerId);
      return { 
        isPlaying: true, 
        location: 'current',
        playerName: player ? player.name : 'Player'
      };
    }
    
    return { isPlaying: false };
  },

  calculateGameDuration(groupSize, singlesMinutes = TENNIS_CONFIG.TIMING.SINGLES_DURATION_MIN, doublesMinutes = TENNIS_CONFIG.TIMING.DOUBLES_DURATION_MIN, maxPlayers = TENNIS_CONFIG.PLAYERS.MAX_PER_GROUP) {
    return groupSize >= maxPlayers ? doublesMinutes : singlesMinutes;
  },

  // NEW HELPER FUNCTIONS FOR RE-REGISTRATION BLOCKING
  
  /**
   * Check if two groups have overlapping players
   * Returns object with overlap details
   */
  checkGroupOverlap(group1, group2) {
    if (!group1 || !group2 || !Array.isArray(group1) || !Array.isArray(group2)) {
      return { hasOverlap: false, overlappingPlayers: [], isSubset: false, isSuperset: false };
    }
    
    const ids1 = group1.map(p => p.id);
    const ids2 = group2.map(p => p.id);
    
    const overlappingIds = ids1.filter(id => ids2.includes(id));
    const overlappingPlayers = group1.filter(p => overlappingIds.includes(p.id));
    
    const result = {
      hasOverlap: overlappingIds.length > 0,
      overlappingPlayers: overlappingPlayers,
      overlappingCount: overlappingIds.length,
      isExactMatch: ids1.length === ids2.length && overlappingIds.length === ids1.length,
      isSubset: overlappingIds.length === ids2.length && ids1.length > ids2.length,
      isSuperset: overlappingIds.length === ids1.length && ids2.length > ids1.length,
      group1Size: ids1.length,
      group2Size: ids2.length
    };
    
    console.log("checkGroupOverlap result:", {
      group1Ids: ids1,
      group2Ids: ids2,
      overlappingIds: overlappingIds,
      result: result
    });
    
    return result;
  },

  /**
   * Check if any player in a group recently cleared a court and return their original end time
   * Used to enforce consistent session end times when players re-register early
   */
  getOriginalEndTimeForGroup(players, recentlyCleared) {
    const ps = Array.isArray(players) ? players : [];
    const rc = Array.isArray(recentlyCleared) ? recentlyCleared : [];
    if (ps.length === 0) return null;  // nothing to derive
    
    if (rc.length === 0) {
      return null;
    }
    
    const now = new Date();
    const groupMemberIds = ps.map(p => p.id);
    
    // Check each recently cleared session
    for (const session of rc) {
      // Skip if session has expired
      if (new Date(session.originalEndTime) <= now) {
        continue;
      }
      
      // Check if any player from this group was in the recently cleared session
      const sessionMemberIds = Array.isArray(session.players) ? session.players.map(p => p.id) : [];
      const hasOverlap = groupMemberIds.some(id => sessionMemberIds.includes(id));
      
      if (hasOverlap) {
        return session.originalEndTime;
      }
    }
    
    return null;
  }
};

// ADD THIS ENTIRE GEOLOCATIONSERVICE OBJECT HERE:
const GeolocationService = {
  // Calculate distance between two coordinates using Haversine formula
  calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371e3; // Earth's radius in meters
    const φ1 = lat1 * Math.PI / 180;
    const φ2 = lat2 * Math.PI / 180;
    const Δφ = (lat2 - lat1) * Math.PI / 180;
    const Δλ = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c; // Distance in meters
  },

  // Check if user is within club boundaries
  async verifyAtClub() {
    return new Promise((resolve, reject) => {
      // Check if geolocation is available
      if (!navigator.geolocation) {
        reject(new Error('Geolocation not supported'));
        return;
      }

      // Set up timeout
      const timeout = setTimeout(() => {
        reject(new Error('Location request timed out'));
      }, TENNIS_CONFIG.GEOLOCATION.TIMEOUT_MS);

      // Request current position
      navigator.geolocation.getCurrentPosition(
        (position) => {
          clearTimeout(timeout);
          
          const distance = this.calculateDistance(
            position.coords.latitude,
            position.coords.longitude,
            TENNIS_CONFIG.GEOLOCATION.CLUB_CENTER.latitude,
            TENNIS_CONFIG.GEOLOCATION.CLUB_CENTER.longitude
          );

          console.log(`Distance from club: ${Math.round(distance)}m`);

          if (distance <= TENNIS_CONFIG.GEOLOCATION.ALLOWED_RADIUS_METERS) {
            resolve({ success: true, distance: Math.round(distance) });
          } else {
            resolve({ 
              success: false, 
              distance: Math.round(distance),
              message: TENNIS_CONFIG.GEOLOCATION.DENIAL_MESSAGE 
            });
          }
        },
        (error) => {
          clearTimeout(timeout);
          console.error('Geolocation error:', error);
          reject(error);
        },
        {
          enableHighAccuracy: true,
          timeout: TENNIS_CONFIG.GEOLOCATION.TIMEOUT_MS,
          maximumAge: 0
        }
      );
    });
  }
};

// Alert Display Component (in real app, this would be imported from './components/AlertDisplay')
const AlertDisplay = ({ show, message }) => {
  if (!show) return null;
  
  return (
    <div className="fixed top-4 right-4 left-4 sm:left-auto sm:right-8 bg-red-500 text-white p-4 sm:p-6 rounded-xl shadow-lg z-50 text-base sm:text-lg max-w-sm sm:max-w-none">
      {message}
    </div>
  );
};

// Welcome Screen Component (in real app, import from './components/WelcomeScreen')
const WelcomeScreen = ({ onRegisterClick, onClearCourtClick }) => {
  return (
    <div className="w-full h-full min-h-screen bg-gradient-to-br from-green-50 to-blue-50 flex items-center justify-center p-4 sm:p-8">
      <div className="text-center w-full max-w-md">
        <p className="text-lg sm:text-xl text-gray-600 mb-8 sm:mb-12">Tennis Court Registration</p>
        <button
          onClick={onRegisterClick}
          className="bg-gradient-to-r from-green-500 to-green-600 text-white text-xl sm:text-2xl font-bold py-4 sm:py-6 px-8 sm:px-12 rounded-xl shadow-lg hover:from-green-600 hover:to-green-700 button-transition transform hover:scale-105 mb-8 sm:mb-16 block w-full"
        >
          Register for a court
        </button>
        <button
          onClick={onClearCourtClick}
          className="bg-gradient-to-r from-blue-300 to-blue-400 text-white text-xl sm:text-2xl font-bold py-4 sm:py-6 px-8 sm:px-12 rounded-xl shadow-lg hover:from-blue-400 hover:to-blue-500 button-transition transform hover:scale-105 block w-full"
        >
          Clear a court
        </button>
      </div>
    </div>
  );
};

// Success Screen Component (in real app, import from './components/SuccessScreen')
const SuccessScreen = ({ 
  isCourtAssignment, 
  justAssignedCourt, 
  assignedCourt, 
  replacedGroup, 
  canChangeCourt, 
  changeTimeRemaining, 
  position, 
  estimatedWait,
  onChangeCourt,
  onNewRegistration,
  onHome,
  currentGroup, // Added to support ball purchase
  mobileCountdown // Added for mobile auto-close countdown
}) => {
  const [showBallPurchaseModal, setShowBallPurchaseModal] = useState(false);
  const [ballPurchaseOption, setBallPurchaseOption] = useState('');
  const [ballsPurchased, setBallsPurchased] = useState(false);
  const [purchaseDetails, setPurchaseDetails] = useState(null);
  
  // Get tennis ball price from settings (with fallback to default)
  const [ballPrice, setBallPrice] = useState(TENNIS_CONFIG.PRICING.TENNIS_BALLS);
  
  useEffect(() => {
    const loadBallPrice = async () => {
      try {
        const settings = await dataStore.get(TENNIS_CONFIG.STORAGE.SETTINGS_KEY);
        if (settings) {
          const parsed = settings || {};
          setBallPrice(parsed.tennisBallPrice || TENNIS_CONFIG.PRICING.TENNIS_BALLS);
        }
      } catch (error) {
        console.error('Failed to load ball price:', error);
      }
    };
    loadBallPrice();
  }, []);
  
  const nonGuestPlayers = currentGroup.filter(p => !p.isGuest).length;
  const splitPrice = nonGuestPlayers > 0 ? ballPrice / nonGuestPlayers : ballPrice;
  
  // Get member's last 4 digits (mock implementation - in real app, would come from member data)
  const getLastFourDigits = React.useCallback((memberNumber) => {
    return memberNumber ? memberNumber.slice(-4).padStart(4, '0') : '****';
  }, []);
  
  const handleBallPurchase = React.useCallback(async () => {
    // Process the purchase
    if (ballPurchaseOption === 'charge') {
      setPurchaseDetails({
        type: 'single',
        amount: ballPrice,
        accounts: [getLastFourDigits(currentGroup[0]?.memberNumber)]
      });
    } else {
      setPurchaseDetails({
        type: 'split',
        amount: splitPrice,
        accounts: currentGroup.filter(p => !p.isGuest).map(p => getLastFourDigits(p.memberNumber))
      });
    }
    
// Save purchase to localStorage
const purchase = {
  id: Date.now(),
  timestamp: new Date().toISOString(),
  type: ballPurchaseOption,
  amount: ballPurchaseOption === 'charge' ? ballPrice : splitPrice,
  totalAmount: ballPurchaseOption === 'charge' ? ballPrice : splitPrice * nonGuestPlayers,
  players: ballPurchaseOption === 'charge' 
    ? [currentGroup[0]] 
    : currentGroup.filter(p => !p.isGuest),
  courtNumber: justAssignedCourt
};

// Get existing purchases
const existingPurchases = await dataStore.get('tennisBallPurchases') || [];
existingPurchases.push(purchase);

// read current, modify in-memory, then persist via the service
const data = Tennis.Storage.readDataSafe();
data.tennisBallPurchases = existingPurchases;
await TennisDataService.saveData(data);

setBallsPurchased(true);
setShowBallPurchaseModal(false);
}, [ballPurchaseOption, ballPrice, splitPrice, currentGroup, getLastFourDigits, justAssignedCourt]);
 
// Fixed layout card component
  const SuccessCard = ({ headerContent, mainContent, footerContent }) => (
    <div className="bg-white rounded-3xl shadow-2xl w-full max-w-[600px] h-auto md:h-[550px]">
      {/* Fixed header area - always 80px on desktop, auto on mobile */}
      <div className="h-auto md:h-20 bg-gray-200 rounded-t-3xl p-4">
        {headerContent}
      </div>
      
      {/* Fixed main content area - auto height on mobile, 310px on desktop */}
      <div className="h-auto md:h-[310px] p-6 sm:p-8 flex flex-col justify-center">
        {mainContent}
      </div>
      
      {/* Fixed footer area - auto height on mobile, 160px on desktop */}
      <div className="h-auto md:h-[160px] px-6 sm:px-8 pb-6 sm:pb-8">
        {footerContent || <div className="h-full" />}
      </div>
    </div>
  );

  // Header content for both success types
  const headerContent = (
    <div className="flex justify-between items-center h-full">
      <button
        onClick={onHome}
        className="bg-gray-400 text-white px-4 sm:px-6 py-2 rounded-full text-sm sm:text-base font-medium hover:bg-gray-500 transition-colors duration-150"
      >
        Home
      </button>
      <button
        onClick={onNewRegistration}
        className="bg-green-500 text-white px-4 sm:px-6 py-2 rounded-full text-sm sm:text-base font-medium hover:bg-green-600 transition-colors duration-150"
      >
        New Registration
      </button>
    </div>
  );
  
  if (isCourtAssignment) {
    // Court assignment main content
    const courtMainContent = (
      <>
        <div className="flex flex-col items-center mb-4 sm:mb-6">
          <div className="w-12 h-12 sm:w-16 sm:h-16 bg-green-500 rounded-full flex items-center justify-center mb-2 sm:mb-3">
            <Check size={32} className="text-white sm:w-10 sm:h-10" />
          </div>
          <h1 className="text-2xl sm:text-3xl font-bold bg-gradient-to-r from-green-600 to-teal-600 bg-clip-text text-transparent">
            Confirmed!
          </h1>
          {mobileCountdown !== null && mobileCountdown > 0 && (
            <p className="text-sm text-gray-500 mt-2">Closing in {mobileCountdown}...</p>
          )}
        </div>
        <div className="bg-green-50 rounded-2xl p-4 sm:p-6 text-center">
          <p className="text-lg sm:text-xl text-gray-700 mb-2">You're all set on</p>
          <p className="text-2xl sm:text-3xl font-bold text-green-600">Court {justAssignedCourt}</p>
          {assignedCourt && (
            <>
              <p className="text-base sm:text-lg text-gray-600 mt-3">
                Priority until{" "}
                <strong>
                  {new Date(assignedCourt.current?.endTime || assignedCourt.endTime).toLocaleTimeString([], {
                    hour: "2-digit",
                    minute: "2-digit"
                  })}
                </strong>


                {(() => {
  const courtBlockStatus = getCourtBlockStatus(justAssignedCourt);
  const sessionEndTime = new Date(assignedCourt.current?.endTime || assignedCourt.endTime);
  
  return courtBlockStatus && courtBlockStatus.isBlocked && 
         new Date(courtBlockStatus.startTime) <= sessionEndTime ? (
    <span className="text-orange-600 ml-2 block sm:inline">
      (Limited due to {courtBlockStatus.reason})
    </span>
  ) : null;
})()}


              </p>
              {replacedGroup && replacedGroup.players && replacedGroup.players.length > 0 && (
                <p className="text-xs sm:text-sm text-orange-600 font-medium mt-2">
                  Please courteously request {replacedGroup.players[0].name} and partners conclude their play
                </p>
              )}
            </>
          )}
        </div>
      </>
    );

    // Court assignment footer content
    const courtFooterContent = !ballsPurchased ? (
      <div className="bg-yellow-50 rounded-2xl p-3 sm:p-4 h-full flex items-center">
        <div className="flex flex-col sm:flex-row gap-2 sm:gap-3 w-full">
          {canChangeCourt && changeTimeRemaining > 0 && (
            <button
              onClick={onChangeCourt}
              className="flex-1 bg-blue-100 text-blue-700 px-4 sm:px-6 py-2 sm:py-2.5 rounded-full text-sm sm:text-base font-medium hover:bg-blue-200 transition-colors duration-150"
            >
              Change Court <span className="text-black">{changeTimeRemaining}</span>
            </button>
          )}
          <button
            onClick={() => setShowBallPurchaseModal(true)}
            className="flex-1 bg-gradient-to-r from-amber-500 to-amber-400 text-white px-4 sm:px-6 py-2 sm:py-2.5 rounded-full text-sm sm:text-base font-medium hover:from-amber-600 hover:to-amber-500 transition-colors duration-150 flex items-center justify-center gap-2 shadow-md"
          >
            <span className="text-lg sm:text-xl">🎾</span>
            <span>Add Balls</span>
          </button>
        </div>
      </div>
    ) : (
      <div className="bg-green-50 rounded-2xl p-3 sm:p-4 h-full flex items-center justify-center">
        <div>
          <div className="flex items-center justify-center gap-2 sm:gap-3 mb-1">
            <Check size={16} className="text-green-600 sm:w-5 sm:h-5" />
            <p className="text-sm sm:text-base font-medium text-green-800">
              Balls Added: ${purchaseDetails.type === 'single' ? ballPrice.toFixed(2) : `${splitPrice.toFixed(2)} each`}
            </p>
          </div>
          <p className="text-xs sm:text-sm text-gray-600 text-center">
            Charged to account{purchaseDetails.accounts.length > 1 ? 's' : ''}: {purchaseDetails.accounts.join(', ')}
          </p>
        </div>
      </div>
    );

    return (
      <div className="w-full h-full min-h-screen bg-gradient-to-br from-green-50 to-blue-50 flex items-center justify-center relative overflow-hidden p-4">
        <SuccessCard 
          headerContent={headerContent}
          mainContent={courtMainContent}
          footerContent={courtFooterContent}
        />
        
        {/* Ball Purchase Modal - outside of the main card to prevent re-renders */}
        {showBallPurchaseModal && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
            <div className="bg-white rounded-2xl p-4 sm:p-6 w-full max-w-[420px] mx-4">
              <h3 className="text-xl sm:text-2xl font-bold text-center mb-4 sm:mb-6">
                Purchase Tennis Balls
              </h3>
              
              <div className="space-y-2 sm:space-y-3 mb-4 sm:mb-6">
                <label 
                  className={`block p-3 sm:p-4 rounded-xl border-2 cursor-pointer transition-all ${
                    ballPurchaseOption === 'charge' 
                      ? 'border-green-500 bg-green-50' 
                      : 'border-gray-200 hover:border-gray-300'
                  }`}
                >
                  <input
                    type="radio"
                    name="ballOption"
                    value="charge"
                    checked={ballPurchaseOption === 'charge'}
                    onChange={(e) => setBallPurchaseOption(e.target.value)}
                    className="sr-only"
                  />
                  <div className="flex justify-between items-center">
                    <div>
                      <p className="font-medium text-sm sm:text-base">Charge to account</p>
                      <p className="text-xs sm:text-sm text-gray-600">
                        Account ending in {getLastFourDigits(currentGroup[0]?.memberNumber)}
                      </p>
                    </div>
                    <p className="text-lg sm:text-xl font-bold">${ballPrice.toFixed(2)}</p>
                  </div>
                </label>
                
                {currentGroup.filter(p => !p.isGuest).length > 1 && (
                  <label 
                    className={`block p-3 sm:p-4 rounded-xl border-2 cursor-pointer transition-all ${
                      ballPurchaseOption === 'split' 
                        ? 'border-green-500 bg-green-50' 
                        : 'border-gray-200 hover:border-gray-300'
                    }`}
                  >
                    <input
                      type="radio"
                      name="ballOption"
                      value="split"
                      checked={ballPurchaseOption === 'split'}
                      onChange={(e) => setBallPurchaseOption(e.target.value)}
                      className="sr-only"
                    />
                    <div className="flex justify-between items-center">
                      <div>
                        <p className="font-medium text-sm sm:text-base">Split the balls</p>
                        <p className="text-xs sm:text-sm text-gray-600">
                          ${splitPrice.toFixed(2)} per player ({currentGroup.filter(p => !p.isGuest).length} players)
                        </p>
                      </div>
                      <p className="text-lg sm:text-xl font-bold">${splitPrice.toFixed(2)} each</p>
                    </div>
                  </label>
                )}
              </div>
              
              <div className="flex gap-2 sm:gap-3">
                <button
                  onClick={handleBallPurchase}
                  disabled={!ballPurchaseOption}
                  className={`flex-1 py-2.5 sm:py-3 px-4 sm:px-6 rounded-full font-medium transition-colors text-sm sm:text-base ${
                    ballPurchaseOption 
                      ? 'bg-blue-500 text-white hover:bg-blue-600' 
                      : 'bg-blue-200 text-blue-400 cursor-not-allowed'
                  }`}
                >
                  Confirm Purchase
                </button>
                <button
                  onClick={() => {
                    setShowBallPurchaseModal(false);
                    setBallPurchaseOption('');
                  }}
                  className="flex-1 bg-gray-200 text-gray-700 py-2.5 sm:py-3 px-4 sm:px-6 rounded-full font-medium hover:bg-gray-300 transition-colors text-sm sm:text-base"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    );
  }
  
  // Waitlist success screen
  const waitlistMainContent = (
    <>
      <div className="flex flex-col items-center mb-4 sm:mb-6">
        <div className="w-12 h-12 sm:w-16 sm:h-16 bg-green-500 rounded-full flex items-center justify-center mb-2 sm:mb-3">
          <Check size={32} className="text-white sm:w-10 sm:h-10" />
        </div>
        <h1 className="text-2xl sm:text-3xl font-bold bg-gradient-to-r from-green-600 to-teal-600 bg-clip-text text-transparent text-center">
          You're on the list!
        </h1>
        {mobileCountdown !== null && mobileCountdown > 0 && (
          <p className="text-sm text-gray-500 mt-2">Closing in {mobileCountdown}...</p>
        )}
      </div>
      
      <div className="bg-blue-50 rounded-2xl p-4 sm:p-6 text-center mb-4 sm:mb-6">
        <p className="text-base sm:text-lg text-gray-600 mb-2 sm:mb-3">Your group has been registered</p>
        {position > 2 ? (
          <p className="text-lg sm:text-xl font-semibold text-gray-700 mb-2">
            There are <span className="text-blue-600">{position - 1} groups</span> ahead of you
          </p>
        ) : position === 2 ? (
          <p className="text-lg sm:text-xl font-semibold text-gray-700 mb-2">
            There is <span className="text-blue-600">1 group</span> ahead of you
          </p>
        ) : (
          <p className="text-lg sm:text-xl font-semibold text-gray-700 mb-2">
            You are <span className="text-green-600">next</span> in line!
          </p>
        )}
        
        {estimatedWait > 0 && (
          <p className="text-base sm:text-lg text-gray-600">
            Estimated wait: <span className="text-orange-600 font-bold">{estimatedWait} min</span>
          </p>
        )}
      </div>
      
      <p className="text-sm sm:text-base text-gray-500 text-center">Check the monitor for court updates</p>
    </>
  );

  return (
    <div className="w-full h-full min-h-screen bg-gradient-to-br from-green-50 to-blue-50 flex items-center justify-center p-4">
      <SuccessCard 
        headerContent={headerContent}
        mainContent={waitlistMainContent}
        footerContent={null} // No footer for waitlist - will show empty space
      />
    </div>
  );
};

// Court Selection Screen Component (in real app, import from './components/CourtSelectionScreen')
const CourtSelectionScreen = ({
  availableCourts,
  showingOvertimeCourts,
  hasWaitingGroups,
  waitingGroupsCount,
  onCourtSelect,
  onJoinWaitlist,
  onGoBack,
  onStartOver
}) => {
  return (
    <div className="w-full h-full min-h-screen bg-gradient-to-br from-green-50 to-blue-50 p-4 sm:p-8 flex items-center justify-center">
      <div className="bg-white rounded-2xl shadow-2xl p-4 sm:p-8 w-full max-w-4xl relative">
        <h2 className="text-2xl sm:text-3xl font-bold text-center mb-6 sm:mb-8">
          {availableCourts.length > 0 ? "Select Your Court" : "Join Waitlist"}
        </h2>
        
        {showingOvertimeCourts && (
          <p className="text-center text-gray-600 mb-4 text-sm sm:text-base">
            All courts are occupied. You may claim an overtime court.
          </p>
        )}

        {availableCourts.length > 0 ? (
          <>
            <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 sm:gap-6 mb-16 sm:mb-20">
              {availableCourts.map(courtNum => (
                <button
                  key={courtNum}
                  onClick={() => onCourtSelect(courtNum)}
                  className={`p-6 sm:p-8 rounded-xl text-xl sm:text-2xl font-bold text-white transition-all transform hover:scale-105 shadow-lg ${
                    showingOvertimeCourts 
                      ? "bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800" 
                      : "bg-gradient-to-r from-green-400 to-green-500 hover:from-green-500 hover:to-green-600"
                  }`}
                >
                  Court {courtNum}
                </button>
              ))}
            </div>
          </>
        ) : (
          <div className="text-center mb-16 sm:mb-20">
            {hasWaitingGroups ? (
              <>
                <p className="text-lg sm:text-xl text-gray-600 mb-4">Courts will be available when it's your turn</p>
                <p className="text-base sm:text-lg text-gray-500 mb-6">There are {waitingGroupsCount} groups ahead of you</p>
              </>
            ) : (
              <p className="text-lg sm:text-xl text-gray-600 mb-6">No courts are currently available</p>
            )}
            <button
              onClick={onJoinWaitlist}
              className="bg-blue-500 text-white py-4 sm:py-6 px-8 sm:px-12 rounded-xl text-xl sm:text-2xl font-bold hover:bg-blue-600 transition-colors"
            >
              Join Waitlist
            </button>
          </div>
        )}



        <div className="absolute bottom-4 sm:bottom-8 left-4 sm:left-8 right-4 sm:right-8 flex justify-between">
          <button
            onClick={onGoBack}
            className="bg-gray-300 text-gray-700 py-2 sm:py-3 px-4 sm:px-6 rounded-xl text-base sm:text-lg hover:bg-gray-400 transition-colors"
          >
            Go Back
          </button>
          
          <button
            onClick={onStartOver}
            className="bg-red-500 text-white py-2 sm:py-3 px-4 sm:px-6 rounded-xl text-base sm:text-lg hover:bg-red-600 transition-colors"
          >
            Start Over
          </button>
        </div>
      </div>
    </div>
  );
};

// Custom hook for debouncing (defined outside component)
const useDebounce = (value, delay) => {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
};

// Unified Court Block Status Function
const getCourtBlockStatus = (courtNumber) => {
  const now = new Date();

// Use the TennisDataService function to get relevant blocks
const activeBlocks = TennisDataService.getActiveBlocksForCourt(courtNumber, now);
  
  if (activeBlocks.length > 0) {
    const currentBlock = activeBlocks[0]; // Blocks are sorted by start time
    const blockStartTime = new Date(currentBlock.startTime);
    const blockEndTime = new Date(currentBlock.endTime);

    const isCurrent = now >= blockStartTime && now < blockEndTime;

    return {
      isBlocked: true,
      isCurrent: isCurrent,
      reason: currentBlock.reason,
      startTime: currentBlock.startTime,
      endTime: currentBlock.endTime,
      remainingMinutes: isCurrent ? Math.ceil((blockEndTime - now) / (1000 * 60)) : 0
    };
  }

  return {
    isBlocked: false,
    isCurrent: false
  };
};

const TennisRegistration = () => {
  // Initialize data state
  const [data, setData] = useState(() => ({
    courts: Array(TENNIS_CONFIG.COURTS.TOTAL_COUNT).fill(null),
    waitingGroups: [],
    recentlyCleared: []
  }));
  
  // Define loadData function to refresh data
  const loadData = async () => {
    const updatedData = await TennisDataService.loadData();
    setData(updatedData);
  };
  window.loadData = loadData; // expose for coalescer/tests
  
  // Expose setData globally for scheduleAvailabilityRefresh
  useEffect(() => {
    window.__setRegistrationData = setData;
    return () => {
      window.__setRegistrationData = null;
    };
  }, []);

  // Load initial data
  useEffect(() => {
    loadData();
  }, []);

  // Real-time synchronization with other apps
  useEffect(() => {
    // Debounced handlers to prevent rapid bouncing
    let updateTimeout = null;
    
    const handleStorageUpdate = async (event) => {
      if (event.detail && event.detail.key === TENNIS_CONFIG.STORAGE.KEY) {
        // Don't trigger updates if we're in the middle of a screen transition
        if (currentScreen === "search" || currentScreen === "group") {
          console.log('Skipping storage update during screen transition');
          return;
        }
        
        // Clear any pending update and debounce
        clearTimeout(updateTimeout);
        updateTimeout = setTimeout(async () => {
          const updatedData = await TennisDataService.loadData();
          setData(updatedData);
          dbg('Data synchronized from external update');
        }, 500); // Increased debounce delay
      }
    };

    const handleStorageEvent = async (event) => {
      // Handle storage events from localStorage changes
      if (event.key === TENNIS_CONFIG.STORAGE.KEY && event.newValue) {
        // Don't trigger updates if we're in the middle of a screen transition
        if (currentScreen === "search" || currentScreen === "group") {
          dbg('Skipping localStorage update during screen transition');
          return;
        }
        
        // Clear any pending update and debounce
        clearTimeout(updateTimeout);
        updateTimeout = setTimeout(async () => {
          const updatedData = await TennisDataService.loadData();
          setData(updatedData);
          console.log('Data synchronized from localStorage change');
        }, 500); // Increased debounce delay
      }
    };

    // Listen for custom events from DataStore
    window.addEventListener(EVENTS.UPDATE, scheduleAvailabilityRefresh);
    window.addEventListener('DATA_UPDATED', scheduleAvailabilityRefresh);
    
    // Listen for storage events from other windows/tabs
    window.addEventListener('storage', handleStorageEvent);

    // Refresh clear screen on updates
    const refreshClearScreen = () => {
      if (currentScreen === "clearCourt") {
        // Force re-render by updating state
        setCurrentScreen("clearCourt");
      }
    };
    document.addEventListener('tennisDataUpdate', refreshClearScreen);
    document.addEventListener('DATA_UPDATED', refreshClearScreen);

    return () => {
      clearTimeout(updateTimeout);
      window.removeEventListener(EVENTS.UPDATE, scheduleAvailabilityRefresh);
      window.removeEventListener('DATA_UPDATED', scheduleAvailabilityRefresh);
      window.removeEventListener('storage', handleStorageEvent);
      document.removeEventListener('tennisDataUpdate', refreshClearScreen);
      document.removeEventListener('DATA_UPDATED', refreshClearScreen);
    };
  }, []);

  // CSS Performance Optimizations
  useEffect(() => {
    const style = document.createElement('style');
    style.textContent = `
      /* Force GPU acceleration and optimize animations */
      .animate-pulse {
        will-change: opacity;
        transform: translateZ(0);
        backface-visibility: hidden;
      }
      
      .animate-spin {
        will-change: transform;
        transform: translateZ(0);
        backface-visibility: hidden;
      }
      
      /* Optimize transform animations */
      .transform {
        transition: transform 200ms ease-out;
        will-change: transform;
      }
      
      /* Replace transition-all with specific properties */
      .transition-all {
        transition: none !important;
      }
      
      /* Specific transitions for court displays */
      .court-transition {
        transition: background-color 200ms ease-out, 
                    border-color 200ms ease-out,
                    box-shadow 200ms ease-out;
      }
      
      /* Button optimizations */
      .button-transition {
        transition: background-color 150ms ease-out, 
                    transform 150ms ease-out;
        transform: translateZ(0);
      }
      
      .button-transition:hover {
        will-change: transform;
      }
      
      /* Optimize backdrop blur (expensive operation) */
      .backdrop-blur {
        transform: translateZ(0);
        will-change: backdrop-filter;
      }
      
      /* Reduce animation overhead for multiple pulsing elements */
      @media (prefers-reduced-motion: reduce) {
        .animate-pulse {
          animation: none;
          opacity: 1;
        }
      }
    `;
    
    document.head.appendChild(style);
    
    return () => {
      document.head.removeChild(style);
    };
  }, []);

  // Calculate available courts and waiting group display
  useEffect(() => {
    const updateAvailableCourts = () => {
      try {
        if (DEBUG) {
          console.log("useEffect: Updating available courts...");
        }
        
        // Check if we should bypass waitlist priority for overtime courts
        const data = getCourtData();
        const tempAvailableCourts = getAvailableCourts(false); // Get courts without waitlist check
        const hasUnoccupiedCourts = data.courts.some((court, index) => {
          const courtNumber = index + 1;
          const blockStatus = getCourtBlockStatus(courtNumber);
          if (blockStatus && blockStatus.isCurrent) return false;
          
          return !court || court.wasCleared || (court.current === null && court.history) ||
                 ((!court.players || court.players.length === 0) && 
                  (!court.current || !court.current.players || court.current.players.length === 0));
        });
        
        // If there are available courts but no unoccupied courts, these must be overtime courts
        const shouldBypassWaitlistPriority = tempAvailableCourts.length > 0 && !hasUnoccupiedCourts;
        
        if (DEBUG) {
          console.log("🔍 useEffect DEBUG:");
          console.log("  - tempAvailableCourts:", tempAvailableCourts);
          console.log("  - hasUnoccupiedCourts:", hasUnoccupiedCourts);
          console.log("  - shouldBypassWaitlistPriority:", shouldBypassWaitlistPriority);
          console.log("  - waitlist length:", data.waitingGroups.length);
        }
        
        // Use the fixed synchronous getAvailableCourts function with appropriate priority setting
        const courts = getAvailableCourts(!shouldBypassWaitlistPriority);
        if (DEBUG) {
          console.log("useEffect: Available courts from getAvailableCourts:", courts);
          console.log("useEffect: Bypassing waitlist priority?", shouldBypassWaitlistPriority);
        }
        setAvailableCourts(courts);
        
        // Check if there's a waiting group that can now play  
        // Note: data is already loaded above
        const firstWaitingGroupData = data.waitingGroups.length > 0 ? data.waitingGroups[0] : null;
        // Use tempAvailableCourts (without waitlist check) to determine if first group can play
        const canPlay = firstWaitingGroupData && tempAvailableCourts.length > 0;
        setCanFirstGroupPlay(canPlay);
        setFirstWaitingGroup(firstWaitingGroupData);
        
        // Create display names for the waiting group
        if (canPlay) {
          const names = firstWaitingGroupData.players.map(p => p.name.split(' ').pop());
          if (names.length <= 3) {
            setWaitingGroupDisplay(names.join(", "));
          } else {
            setWaitingGroupDisplay(`${names.slice(0, 3).join(", ")}, etc`);
          }
        } else {
          setWaitingGroupDisplay("");
        }
      } catch (error) {
        console.error('Error updating available courts:', error);
        setAvailableCourts([]);
        setCanFirstGroupPlay(false);
        setFirstWaitingGroup(null);
        setWaitingGroupDisplay("");
      }
    };
    
    updateAvailableCourts();
  }, [data, currentScreen]); // Re-run when data or screen changes

// Auto-clear expired courts function
useEffect(() => {
  // function autoClearExpiredCourts() { /* disabled per policy */ }
  const autoClearExpiredCourts = async () => {
    /* disabled per policy - players remain on-court until manual clear or bump */
  };
  
  // Run immediately on mount
  // autoClearExpiredCourts(); /* disabled per policy */
  
  // Then run every 30 seconds
  // const interval = setInterval(autoClearExpiredCourts, 30000); /* disabled per policy */
  
  // return () => clearInterval(interval); /* disabled per policy */
}, []); // Empty dependency array so it only sets up once


// Historical Data Protection System
// This backs up court game data for analytics and reporting purposes in Admin.html
// It does NOT restore data automatically - it only saves historical records
useEffect(() => {
  const protectCourtHistory = async () => {
    const data = await TennisDataService.loadData();
    const now = new Date();
    
    // Create backup of all court history
    for (let index = 0; index < data.courts.length; index++) {
      const court = data.courts[index];
      if (court && ((court.current && court.current.players) || (court.players))) {
        const courtNumber = index + 1;
        const backupKey = `courtHistory_${courtNumber}`;
        
        // Get existing backup
        let courtBackup = await dataStore.get(backupKey) || [];
        
        // Get current game data
        const players = court.current?.players || court.players;
        const startTime = court.current?.startTime || court.startTime;
        const endTime = court.current?.endTime || court.endTime;
        
        if (players && players.length > 0 && startTime) {
          // Check if this game is already backed up
          const gameId = `${startTime}_${players.map(p => p.id).join('_')}`;
          const alreadyBacked = courtBackup.some(backup => backup.gameId === gameId);
          
          if (!alreadyBacked) {
            // Add to backup
            courtBackup.push({
              gameId: gameId,
              players: players,
              startTime: startTime,
              endTime: endTime,
              backedUpAt: now.toISOString(),
              courtNumber: courtNumber
            });
            
            // Save backup
            await dataStore.set(backupKey, courtBackup, { immediate: true });
            console.log(`Backed up game history for court ${courtNumber}`);
          }
        }
      }
    }
  };
  
  // Run backup every 10 seconds
  // DISABLED: protectCourtHistory is redundant now that StorageGuard prevents clobbering
  // protectCourtHistory();
  // const backupInterval = setInterval(protectCourtHistory, 10000);
  
  // return () => clearInterval(backupInterval);
}, []);

// REMOVED: Historical Data Restoration System
// This was causing issues where cleared data would be automatically restored every 15 seconds.
// We keep the Historical Data Protection System above for analytics purposes,
// but we don't want to automatically restore cleared courts.

// Auto-cleanup expired blocks weekly
useEffect(() => {
  const runBlockCleanup = () => {
    const removed = TennisDataService.cleanupExpiredBlocks();
    if (removed > 0) {
      console.log(`🧹 Weekly cleanup removed ${removed} expired blocks at ${new Date().toLocaleDateString()}`);
    }
  };
  
  // Run cleanup on app startup
  runBlockCleanup();
  
  // Run cleanup once a week (every 7 days)
  const interval = setInterval(runBlockCleanup, 7 * 24 * 60 * 60 * 1000); // 7 days
  
  return () => clearInterval(interval);
}, []); 

  // Constants
  const CONSTANTS = {
    ADMIN_CODE: TENNIS_CONFIG.ADMIN.ACCESS_CODE,
    MAX_PLAYERS: TENNIS_CONFIG.PLAYERS.MAX_PER_GROUP,
    MAX_PLAY_DURATION_MS: TENNIS_CONFIG.TIMING.MAX_PLAY_DURATION_MS,
    MAX_PLAY_DURATION_MIN: TENNIS_CONFIG.TIMING.MAX_PLAY_DURATION_MIN,
    TIMEOUT_WARNING_MIN: TENNIS_CONFIG.TIMING.TIMEOUT_WARNING_MIN,
    SESSION_TIMEOUT_MS: TENNIS_CONFIG.TIMING.SESSION_TIMEOUT_MS,
    SESSION_WARNING_MS: TENNIS_CONFIG.TIMING.SESSION_WARNING_MS,
    COURT_COUNT: TENNIS_CONFIG.COURTS.TOTAL_COUNT,
    CHANGE_COURT_TIMEOUT_SEC: TENNIS_CONFIG.TIMING.CHANGE_COURT_TIMEOUT_SEC,
    AUTO_RESET_SUCCESS_MS: TENNIS_CONFIG.TIMING.AUTO_RESET_SUCCESS_MS,
    ALERT_DISPLAY_MS: TENNIS_CONFIG.TIMING.ALERT_DISPLAY_MS,
    AUTO_RESET_CLEAR_MS: TENNIS_CONFIG.TIMING.AUTO_RESET_CLEAR_MS,
    DURATIONS: {
      SINGLES_MIN: TENNIS_CONFIG.TIMING.SINGLES_DURATION_MIN,
      DOUBLES_MIN: TENNIS_CONFIG.TIMING.DOUBLES_DURATION_MIN
    },
    MEMBER_COUNT: 40,
    MEMBER_ID_START: 1000,
    MAX_AUTOCOMPLETE_RESULTS: TENNIS_CONFIG.DISPLAY.MAX_AUTOCOMPLETE_RESULTS,
    MAX_FREQUENT_PARTNERS: TENNIS_CONFIG.DISPLAY.MAX_FREQUENT_PARTNERS,
    MAX_WAITING_DISPLAY: TENNIS_CONFIG.DISPLAY.MAX_WAITING_DISPLAY,
    AVG_GAME_TIME_MIN: TENNIS_CONFIG.TIMING.AVG_GAME_TIME_MIN,
    POLL_INTERVAL_MS: TENNIS_CONFIG.TIMING.POLL_INTERVAL_MS,
    UPDATE_INTERVAL_MS: TENNIS_CONFIG.TIMING.UPDATE_INTERVAL_MS
  };

  const [currentGroup, setCurrentGroup] = useState([]);
  const [memberNumber, setMemberNumber] = useState("");
  const [showAlert, setShowAlert] = useState(false);
  const [alertMessage, setAlertMessage] = useState("");
  const [availableCourts, setAvailableCourts] = useState([]);
  const [canFirstGroupPlay, setCanFirstGroupPlay] = useState(false);
  const [firstWaitingGroup, setFirstWaitingGroup] = useState(null);
  const [waitingGroupDisplay, setWaitingGroupDisplay] = useState("");
  const [showSuccess, setShowSuccess] = useState(false);
  const [mobileCountdown, setMobileCountdown] = useState(5);
  const [justAssignedCourt, setJustAssignedCourt] = useState(null);
  const [replacedGroup, setReplacedGroup] = useState(null);
  const [originalCourtData, setOriginalCourtData] = useState(null);
  const [canChangeCourt, setCanChangeCourt] = useState(false);
  const [changeTimeRemaining, setChangeTimeRemaining] = useState(CONSTANTS.CHANGE_COURT_TIMEOUT_SEC);
  const [currentScreen, setCurrentScreen] = useState("welcome");
  const [searchInput, setSearchInput] = useState("");
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [showAddPlayer, setShowAddPlayer] = useState(false);
  const [addPlayerSearch, setAddPlayerSearch] = useState("");
  const [showAddPlayerSuggestions, setShowAddPlayerSuggestions] = useState(false);

  const [selectedCourtToClear, setSelectedCourtToClear] = useState(null);
  const [clearCourtStep, setClearCourtStep] = useState(1);
  const [isChangingCourt, setIsChangingCourt] = useState(false);
  const [wasOvertimeCourt, setWasOvertimeCourt] = useState(false);
  const [lastActivity, setLastActivity] = useState(Date.now());
  const [showTimeoutWarning, setShowTimeoutWarning] = useState(false);
  const [hasWaitlistPriority, setHasWaitlistPriority] = useState(false);
  const timeoutTimerRef = useRef(null);
  const warningTimerRef = useRef(null);
  const frequentPartnersCacheRef = useRef({});
  const [currentTime, setCurrentTime] = useState(new Date());
  const [courtToMove, setCourtToMove] = useState(null);
  const [moveToCourtNum, setMoveToCourtNum] = useState(null);
  const [hasAssignedCourt, setHasAssignedCourt] = useState(false);

  const [waitlistMoveFrom, setWaitlistMoveFrom] = useState(null);
  const [showGuestForm, setShowGuestForm] = useState(false);
  const [guestName, setGuestName] = useState("");
  const [guestSponsor, setGuestSponsor] = useState("");
  const [guestCounter, setGuestCounter] = useState(1);
  const [showGuestNameError, setShowGuestNameError] = useState(false);
  const [showSponsorError, setShowSponsorError] = useState(false);
  const [showBlockModal, setShowBlockModal] = useState(false);
  const [blockingInProgress, setBlockingInProgress] = useState(false);
  const [selectedCourtsToBlock, setSelectedCourtsToBlock] = useState([]);
  const [blockMessage, setBlockMessage] = useState("");
  const [blockStartTime, setBlockStartTime] = useState("now");
  const [blockEndTime, setBlockEndTime] = useState("");
  const [isSearching, setIsSearching] = useState(false); // Add searching state
  
  // Admin panel state - moved to top level
  const [ballPriceInput, setBallPriceInput] = useState('');
  const [showPriceSuccess, setShowPriceSuccess] = useState(false);
  const [priceError, setPriceError] = useState('');
  const [checkingLocation, setCheckingLocation] = useState(false);
  const [isUserTyping, setIsUserTyping] = useState(false);
  const typingTimeoutRef = useRef(null);

  // Debouncing hooks - MUST be at top level
  const debouncedSearchInput = useDebounce(searchInput, 300);
  const debouncedAddPlayerSearch = useDebounce(addPlayerSearch, 300);
  
  // Determine which search value to use based on input type
  const shouldDebounceMainSearch = !/^\d+$/.test(searchInput);
  const effectiveSearchInput = shouldDebounceMainSearch ? debouncedSearchInput : searchInput;
  
  const shouldDebounceAddPlayer = !/^\d+$/.test(addPlayerSearch);
  const effectiveAddPlayerSearch = shouldDebounceAddPlayer ? debouncedAddPlayerSearch : addPlayerSearch;

// Helper function to get occupied courts from domain status
function computeOccupiedCourts() {
  const A = window.Tennis?.Domain?.availability || window.Tennis?.Domain?.Availability;
  const S = window.Tennis?.Storage;
  const now = new Date();
  const data = S.readDataSafe();
  const blocks = S.readJSON(S.STORAGE?.BLOCKS) || [];
  const wetSet = new Set(
    (blocks||[])
      .filter(b => b?.isWetCourt && new Date(b.startTime ?? b.start) <= now && now < new Date(b.endTime ?? b.end))
      .map(b => b.courtNumber)
  );
  const statuses = A.getCourtStatuses({ data, now, blocks, wetSet });
  // Only true in-use courts
  const occupied = statuses.filter(s => s.status === 'occupied').map(s => s.courtNumber);
  return { occupied, data };
}

// Helper function to get courts that can be cleared (occupied or overtime)
function getCourtsOccupiedForClearing() {
  const Av  = Tennis.Domain.availability || Tennis.Domain.Availability;
  const now = new Date();
  const S   = Tennis.Storage;
  const data   = S.readDataSafe();
  const blocks = S.readJSON(S.STORAGE.BLOCKS) || [];
  const wetSet = new Set(
    blocks
      .filter(b => b?.isWetCourt && new Date(b.startTime ?? b.start) <= now && now < new Date(b.endTime ?? b.end))
      .map(b => b.courtNumber)
  );

  const statuses = Av.getCourtStatuses({ data, now, blocks, wetSet });
  const clearableCourts = statuses
    .filter(s => s.isOccupied || s.isOvertime)   // include BOTH occupied + overtime
    .map(s => s.courtNumber)
    .sort((a, b) => a - b);
  return clearableCourts;
}

// Helper function to mark user as typing
const markUserTyping = () => {
  setIsUserTyping(true);
  clearTimeout(typingTimeoutRef.current);
  typingTimeoutRef.current = setTimeout(() => {
    setIsUserTyping(false);
  }, 3000);
};

  // Wrapper function to check location before proceeding
const checkLocationAndProceed = async (onSuccess) => {
    // Skip location check if disabled
    if (!TENNIS_CONFIG.GEOLOCATION.ENABLED) {
      console.log('⚠️ Geolocation check disabled for development');
      onSuccess();
      return;
    }
    
    setCheckingLocation(true);
    
    try {
      const locationResult = await GeolocationService.verifyAtClub();
      
      if (locationResult.success) {
        // Location verified, proceed with action
        onSuccess();
      } else {
        // Not at club
        showAlertMessage(locationResult.message);
      }
    } catch (error) {
      // Location check failed (timeout, permission denied, etc.)
      console.error('Location check failed:', error);
      showAlertMessage(TENNIS_CONFIG.GEOLOCATION.ERROR_MESSAGE);
    } finally {
      setCheckingLocation(false);
    }
  };

  // Track when main search is in progress
  useEffect(() => {
    if (shouldDebounceMainSearch && searchInput !== debouncedSearchInput && searchInput.length > 0) {
      setIsSearching(true);
    } else {
      setIsSearching(false);
    }
  }, [searchInput, debouncedSearchInput, shouldDebounceMainSearch]);

  // Load current ball price when entering admin screen
  useEffect(() => {
    const loadAdminSettings = async () => {
      if (currentScreen === "admin") {
        try {
          const settings = await dataStore.get(TENNIS_CONFIG.STORAGE.SETTINGS_KEY);
          if (settings) {
            const parsed = settings || {};
            setBallPriceInput((parsed.tennisBallPrice || TENNIS_CONFIG.PRICING.TENNIS_BALLS).toFixed(2));
          } else {
            setBallPriceInput(TENNIS_CONFIG.PRICING.TENNIS_BALLS.toFixed(2));
          }
        } catch (error) {
          setBallPriceInput(TENNIS_CONFIG.PRICING.TENNIS_BALLS.toFixed(2));
        }
      }
    };
    loadAdminSettings();
  }, [currentScreen]);

  // Simplified member database
  const memberDatabase = {};
  for (let i = 1; i <= CONSTANTS.MEMBER_COUNT; i++) {
    const id = CONSTANTS.MEMBER_ID_START + i;
    const names = [
      "Novak Djokovic", "Carlos Alcaraz", "Jannik Sinner", "Daniil Medvedev", 
      "Alexander Zverev", "Andrey Rublev", "Casper Ruud", "Hubert Hurkacz",
      "Taylor Fritz", "Alex de Minaur", "Iga Swiatek", "Aryna Sabalenka",
      "Coco Gauff", "Elena Rybakina", "Jessica Pegula", "Ons Jabeur",
      "Marketa Vondrousova", "Karolina Muchova", "Beatriz Haddad Maia", "Petra Kvitova",
      "Stefanos Tsitsipas", "Felix Auger-Aliassime", "Cameron Norrie", "Karen Khachanov",
      "Frances Tiafoe", "Tommy Paul", "Lorenzo Musetti", "Ben Shelton",
      "Nicolas Jarry", "Sebastian Korda", "Madison Keys", "Victoria Azarenka",
      "Daria Kasatkina", "Belinda Bencic", "Caroline Garcia", "Simona Halep",
      "Elina Svitolina", "Maria Sakkari", "Liudmila Samsonova", "Zheng Qinwen"
    ];
    
    memberDatabase[id.toString()] = {
      familyMembers: [{
        id: id,
        name: names[i - 1] || `Player ${i}`,
        phone: `555-${String(i).padStart(4, '0')}`,
        ranking: ((i - 1) % 20) + 1,
        winRate: 0.5 + (Math.random() * 0.4)
      }],
      playingHistory: [],
      lastGame: null
    };
  }

  // Update current time every second for responsive overtime detection
  useEffect(() => {
    const timer = setInterval(() => {
      setCurrentTime(new Date());
    }, 1000);
    return () => clearInterval(timer);
  }, []);

  // Mobile Bridge Integration
  useEffect(() => {
    // Hook up mobile UI helpers
    if (window.RegistrationUI) {
      window.RegistrationUI.setSelectedCourt = (courtNumber) => {
        console.log('Mobile: Setting selected court to', courtNumber);
        // Store the court for assignment but don't navigate yet
        window.__preselectedCourt = courtNumber;
      };
      
      window.RegistrationUI.startRegistration = (courtNumber) => {
        console.log('Mobile: Starting registration for court', courtNumber);
        // Navigate to group step and focus input
        setCurrentScreen('group');
        requestAnimationFrame(() => {
          const input = 
            document.querySelector('#mobile-group-search-input') ||
            document.querySelector('#main-search-input') ||
            document.querySelector('[data-role="player-input"]') ||
            document.querySelector('#playerNameInput') ||
            document.querySelector('input[type="text"]');
          if (input) {
            input.focus({ preventScroll: true });
            try { 
              const v = input.value || ''; 
              input.setSelectionRange(v.length, v.length); 
            } catch {}
          }
        });
      };
    }
  }, []);

  // Expose React state for mobile guards
  useEffect(() => {
    window.__reactState = {
      currentGroup,
      currentScreen,
      showSuccess
    };
  }, [currentGroup, currentScreen, showSuccess]);

  // Mobile: Watch for success state changes and send signal
  useEffect(() => {
    if (showSuccess && window.__mobileFlow && window.top !== window.self) {
      dbg('Registration: Success state changed to true, sending mobile signal');
      const courtNumber = window.__preselectedCourt || justAssignedCourt || null;
      dbg('Registration: Court number for success:', courtNumber);
      try {
        window.parent.postMessage({ type: 'registration:success', courtNumber: courtNumber }, '*');
        dbg('Registration: Direct success message sent');
      } catch(e) {
        if (DEBUG) console.log('Registration: Error in direct success message:', e);
      }
      
      // Start countdown for mobile
      setMobileCountdown(5);
      const countdownInterval = setInterval(() => {
        setMobileCountdown(prev => {
          if (prev <= 1) {
            clearInterval(countdownInterval);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
      
      return () => clearInterval(countdownInterval);
    }
  }, [showSuccess, justAssignedCourt]);

  // Update available courts when current group changes
  useEffect(() => {
    const updateAvailableCourts = () => {
      try {
        // Check if we should bypass waitlist priority for overtime courts
        const data = getCourtData();
        const tempAvailableCourts = getAvailableCourts(false); // Get courts without waitlist check
        const hasUnoccupiedCourts = data.courts.some((court, index) => {
          const courtNumber = index + 1;
          const blockStatus = getCourtBlockStatus(courtNumber);
          if (blockStatus && blockStatus.isCurrent) return false;
          
          return !court || court.wasCleared || (court.current === null && court.history) ||
                 ((!court.players || court.players.length === 0) && 
                  (!court.current || !court.current.players || court.current.players.length === 0));
        });
        
        // If there are available courts but no unoccupied courts, these must be overtime courts
        const shouldBypassWaitlistPriority = tempAvailableCourts.length > 0 && !hasUnoccupiedCourts;
        
        console.log("🔍 useEffect (currentGroup) DEBUG:");
        console.log("  - tempAvailableCourts:", tempAvailableCourts);
        console.log("  - hasUnoccupiedCourts:", hasUnoccupiedCourts);
        console.log("  - shouldBypassWaitlistPriority:", shouldBypassWaitlistPriority);
        console.log("  - waitlist length:", data.waitingGroups.length);
        
        // Use the synchronous getAvailableCourts function with appropriate priority setting
        const courts = getAvailableCourts(!shouldBypassWaitlistPriority);
        console.log("useEffect (currentGroup): Available courts:", courts);
        setAvailableCourts(courts);
      } catch (error) {
        console.error('Error updating available courts:', error);
        setAvailableCourts([]);
      }
    };
    
    if (currentGroup.length > 0) {
      updateAvailableCourts();
    }
  }, [currentGroup]);

  // Wire up event listeners for availability updates (once only)
  useEffect(() => {
    if (!window.__wiredAvailabilityEvents) {
      const refreshAvailability = () => {
        // This is called by both events, reusing the existing updateAvailableCourts logic
        if (currentGroup.length > 0) {
          const updateAvailableCourts = () => {
            try {
              const data = getCourtData();
              const tempAvailableCourts = getAvailableCourts(false);
              const hasUnoccupiedCourts = data.courts.some((court, index) => {
                const courtNumber = index + 1;
                const blockStatus = getCourtBlockStatus(courtNumber);
                if (blockStatus && blockStatus.isCurrent) return false;
                
                return !court || court.wasCleared || (court.current === null && court.history) ||
                  (court.history && court.history.length > 0 && (!court.players || court.players.length === 0));
              });
              
              if (!hasWaitlistPriority || hasUnoccupiedCourts) {
                setAvailableCourts(tempAvailableCourts);
              } else {
                setAvailableCourts([]);
              }
            } catch (error) {
              console.error('Error updating available courts:', error);
              setAvailableCourts([]);
            }
          };
          updateAvailableCourts();
        }
      };
      
      window.addEventListener('tennisDataUpdate', refreshAvailability);
      window.addEventListener('DATA_UPDATED', refreshAvailability);
      window.__wiredAvailabilityEvents = true;
    }
    
    return () => {
      clearTimeout(typingTimeoutRef.current);
    };
  }, [currentGroup, hasWaitlistPriority, getCourtData, getAvailableCourts, getCourtBlockStatus]);

  // Activity tracking for timeout
  const updateActivity = () => {
    setLastActivity(Date.now());
    setShowTimeoutWarning(false);
    
    // Clear and restart timers when there's activity
    if (timeoutTimerRef.current) clearTimeout(timeoutTimerRef.current);
    if (warningTimerRef.current) clearTimeout(warningTimerRef.current);
    
    if (currentScreen === "group") {
      // Set warning timer
      warningTimerRef.current = setTimeout(() => {
        setShowTimeoutWarning(true);
      }, CONSTANTS.SESSION_WARNING_MS);

      // Set timeout timer
      timeoutTimerRef.current = setTimeout(() => {
        showAlertMessage("Session timed out due to inactivity");
        // Reset all form state
        setCurrentGroup([]);
        setShowSuccess(false);
        setMemberNumber("");
        setJustAssignedCourt(null);
        setReplacedGroup(null);
        setOriginalCourtData(null);
        setCanChangeCourt(false);
        setCurrentScreen("welcome");
        setSearchInput("");
        setShowSuggestions(false);
        setShowAddPlayer(false);
        setAddPlayerSearch("");
        setShowAddPlayerSuggestions(false);
        setHasWaitlistPriority(false);
        setSelectedCourtToClear(null);
        setClearCourtStep(1);
        setIsChangingCourt(false);
        setWasOvertimeCourt(false);
      }, CONSTANTS.SESSION_TIMEOUT_MS);
    }
  };

  // Setup timeout for group management screen
  useEffect(() => {
    if (currentScreen === "group") {
      // Initial setup of timers when entering group screen
      updateActivity();

      // Add activity listeners
      const handleActivity = () => updateActivity();
      window.addEventListener('click', handleActivity);
      window.addEventListener('touchstart', handleActivity);
      window.addEventListener('keypress', handleActivity);

      return () => {
        // Cleanup
        if (timeoutTimerRef.current) clearTimeout(timeoutTimerRef.current);
        if (warningTimerRef.current) clearTimeout(warningTimerRef.current);
        window.removeEventListener('click', handleActivity);
        window.removeEventListener('touchstart', handleActivity);
        window.removeEventListener('keypress', handleActivity);
      };
    } else {
      // Clear timers when leaving group screen
      if (timeoutTimerRef.current) clearTimeout(timeoutTimerRef.current);
      if (warningTimerRef.current) clearTimeout(warningTimerRef.current);
    }
  }, [currentScreen]); // Only depend on currentScreen, not lastActivity

  // Show alert message helper
  const showAlertMessage = (message) => {
    setAlertMessage(message);
    setShowAlert(true);
    setTimeout(() => setShowAlert(false), CONSTANTS.ALERT_DISPLAY_MS);
  };

  // Get court data using the data service (synchronous for React renders)
  const getCourtData = () => {
    // For synchronous usage, use cached data from state
    return data;
    
    // Check for auto-timeout courts and expired blocks
    const maxDuration = CONSTANTS.MAX_PLAY_DURATION_MS;
    const now = new Date().getTime();
    let hasChanges = false;
    
    data.courts = data.courts.map((court, index) => {
      if (court) {
        // Skip already cleared courts
        if (court.wasCleared) {
          return court;
        }
        
   // Check if court is currently blocked using new system
const blockStatus = getCourtBlockStatus(index + 1);
const isCurrentlyBlocked = blockStatus && blockStatus.isCurrent;

// Get start time from either structure (new or old)
const startTime = court.current?.startTime || court.startTime;

// Check for overtime courts (only if not blocked and has start time)
if (startTime && !isCurrentlyBlocked) {
  const startTimeMs = new Date(startTime).getTime();
  const timePlayed = now - startTimeMs;
  
  if (timePlayed > maxDuration) {
    // Auto-clear this court using the same logic as manual clear
    console.log(`Auto-clearing court ${index + 1} after ${CONSTANTS.MAX_PLAY_DURATION_MIN / 60} hours`);
    hasChanges = true;
    
    // Handle both structures when clearing
    if (court.current) {
      // New structure - preserve history
      court.current = null;
      if (!court.history) court.history = [];
      // Could add to history here if needed
    } else {
      // Old structure - mark as cleared
      court.endTime = new Date().toISOString();
      court.wasCleared = true;
    }
    
    return court;
  }
}
      }
      return court;
    });
    
    // Clean up expired recentlyCleared sessions
    if (data.recentlyCleared && data.recentlyCleared.length > 0) {
      const originalLength = data.recentlyCleared.length;
      data.recentlyCleared = data.recentlyCleared.filter(session => {
        return new Date(session.originalEndTime).getTime() >= now;
      });
      
      if (data.recentlyCleared.length !== originalLength) {
        hasChanges = true;
        console.log(`Cleaned up ${originalLength - data.recentlyCleared.length} expired sessions from recentlyCleared`);
      }
    }
    
    // Save changes if any courts were auto-cleared or sessions expired
    if (hasChanges) {
      TennisDataService.saveData(data);
    }
    
    return data;
  };

  // Save court data using the data service
  const saveCourtData = async (data) => {
    const result = await TennisDataService.saveData(data);
    
    if (!result.success) {
      showAlertMessage(result.error || 'Failed to save data');
    }
    
    return result.success;
  };

  // Check if player is next in waitlist
  const isPlayerNextInWaitlist = (playerId) => {
    const data = getCourtData();
    if (data.waitingGroups.length > 0) {
      const firstGroup = data.waitingGroups[0];
      return firstGroup.players.some(player => player.id === playerId);
    }
    return false;
  };

// Get available courts (modified to check waitlist priority)
const getAvailableCourts = (checkWaitlistPriority = true, includeOvertimeIfChanging = false, excludeCourtNumber = null) => {
  let selectable = [];
  if (USE_DOMAIN_SELECTABLE && A && A.getSelectableCourts) {
    try {
      const now    = new Date();
      const data   = Storage.readDataSafe();
      const blocks = Storage.readJSON(Storage.STORAGE.BLOCKS) || [];
      const wetSet = new Set(
        blocks
          .filter(b => b?.isWetCourt && new Date(b.startTime ?? b.start) <= now && now < new Date(b.endTime ?? b.end))
          .map(b => b.courtNumber)
      );
      selectable = A.getSelectableCourts({ data, now, blocks, wetSet }) || [];
    } catch (error) {
      console.error('Error using domain getSelectableCourts:', error);
      // Fall through to legacy logic
    }
  }
  
  if (selectable.length === 0) {
    // fallback to existing legacy computation (leave your current code/path here)
    const data = getCourtData();
    const unoccupiedCourts = [];
    const overtimeCourts = [];
    const currentTime = new Date(); // Fix: Define currentTime locally

    console.log("getAvailableCourts called with:", { checkWaitlistPriority, includeOvertimeIfChanging, excludeCourtNumber });
    console.log("Court data:", data.courts.length, "courts");
    
    data.courts.forEach((court, index) => {
      const courtNumber = index + 1;

      console.log(`Checking court ${courtNumber}:`, court);

      // Check if this court is currently blocked using new system
      const blockStatus = getCourtBlockStatus(courtNumber);
      if (blockStatus && blockStatus.isCurrent) {
        console.log(`Court ${courtNumber} is blocked:`, blockStatus);
        return; // Skip this court - it's blocked
      }
      
      // Skip the court we're potentially moving from
      if (excludeCourtNumber && courtNumber === excludeCourtNumber) {
        // Treat this court as empty for availability calculation
        unoccupiedCourts.push(courtNumber);
        return;
      }
      
      // Now check normal availability
      if (!court) {
        // No court data at all - it's available
        unoccupiedCourts.push(courtNumber);
      } else if (court.wasCleared) {
        // Court was cleared - it's available
        unoccupiedCourts.push(courtNumber);
      } else if ((!court.players || court.players.length === 0) && (!court.current || !court.current.players || court.current.players.length === 0)) {
        // Both old and new structure have no players - it's available
        unoccupiedCourts.push(courtNumber);
      } else {
        // Check if court is occupied (either structure)
        const isOccupied = (court.players && court.players.length > 0) || (court.current && court.current.players && court.current.players.length > 0);
        
        if (isOccupied) {
          // Check for overtime
          const endTime = court.endTime || court.current?.endTime;
          if (endTime && new Date(endTime) <= currentTime) {
            overtimeCourts.push(courtNumber);
          }
        } else {
          // This shouldn't happen, but just in case
          unoccupiedCourts.push(courtNumber);
        }
      }
    });
    
    console.log("Available courts result:", { unoccupiedCourts, overtimeCourts });
    
    // When changing courts and originally selected an overtime court, show all available options
    if (includeOvertimeIfChanging) {
      selectable = [...unoccupiedCourts, ...overtimeCourts];
    } else {
      // Priority: show unoccupied courts first, overtime courts only if no unoccupied
      // This ensures overtime courts are available when all courts are occupied (by games or blocks)
      const available = unoccupiedCourts.length > 0 ? unoccupiedCourts : overtimeCourts;
      
      // If checking waitlist priority and there are available courts
      if (checkWaitlistPriority && available.length > 0 && data.waitingGroups.length > 0) {
        // Check if current group has waitlist priority
        if (!hasWaitlistPriority) {
          // Check if any player in current group is in the top N waiting groups
          // where N is the number of available courts
          const topNGroups = data.waitingGroups.slice(0, Math.min(available.length, 2)); // Cap at 2 groups max
          const isInTopN = currentGroup.some(player => 
            topNGroups.some(waitingGroup => 
              waitingGroup.players.some(waitingPlayer => waitingPlayer.id === player.id)
            )
          );
          
          if (!isInTopN) {
            // Not in top N groups, but if these are overtime courts and there are no unoccupied courts,
            // we should still allow access (better UX when all courts are full)
            if (overtimeCourts.length > 0 && unoccupiedCourts.length === 0) {
              selectable = available; // Return overtime courts even without priority
            } else {
              selectable = []; // Otherwise, no courts available
            }
          } else {
            selectable = available;
          }
        } else {
          selectable = available;
        }
      } else {
        selectable = available;
      }
    }
  }

  // Feed `selectable` into the existing UI rendering for the picker/modal
  // (Do not change how items are displayed/selected—just the source array.)
  
  dbg("Final available courts:", selectable);
  return selectable;
};
  

// ✅ NEW WRAPPER FUNCTION
const tryAssignCourtToGroup = () => {
  const groupId = currentGroup.map(p => p.id).sort().join("-");
  const data = TennisDataService.loadData();
  const courts = data.courts;

  for (let i = 0; i < courts.length; i++) {
    const courtNumber = i + 1;

    // Skip if group declined this court
    if (declinedCourts[groupId]?.includes(courtNumber)) {
      continue;
    }

    // Check if court is fully occupied or blocked right now
    const court = courts[i];
    const isOccupied = court?.current && new Date(court.current.endTime) > new Date();
    const isBlocked = court?.blocked && new Date(court.blocked.startTime) <= new Date();

    if (!isOccupied && !isBlocked) {
      tryAssignCourtToGroup();
      return;
    }
  }

  showAlertMessage("No suitable courts available at this time.");
};


const assignCourtToGroup = async (courtNumber) => {
  // Mobile: Use preselected court if in mobile flow
  if (window.__mobileFlow && window.__preselectedCourt && !courtNumber) {
    courtNumber = window.__preselectedCourt;
    console.log('Mobile: Using preselected court', courtNumber);
  }

// Check if club is open
const now = new Date();
  const currentHour = now.getHours();
  const currentMinutes = now.getMinutes();
  const currentTime = currentHour + (currentMinutes / 60); // Convert to decimal hours
  const dayOfWeek = now.getDay(); // 0 = Sunday, 6 = Saturday
  
  // Determine opening time
  const isWeekend = (dayOfWeek === 0 || dayOfWeek === 6);
  const openingTime = isWeekend ? 7 : 6.5; // 7:00 AM weekend, 6:30 AM weekday
  const openingTimeString = isWeekend ? "7:00 AM" : "6:30 AM";
  
  // If too early, show alert and return
  if (currentTime < openingTime) {
    showAlertMessage(`The club is not open yet. Court registration will be available at ${openingTimeString}.`);
    return;
  }
  
  // Validate court number
  if (!courtNumber || courtNumber < 1 || courtNumber > CONSTANTS.COURT_COUNT) {
    showAlertMessage(`Invalid court number. Please select a court between 1 and ${CONSTANTS.COURT_COUNT}.`);
    return;
  }
  
  // Validate group has players
  if (!currentGroup || currentGroup.length === 0) {
    showAlertMessage("No players in group. Please add players first.");
    return;
  }
  
  // Reuse the same extraction as the form submit path:
const players = currentGroup.map(p => ({
  id: String(p.id || '').trim(),
  name: String(p.name || '').trim()
})).filter(p => p && p.id && p.name);

const guests = currentGroup.filter(p => p.isGuest).length;

// Domain validation (reuse the same error UI as submit)
const { ok, errors } = validateGroupCompat(players, guests);
if (!ok) {
  showAlertMessage(errors.join('\n'));
  return;
}

// Duration determined from group size
const Tm = window.Tennis.Domain.time || window.Tennis.Domain.Time;
const duration = Tm.durationForGroupSize(players.length); // typically 60/90

// Canonical group object
const group = { players, guests };

// Check for upcoming block on selected court using new system
const blockStatus = await getCourtBlockStatus(courtNumber);
if (blockStatus && !blockStatus.isCurrent && blockStatus.startTime) {
  const now = new Date();
  const blockStart = new Date(blockStatus.startTime);
  const sessionEnd = new Date(now.getTime() + (duration * 60000));
  
  // Check if block will start before session ends
  if (blockStart < sessionEnd) {
    const minutesUntilBlock = Math.ceil((blockStart - now) / 60000);
    const confirmMsg = `⚠️ This court has a block starting in ${minutesUntilBlock} minutes (${blockStatus.reason}). You may not get your full ${duration} minutes.\n\nDo you want to take this court anyway?`;

    const proceed = confirm(confirmMsg);
    if (!proceed) {
      showAlertMessage("Please select a different court or join the waitlist.");
      return; // Exit without assigning
    }
  }
}

console.log('🔵 UI preparing to assignCourt with:', {
  courtNumber,
  group,
  duration
});

// Call service with canonical object (NOT an array and NOT a single player object)
const result = await TennisDataService.assignCourt(courtNumber, group, duration);
console.log('✅ Court assigned result:', result);


  if (!result.success) {
    showAlertMessage(result.error || 'Failed to assign court');
    return;
  }
  
  // Check if there were other courts available at time of assignment
  const availableAtAssignment = getAvailableCourts(
    !isChangingCourt, 
    false,
    courtNumber  // Exclude the court we're about to assign
  );
  
  // Only allow court changes if there were other options
  const allowCourtChange = availableAtAssignment.length > 0;
  
  // Update UI state based on result
  setJustAssignedCourt(courtNumber);
  setReplacedGroup(result.replacedGroup);
  setOriginalCourtData(null);
  setIsChangingCourt(false);
  setWasOvertimeCourt(false);
  setHasAssignedCourt(true);  // Track that this group has a court
  setCanChangeCourt(allowCourtChange);  // Only true if alternatives exist
  setChangeTimeRemaining(CONSTANTS.CHANGE_COURT_TIMEOUT_SEC);
  setShowSuccess(true);
  // Mobile: notify parent on success
  if (window.__mobileSuccessHandler) {
    window.__mobileSuccessHandler(justAssignedCourt || courtNumber);
  }
  // Mobile: trigger success signal
  dbg('Registration: Checking mobile success signal...', !!window.UI?.__mobileSendSuccess__);
  if (window.UI?.__mobileSendSuccess__) {
    dbg('Registration: Calling mobile success signal');
    window.UI.__mobileSendSuccess__();
  }

  if (allowCourtChange) {
    const timer = setInterval(() => {
      setChangeTimeRemaining(prev => {
        if (prev <= 1) {
          clearInterval(timer);
          setCanChangeCourt(false);
          // Don't call resetForm() - let user decide when to leave
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
  }
};



  // Change court assignment
  const changeCourt = () => {
    if (!canChangeCourt || !justAssignedCourt) return;
    
    const data = getCourtData();
    
    // Store the original court data if it was an overtime court we replaced
    const currentCourtData = data.courts[justAssignedCourt - 1];
    if (replacedGroup) {
      // We had replaced an overtime court - restore the original group
      setOriginalCourtData({
        players: replacedGroup.players,
        startTime: null, // We don't have the original start time
        endTime: replacedGroup.endTime,
        assignedAt: null,
        duration: null
      });
    }
    
    // Check if we're leaving an overtime court selection
    const wasOvertime = replacedGroup !== null;
    
    // Don't clear the court yet - just navigate to selection
    setShowSuccess(false);
    setIsChangingCourt(true);
    setWasOvertimeCourt(wasOvertime);
    setCurrentScreen("court");
  };

  // Clear a court via service
  const TD = window.TennisDataService || window.Tennis?.DataService;
  async function clearViaService(courtNumber) {
    if (!TD) return { success:false, error:'Service unavailable' };
    if (typeof TD.clearCourt === 'function') {
      return await TD.clearCourt(courtNumber);
    }
    if (typeof TD.unassignCourt === 'function') {
      return await TD.unassignCourt(courtNumber);
    }
    return { success:false, error:'No clearCourt/unassignCourt service available' };
  }

  const clearCourt = async (courtNumber) => {
    console.log(`clearCourt called for court ${courtNumber}`);
    
    const res = await clearViaService(courtNumber);
    if (!res?.success) {
      alert(res?.error || 'Failed to clear court');
      return;
    }
    console.log(`Court ${courtNumber} cleared successfully`);
    // success UI stays the same (thanks/close), no manual writes needed—
    // DataStore.set inside the service will emit both events.
  };

  // Send group to waitlist
  const sendGroupToWaitlist = async (group) => {
    // Build the group object from existing form fields / variables
    const players = group.map(p => ({
      id: String(p.id || '').trim(),
      name: String(p.name || '').trim()
    })).filter(p => p && p.id && p.name);

    const guests = group.filter(p => p.isGuest).length;

    const validation = W.validateGroup({ players, guests });
    const { ok, errors } = validation || { ok: false, errors: ['Validation failed'] };
    if (!ok) {
      // Reuse the page's existing error display surface
      showAlertMessage((errors || ['Unknown validation error']).join('\n'));
      return;
    }
    
    // Check if any player is already playing
    for (const player of group) {
      const playerStatus = isPlayerAlreadyPlaying(player.id);
      if (playerStatus.isPlaying && playerStatus.location !== 'current') {
        showAlertMessage(`${player.name} is already registered elsewhere.`);
        return;
      }
    }
    
    const result = await TennisDataService.addToWaitlist(group);
    
    if (!result.success) {
      showAlertMessage(result.error || 'Failed to add to waitlist');
    }
  };

  // Reset form
  const resetForm = () => {
    setCurrentGroup([]);
    setShowSuccess(false);
    setMemberNumber("");
    setJustAssignedCourt(null);
    setReplacedGroup(null);
    setOriginalCourtData(null);
    setCanChangeCourt(false);
    setCurrentScreen("welcome");
    setSearchInput("");
    setShowSuggestions(false);
    setShowAddPlayer(false);
    setAddPlayerSearch("");
    setShowAddPlayerSuggestions(false);
    setHasWaitlistPriority(false);
    setSelectedCourtToClear(null);
    setClearCourtStep(1);
    setIsChangingCourt(false);
    setWasOvertimeCourt(false);
    setCourtToMove(null);
    setMoveToCourtNum(null);
    setHasAssignedCourt(false);
    frequentPartnersCacheRef.current = {};
    setShowGuestForm(false);
    setGuestName("");
    setGuestSponsor("");
    setShowGuestNameError(false);
    setShowSponsorError(false);
  };

  // Get all members
  const getAllMembers = () => {
    const allMembers = {};
    Object.values(memberDatabase).forEach(member => {
      member.familyMembers.forEach(player => {
        allMembers[player.id] = player;
      });
    });
    return allMembers;
  };

  // Get frequent partners
  const getFrequentPartners = (memberNumber) => {
    const member = memberDatabase[memberNumber];
    if (!member || !member.familyMembers || member.familyMembers.length === 0) return [];

    // Use member ID as seed for consistent random generation
    const seed = member.familyMembers[0].id;
    
    const allMembers = getAllMembers();
    const memberIds = Object.keys(allMembers);
    
    // Get all potential partners (excluding self)
    const potentialPartners = [];
    
    memberIds.forEach((partnerId, index) => {
      if (partnerId != member.familyMembers[0].id) {
        const player = allMembers[partnerId];
        if (player) {
          // Check if this player is currently playing
          const playerStatus = isPlayerAlreadyPlaying(parseInt(partnerId));
          if (!playerStatus.isPlaying) {
            // Generate a consistent "play count" based on both IDs
            const combinedSeed = seed + parseInt(partnerId);
            const playCount = (combinedSeed * 9301 + 49297) % 233280;
            const normalizedCount = (playCount % 10) + 1;
            
            potentialPartners.push({
              player: player,
              count: normalizedCount
            });
          }
        }
      }
    });
    
    // Sort by play count and return top 6
    return potentialPartners
      .sort((a, b) => b.count - a.count)
      .slice(0, CONSTANTS.MAX_FREQUENT_PARTNERS);
  };

  // Check if player is already playing with detailed info
  const isPlayerAlreadyPlaying = (playerId) => {
    const data = getCourtData();
    return TennisBusinessLogic.isPlayerAlreadyPlaying(playerId, data, currentGroup);
  };

  // Generate player status message
  const getPlayerStatusMessage = (playerStatus) => {
    if (!playerStatus.isPlaying) return null;
    
    switch (playerStatus.location) {
      case 'court':
        return `${playerStatus.playerName} is already playing on Court ${playerStatus.courtNumber}`;
      case 'waiting':
        return `${playerStatus.playerName} is already in a group waiting for a court`;
      case 'current':
        return `${playerStatus.playerName} is already in your group`;
      default:
        return `${playerStatus.playerName} is already registered`;
    }
  };

  // Validate guest name (2+ words with 2+ letters each)
  const validateGuestName = (name) => {
    const words = name.trim().split(/\s+/);
    if (words.length < 2) return false;
    return words.every(word => word.length >= 2 && /^[a-zA-Z]+$/.test(word));
  };

  // Add frequent partner
  const addFrequentPartner = (player) => {
    // Validate player object
    if (!DataValidation.isValidPlayer(player)) {
      showAlertMessage("Invalid player data. Please try again.");
      return;
    }
    
    // Validate group size
    if (currentGroup.length >= CONSTANTS.MAX_PLAYERS) {
      setAlertMessage(`Group is full (max ${CONSTANTS.MAX_PLAYERS} players)`);
      setShowAlert(true);
      setTimeout(() => setShowAlert(false), CONSTANTS.ALERT_DISPLAY_MS);
      return;
    }
    
    // Check for duplicate in current group
    if (currentGroup.some(p => p.id === player.id)) {
      setAlertMessage(`${player.name} is already in your group`);
      setShowAlert(true);
      setTimeout(() => setShowAlert(false), CONSTANTS.ALERT_DISPLAY_MS);
      return;
    }
    
    const playerStatus = isPlayerAlreadyPlaying(player.id);
    if (playerStatus.isPlaying) {
      let message = "";
      if (playerStatus.location === 'court') {
        message = `${playerStatus.playerName} is already playing on Court ${playerStatus.courtNumber}`;
      } else if (playerStatus.location === 'waiting') {
        message = `${playerStatus.playerName} is already in a group waiting for a court`;
      } else if (playerStatus.location === 'current') {
        message = `${playerStatus.playerName} is already in your group`;
      }
      setAlertMessage(message);
      setShowAlert(true);
      setTimeout(() => setShowAlert(false), CONSTANTS.ALERT_DISPLAY_MS);
      return;
    }

    setCurrentGroup([...currentGroup, {
      name: player.name,
      memberNumber: findMemberNumber(player.id),
      id: player.id,
      phone: player.phone || '',
      ranking: player.ranking || null,
      winRate: player.winRate || 0.5
    }]);
    window.computeEtaPreview();
  };

  // Find member number
  const findMemberNumber = (playerId) => {
    for (const [memberNum, member] of Object.entries(memberDatabase)) {
      if (member.familyMembers.some(m => m.id === playerId)) {
        return memberNum;
      }
    }
    return "";
  };

  // Get autocomplete suggestions
  const getAutocompleteSuggestions = (input) => {
    if (!input || input.length < 1) return [];
    
    const suggestions = [];
    const lowerInput = input.toLowerCase();
    
    // Get member suggestions
    Object.entries(memberDatabase).forEach(([memberNum, data]) => {
      data.familyMembers.forEach(member => {
        // Split the name into parts
        const nameParts = member.name.split(' ');
        const firstName = nameParts[0] || '';
        const lastName = nameParts[nameParts.length - 1] || '';
        
        // Check if input matches the beginning of first or last name, or member number
        if (firstName.toLowerCase().startsWith(lowerInput) || 
            lastName.toLowerCase().startsWith(lowerInput) ||
            memberNum.startsWith(input)) {
          suggestions.push({
            memberNumber: memberNum,
            member: member,
            displayText: `${member.name} (#${memberNum})`
          });
        }
      });
    });
    
    // Sort suggestions to prioritize first name matches, then last name matches
    suggestions.sort((a, b) => {
      const aName = a.member.name.toLowerCase();
      const bName = b.member.name.toLowerCase();
      const aFirstName = aName.split(' ')[0];
      const bFirstName = bName.split(' ')[0];
      
      // Prioritize first name matches
      if (aFirstName.startsWith(lowerInput) && !bFirstName.startsWith(lowerInput)) return -1;
      if (!aFirstName.startsWith(lowerInput) && bFirstName.startsWith(lowerInput)) return 1;
      
      // Then sort alphabetically
      return aName.localeCompare(bName);
    });
    
    return suggestions.slice(0, CONSTANTS.MAX_AUTOCOMPLETE_RESULTS);
  };

  // Handle suggestion click
  const handleSuggestionClick = async (suggestion) => {
    // Validate member number exists and is valid
    if (!suggestion || !suggestion.memberNumber || !suggestion.member) {
      showAlertMessage("Invalid member selection. Please try again.");
      return;
    }
    
    // Validate member is in database
    if (!memberDatabase[suggestion.memberNumber]) {
      showAlertMessage("Member number not found in database.");
      return;
    }
    
    const playerStatus = isPlayerAlreadyPlaying(suggestion.member.id);
    
    // Set member number first
    setMemberNumber(suggestion.memberNumber);
    
    // Check if this player is in the first waiting group and courts are available
    if (playerStatus.isPlaying && playerStatus.location === 'waiting' && playerStatus.position === 1) {
      const data = getCourtData();
      const availableCourts = getAvailableCourts(false); // Don't check waitlist priority yet
      
      if (availableCourts.length > 0) {
        // Player is in first waiting group and courts are available
        const firstWaitingGroup = data.waitingGroups[0];
        
        // Load the entire waiting group
        setCurrentGroup(firstWaitingGroup.players.map(player => ({
          ...player,
          memberNumber: findMemberNumber(player.id)
        })));
        
        // Set waitlist priority flag
        setHasWaitlistPriority(true);
        
        // Remove the group from waitlist
        data.waitingGroups.shift();
        await dataStore.set('tennisClubData', data, { immediate: true });
        if (USE_SHARED_CORE && Events) {
          Events.emitDom('tennisDataUpdate', {});
        } else {
          window.dispatchEvent(new Event('tennisDataUpdate'));
        }
        
        setSearchInput("");
        setShowSuggestions(false);
        setCurrentScreen("group");
        return;
      }
    }
    
    // Check if player is in position 2 and there are 2+ courts available
    if (playerStatus.isPlaying && playerStatus.location === 'waiting' && playerStatus.position === 2) {
      const data = getCourtData();
      const availableCourts = getAvailableCourts(false);
      
      if (availableCourts.length >= 2) {
        // Player is in second waiting group and there are at least 2 courts
        const secondWaitingGroup = data.waitingGroups[1];
        
        // Load the entire waiting group
        setCurrentGroup(secondWaitingGroup.players.map(player => ({
          ...player,
          memberNumber: findMemberNumber(player.id)
        })));
        
        // Set waitlist priority flag
        setHasWaitlistPriority(true);
        
        // Remove the group from waitlist
        data.waitingGroups.splice(1, 1); // Remove second group
        await dataStore.set('tennisClubData', data, { immediate: true });
        if (USE_SHARED_CORE && Events) {
          Events.emitDom('tennisDataUpdate', {});
        } else {
          window.dispatchEvent(new Event('tennisDataUpdate'));
        }
        
        setSearchInput("");
        setShowSuggestions(false);
        setCurrentScreen("group");
        return;
      }
    }

    // Normal flow for new players
    setSearchInput("");
    setShowSuggestions(false);
    
    if (!playerStatus.isPlaying) {
      setCurrentGroup([...currentGroup, {
        name: suggestion.member.name,
        memberNumber: suggestion.memberNumber,
        id: suggestion.member.id,
        phone: suggestion.member.phone,
        ranking: suggestion.member.ranking,
        winRate: suggestion.member.winRate
      }]);
      
      setCurrentScreen("group");
    } else {
      let message = "";
      if (playerStatus.location === 'court') {
        message = `${playerStatus.playerName} is already playing on Court ${playerStatus.courtNumber}`;
      } else if (playerStatus.location === 'waiting') {
        message = `${playerStatus.playerName} is already in a group waiting for a court`;
      } else if (playerStatus.location === 'current') {
        message = `${playerStatus.playerName} is already in your group`;
      }
      setAlertMessage(message);
      setShowAlert(true);
      setTimeout(() => setShowAlert(false), CONSTANTS.ALERT_DISPLAY_MS);
    }
  };

  // Success screen
  if (showSuccess) {
    const isCourtAssignment = justAssignedCourt !== null;
    const data = getCourtData();
    const assignedCourt = justAssignedCourt ? data.courts[justAssignedCourt - 1] : null;
    
    let estimatedWait = 0;
    let position = 0;
    if (!isCourtAssignment) {
      // Position in queue - they were just added so they're last
      position = data.waitingGroups.length;
      
      // Get all court end times for occupied courts
      const courtEndTimes = data.courts
      .filter(court => court && court.current && new Date(court.current.endTime) >= currentTime) // Changed from > to >=
      .map(court => new Date(court.current.endTime).getTime())
      .sort((a, b) => a - b);
      
      if (courtEndTimes.length === 0 && position === 1) return 0;
      
      if (position <= courtEndTimes.length) {
        // They'll get one of the currently occupied courts
        estimatedWait = Math.ceil((courtEndTimes[position - 1] - currentTime.getTime()) / 60000);
      } else {
        // Use business logic for complex calculation
        estimatedWait = TennisBusinessLogic.calculateEstimatedWaitTime(
          position, 
          data.courts, 
          currentTime, 
          CONSTANTS.AVG_GAME_TIME_MIN
        );
      }
    }

    return (
      <>
        <AlertDisplay show={showAlert} message={alertMessage} />
        <SuccessScreen
          isCourtAssignment={isCourtAssignment}
          justAssignedCourt={justAssignedCourt}
          assignedCourt={assignedCourt}
          replacedGroup={replacedGroup}
          canChangeCourt={canChangeCourt}
          changeTimeRemaining={changeTimeRemaining}
          position={position}
          estimatedWait={estimatedWait}
          currentGroup={currentGroup}
          mobileCountdown={window.__mobileFlow ? mobileCountdown : null}
          onChangeCourt={changeCourt}
          onNewRegistration={() => {
            resetForm();
            setCurrentScreen("search");
          }}
          onHome={resetForm}
        />
      </>
    );
  }

// Welcome screen
if (currentScreen === "welcome") {
  return (
    <>
      <AlertDisplay show={showAlert} message={alertMessage} />
      {checkingLocation && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl p-6 shadow-xl">
            <p className="text-lg">{TENNIS_CONFIG.GEOLOCATION.CHECKING_MESSAGE}</p>
          </div>
        </div>
      )}
      <WelcomeScreen 
        onRegisterClick={() => {
          checkLocationAndProceed(() => setCurrentScreen("search"));
        }}
        onClearCourtClick={() => {
          checkLocationAndProceed(() => setCurrentScreen("clearCourt"));
        }}
      />
    </>
  );
}

  // Admin screen
  if (currentScreen === "admin") {
    const data = getCourtData();
    const now = new Date();
    const occupiedCourts = data.courts.filter(court => court !== null && court.players && court.players.length > 0 && !court.wasCleared);
    const overtimeCourts = data.courts.filter(court => court && court.players && court.players.length > 0 && !court.wasCleared && new Date(court.endTime) <= currentTime);
    
    // Count only currently blocked courts
    const blockedCourts = data.courts.filter(court => {
      if (!court || !court.blocked || !court.blocked.startTime || !court.blocked.endTime) return false;
      const blockStartTime = new Date(court.blocked.startTime);
      const blockEndTime = new Date(court.blocked.endTime);
      return now >= blockStartTime && now < blockEndTime;
    });
    
    // Handle price update
    const handlePriceUpdate = async () => {
      const price = parseFloat(ballPriceInput);
      
      // Validation
      if (isNaN(price)) {
        setPriceError('Please enter a valid number');
        return;
      }
      
      if (price < 0.50 || price > 50.00) {
        setPriceError('Price must be between $0.50 and $50.00');
        return;
      }
      
      // Save to localStorage
      try {
        const parsed = await dataStore.get(TENNIS_CONFIG.STORAGE.SETTINGS_KEY) || {};
        parsed.tennisBallPrice = price;
        await dataStore.set(TENNIS_CONFIG.STORAGE.SETTINGS_KEY, parsed, { immediate: true });
        
        // Show success message
        setShowPriceSuccess(true);
        setPriceError('');
        setTimeout(() => setShowPriceSuccess(false), 3000);
      } catch (error) {
        setPriceError('Failed to save price');
      }
    };
    
    console.log('Admin data loaded:', { 
      totalCourts: data.courts.length, 
      occupied: occupiedCourts.length, 
      blocked: blockedCourts.length,
      blockedDetails: blockedCourts
    });
    
    return (
      <div className="w-full h-full bg-gradient-to-br from-gray-900 to-gray-800 p-4 sm:p-8 flex items-center justify-center">
        <AlertDisplay show={showAlert} message={alertMessage} />
        <div className="bg-gray-900 rounded-2xl shadow-2xl p-4 sm:p-8 w-full max-w-6xl h-full max-h-[95vh] overflow-y-auto scrollbar-hide">
          <div className="mb-4 sm:mb-6">
            <h1 className="text-2xl sm:text-4xl font-bold text-white mb-2">Admin Panel</h1>
            <p className="text-gray-400 text-sm sm:text-base">System management and controls</p>
          </div>
          
          {/* Court Management */}
          <div className="mb-6 sm:mb-8 bg-gray-800 rounded-xl p-4 sm:p-6">
            <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-2 sm:gap-0">
              <h2 className="text-xl sm:text-2xl font-bold text-white">
                Court Management 
                <span className="text-sm sm:text-lg font-normal text-gray-400 block sm:inline sm:ml-3">
                  ({occupiedCourts.length} occupied, {overtimeCourts.length} overtime)
                </span>
              </h2>
              <div className="flex gap-2 w-full sm:w-auto">
                <button
                  onClick={() => {
                    setShowBlockModal(true);
                    setSelectedCourtsToBlock([]);
                    setBlockMessage("");
                    setBlockStartTime("");
                    setBlockEndTime("");
                    setBlockingInProgress(false);
                  }}
                  className="bg-yellow-700 text-white py-2 px-3 sm:px-4 rounded-lg text-xs sm:text-sm font-semibold hover:bg-yellow-800 transition-colors flex-1 sm:flex-initial"
                >
                  Block Courts
                </button>
                <button
                  onClick={async () => {
                    const confirmClear = window.confirm("Clear all courts? This will make all courts immediately available.");
                    if (confirmClear) {
                      const result = await TennisDataService.clearAllCourts();
                      if (result.success) {
                        showAlertMessage("All courts cleared successfully");
                      } else {
                        showAlertMessage(result.error || "Failed to clear courts");
                      }
                    }
                  }}
                  className="bg-orange-600 text-white py-2 px-3 sm:px-4 rounded-lg text-xs sm:text-sm font-semibold hover:bg-orange-700 transition-colors flex-1 sm:flex-initial"
                >
                  Clear All Courts
                </button>
              </div>
            </div>
            {/* Block Courts Modal */}
            {showBlockModal && (
              <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                <div className="bg-gray-800 rounded-xl p-4 sm:p-6 max-w-2xl w-full m-4 max-h-[90vh] overflow-y-auto modal-mobile-full">
                  <h3 className="text-lg sm:text-xl font-bold text-white mb-4">Block Courts</h3>
                  
                  {/* Court Selection */}
                  <div className="mb-4">
                    <label className="block text-white mb-2 text-sm sm:text-base">Select Courts to Block</label>
                    <div className="grid grid-cols-4 sm:grid-cols-6 gap-2 mb-2">
                      {[...Array(CONSTANTS.COURT_COUNT)].map((_, index) => {
                        const courtNum = index + 1;
                        const isSelected = selectedCourtsToBlock.includes(courtNum);
                        
                        return (
                          <button
                            key={courtNum}
                            onClick={() => {
                              if (isSelected) {
                                setSelectedCourtsToBlock(selectedCourtsToBlock.filter(c => c !== courtNum));
                              } else {
                                setSelectedCourtsToBlock([...selectedCourtsToBlock, courtNum]);
                              }
                              setBlockingInProgress(false); // Reset when courts change
                            }}
                            className={`py-2 px-2 sm:px-3 rounded text-xs sm:text-sm font-medium transition-colors ${
                              isSelected
                                ? "bg-yellow-600 text-white"
                                : "bg-gray-700 text-gray-300 hover:bg-gray-600"
                            }`}
                          >
                            Court {courtNum}
                          </button>
                        );
                      })}
                    </div>
                    <button
                      onClick={() => {
                        if (selectedCourtsToBlock.length === CONSTANTS.COURT_COUNT) {
                          setSelectedCourtsToBlock([]);
                        } else {
                          setSelectedCourtsToBlock([...Array(CONSTANTS.COURT_COUNT)].map((_, i) => i + 1));
                        }
                        setBlockingInProgress(false); // Reset when selection changes
                      }}
                      className="text-yellow-400 text-xs sm:text-sm hover:text-yellow-300"
                    >
                      {selectedCourtsToBlock.length === CONSTANTS.COURT_COUNT ? "Deselect All" : "Select All"}
                    </button>
                  </div>
                  
                  {/* Message Selection */}
                  <div className="mb-4">
                    <label className="block text-white mb-2 text-sm sm:text-base">Block Reason</label>
                    <div className="flex flex-wrap gap-2 mb-2">
                      <button
                        onClick={() => {
                          setBlockMessage("WET COURT");
                          setBlockingInProgress(false);
                        }}
                        className={`px-3 sm:px-4 py-2 rounded text-xs sm:text-sm ${
                          blockMessage === "WET COURT" 
                            ? "bg-yellow-600 text-white" 
                            : "bg-gray-700 text-gray-300 hover:bg-gray-600"
                        }`}
                      >
                        WET COURT
                      </button>
                      <button
                        onClick={() => {
                          setBlockMessage("COURT WORK");
                          setBlockingInProgress(false);
                        }}
                        className={`px-3 sm:px-4 py-2 rounded text-xs sm:text-sm ${
                          blockMessage === "COURT WORK" 
                            ? "bg-yellow-600 text-white" 
                            : "bg-gray-700 text-gray-300 hover:bg-gray-600"
                        }`}
                      >
                        COURT WORK
                      </button>
                      <button
                        onClick={() => {
                          setBlockMessage("LESSON");
                          setBlockingInProgress(false);
                        }}
                        className={`px-3 sm:px-4 py-2 rounded text-xs sm:text-sm ${
                          blockMessage === "LESSON" 
                            ? "bg-yellow-600 text-white" 
                            : "bg-gray-700 text-gray-300 hover:bg-gray-600"
                        }`}
                      >
                        LESSON
                      </button>
                    </div>
                    <input
                      type="text"
                      value={blockMessage}
                      onChange={(e) => {
                       setBlockMessage(e.target.value);
                       setBlockingInProgress(false);
                     }}
                     placeholder="Or enter custom message..."
                     className="w-full p-2 bg-gray-700 text-white rounded border border-gray-600 focus:border-yellow-500 focus:outline-none text-sm sm:text-base"
                   />
                 </div>
                 
                 {/* Time Selection */}
                 <div className="mb-4">
                   <label className="block text-white mb-2 text-sm sm:text-base">Start Time</label>
                   <div className="flex gap-2 mb-2">
                     <button
                       onClick={() => {
                         setBlockStartTime("now");
                         setBlockingInProgress(false);
                       }}
                       className={`px-3 sm:px-4 py-2 rounded text-xs sm:text-sm ${
                         blockStartTime === "now"
                           ? "bg-yellow-600 text-white"
                           : "bg-gray-600 text-white hover:bg-gray-700"
                       }`}
                     >
                       Now
                     </button>
                     <input
                       type="time"
                       value={blockStartTime === "now" ? "" : blockStartTime}
                       onChange={(e) => {
                         setBlockStartTime(e.target.value);
                         setBlockingInProgress(false);
                       }}
                       className="p-2 bg-gray-700 text-white rounded border border-gray-600 focus:border-yellow-500 focus:outline-none text-sm sm:text-base"
                     />
                   </div>
                 </div>
                 
                 <div className="mb-4 sm:mb-6">
                   <label className="block text-white mb-2 text-sm sm:text-base">End Time</label>
                   <div className="flex gap-2 mb-2 flex-wrap">
                     <button
                       onClick={() => {
                         const end = new Date();
                         if (blockStartTime && blockStartTime !== "now") {
                           const [hours, minutes] = blockStartTime.split(':');
                           end.setHours(parseInt(hours), parseInt(minutes));
                         }
                         end.setHours(end.getHours() + 1);
                         const endHours = end.getHours().toString().padStart(2, '0');
                         const endMinutes = end.getMinutes().toString().padStart(2, '0');
                         setBlockEndTime(`${endHours}:${endMinutes}`);
                         setBlockingInProgress(false);
                       }}
                       className="px-3 py-1 rounded bg-gray-600 text-white hover:bg-gray-700 text-xs sm:text-sm"
                     >
                       +1 hour
                     </button>
                     <button
                       onClick={() => {
                         const end = new Date();
                         if (blockStartTime && blockStartTime !== "now") {
                           const [hours, minutes] = blockStartTime.split(':');
                           end.setHours(parseInt(hours), parseInt(minutes));
                         }
                         end.setHours(end.getHours() + 2);
                         const endHours = end.getHours().toString().padStart(2, '0');
                         const endMinutes = end.getMinutes().toString().padStart(2, '0');
                         setBlockEndTime(`${endHours}:${endMinutes}`);
                       }}
                       className="px-3 py-1 rounded bg-gray-600 text-white hover:bg-gray-700 text-xs sm:text-sm"
                     >
                       +2 hours
                     </button>
                     <button
                       onClick={() => {
                         const end = new Date();
                         if (blockStartTime && blockStartTime !== "now") {
                           const [hours, minutes] = blockStartTime.split(':');
                           end.setHours(parseInt(hours), parseInt(minutes));
                         }
                         end.setHours(end.getHours() + 4);
                         const endHours = end.getHours().toString().padStart(2, '0');
                         const endMinutes = end.getMinutes().toString().padStart(2, '0');
                         setBlockEndTime(`${endHours}:${endMinutes}`);
                       }}
                       className="px-3 py-1 rounded bg-gray-600 text-white hover:bg-gray-700 text-xs sm:text-sm"
                     >
                       +4 hours
                     </button>
                   </div>
                   <input
                     type="time"
                     value={blockEndTime}
                     onChange={(e) => {
                       setBlockEndTime(e.target.value);
                       setBlockingInProgress(false);
                     }}
                     required
                     className="p-2 bg-gray-700 text-white rounded border border-gray-600 focus:border-yellow-500 focus:outline-none w-full text-sm sm:text-base"
                   />
                 </div>
                 
                 {/* Action Buttons */}
                 <div className="flex gap-2 justify-end">
                   <button
                     onClick={() => setShowBlockModal(false)}
                     className="px-4 sm:px-6 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors text-sm sm:text-base"
                   >
                     Close
                   </button>
                   <button
                     onClick={() => {
                       if (selectedCourtsToBlock.length === 0) {
                         showAlertMessage("Please select at least one court to block");
                         return;
                       }
                       if (!blockMessage) {
                         showAlertMessage("Please enter a block reason");
                         return;
                       }
                       if (!blockEndTime) {
                         showAlertMessage("Please select an end time");
                         return;
                       }
                       
                       // Set blocking in progress
                       setBlockingInProgress(true);
                       
                       const data = getCourtData();
                       const currentTime = new Date(); // Use different name to avoid scope conflict
                       
                       // Calculate start time
                       let startTime;
                       if (blockStartTime === "now") {
                         startTime = new Date();
                       } else {
                         // Create a date with today's date and the selected time
                         startTime = new Date();
                         const [hours, minutes] = blockStartTime.split(':');
                         startTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
                         
                         // Don't automatically adjust to tomorrow - let admin set past times if needed
                       }
                       
                       // Calculate end time based on the selected time
                       const [endHours, endMinutes] = blockEndTime.split(':');
                       let endTime = new Date(startTime); // Start from the same date as start time
                       endTime.setHours(parseInt(endHours), parseInt(endMinutes), 0, 0);
                       
                       // If end time is before start time, assume next day
                       if (endTime <= startTime) {
                         endTime.setDate(endTime.getDate() + 1);
                       }
                       
                       console.log('Block times calculated:', {
                         blockStartTimeInput: blockStartTime,
                         currentTime: currentTime.toLocaleString(),
                         startTime: startTime.toLocaleString(),
                         endTime: endTime.toLocaleString()
                       });
                       

                    // Block selected courts
selectedCourtsToBlock.forEach(courtNum => {
 // Use the new block system
 TennisDataService.addCourtBlock(
   courtNum,
   blockMessage,
   startTime.toISOString(),
   endTime.toISOString()
 );
});

showAlertMessage(`${selectedCourtsToBlock.length} court(s) blocked successfully`);
                       
                      
                       // Don't reset the form, just set blocking state
                       // This allows multiple blocks to be applied
                       // setTimeout removed - keep state immediately
                     }}
                     disabled={blockingInProgress}
                     className={`px-4 sm:px-6 py-2 rounded transition-colors text-sm sm:text-base ${
                       blockingInProgress 
                         ? 'bg-yellow-400 text-white cursor-not-allowed' 
                         : 'bg-yellow-600 text-white hover:bg-yellow-700'
                     }`}
                   >
                     {blockingInProgress ? 'Applied' : 'Apply Blocks'}
                   </button>
                 </div>
               </div>
             </div>
           )}
           
           {/* Move Court UI */}
           {courtToMove && (
             <div className="mb-4 p-3 sm:p-4 bg-blue-900/30 border-2 border-blue-600 rounded-lg">
               <p className="text-white font-medium mb-3 text-sm sm:text-base">
                 Moving players from Court {courtToMove} to:
               </p>
               <div className="grid grid-cols-4 sm:grid-cols-6 gap-2 mb-3">
                 {[...Array(CONSTANTS.COURT_COUNT)].map((_, index) => {
                   const targetCourtNum = index + 1;
                   const isOccupied = data.courts[index] !== null;
                   const isCurrent = targetCourtNum === courtToMove;
                   
                   return (
                     <button
                       key={targetCourtNum}
                       disabled={isOccupied || isCurrent}
                       onClick={async () => {
                         const result = await TennisDataService.moveCourt(courtToMove, targetCourtNum);
                         
                         if (result.success) {
                           showAlertMessage(`Court ${courtToMove} moved to Court ${targetCourtNum}`);
                         } else {
                           showAlertMessage(result.error || 'Failed to move court');
                         }
                         
                         setCourtToMove(null);
                       }}
                       className={`py-2 px-2 sm:px-3 rounded text-xs sm:text-sm font-medium transition-colors ${
                         isCurrent
                           ? "bg-gray-600 text-gray-400 cursor-not-allowed"
                           : isOccupied
                           ? "bg-gray-700 text-gray-500 cursor-not-allowed"
                           : "bg-blue-600 text-white hover:bg-blue-700"
                       }`}
                     >
                       Court {targetCourtNum}
                     </button>
                   );
                 })}
               </div>
               <button
                 onClick={() => setCourtToMove(null)}
                 className="bg-gray-600 text-white px-4 py-1 rounded text-sm hover:bg-gray-700 transition-colors"
               >
                 Cancel
               </button>
             </div>
           )}
           
           <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
             {[...Array(12)].map((_, index) => {
               const court = data.courts[index];
               const courtNum = index + 1;
               const now = new Date();
               
               // Check block status using unified system only
let blockStatus = null;
const blockStatusResult = getCourtBlockStatus(courtNum);

if (blockStatusResult && blockStatusResult.isBlocked) {
  blockStatus = blockStatusResult.isCurrent ? 'current' : 'future';
}
               
               const isBlocked = blockStatus === 'current';
               const isFutureBlock = blockStatus === 'future';
               const isCleared = court && court.wasCleared;
               const isOccupied = court && court.players && court.players.length > 0 && !isCleared;
               const isOvertime = court && court.endTime && !isBlocked && !isCleared && new Date(court.endTime) <= currentTime;
               const timeRemaining = court && court.endTime && !isBlocked && !isCleared
                 ? Math.max(0, Math.floor((new Date(court.endTime).getTime() - currentTime.getTime()) / 60000))
                 : 0;
               
               return (
                 <div
                   key={courtNum}
                   className={`p-3 sm:p-4 rounded-lg border-2 ${
                     isBlocked
                       ? "bg-red-900 border-red-700"
                       : isFutureBlock
                       ? "bg-yellow-900 border-yellow-700"
                       : !court 
                       ? "bg-gray-700 border-gray-600" 
                       : "bg-gray-700 border-gray-600"
                   }`}
                 >
                   <div className="flex justify-between items-start">
                     <div className="flex-1">
                       <div className="flex items-center gap-2 sm:gap-4 mb-2">
                         <h3 className="text-base sm:text-lg font-bold text-white">Court {courtNum}</h3>
                         {isOccupied && !isBlocked && (
                           <span className={`text-xs sm:text-sm font-medium text-gray-400`}>
                             {isOvertime ? 'Overtime' : `${timeRemaining} min remaining`}
                           </span>
                         )}
                       </div>
                       {isBlocked ? (
                         <div>

                          <p className="text-red-400 font-medium text-sm sm:text-base">
  🚫 {blockStatusResult ? blockStatusResult.reason : "BLOCKED"}
</p>

<p className="text-gray-400 text-xs sm:text-sm">
  Until {new Date(blockStatusResult.endTime).toLocaleTimeString([], {
    hour: "2-digit",
    minute: "2-digit"
  })}
</p>


                         </div>

                         ) : isFutureBlock ? (
  <div>
    <p className="text-yellow-400 font-medium text-sm sm:text-base">
      Future: {blockStatusResult.reason}
    </p>
    <p className="text-gray-400 text-xs sm:text-sm">
      {new Date(blockStatusResult.startTime).toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit"
      })} - {new Date(blockStatusResult.endTime).toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit"
      })}
    </p>
  </div>


                       ) : isOccupied ? (
                         <div>
                           <div className="flex flex-col">
                             {court.players.map((player, idx) => (
                               <span key={idx} className="text-gray-300 text-xs sm:text-sm">
                                 {player.name.split(' ').pop()}
                               </span>
                             ))}
                           </div>

                         </div>
                       ) : isCleared ? (
                         <p className="text-gray-500 text-xs sm:text-sm">Available (History Preserved)</p>
                       ) : (
                         <p className="text-gray-500 text-xs sm:text-sm">Available</p>
                       )}
                     </div>
                     {(isOccupied || isBlocked || isFutureBlock) && (
                       <div className="flex flex-col gap-1 ml-2">
                         {!isBlocked && !isFutureBlock && isOccupied && (
                           <button
                             onClick={() => setCourtToMove(courtNum)}
                             className="bg-blue-600 text-white px-2 sm:px-3 py-1 rounded text-xs sm:text-sm hover:bg-blue-700 transition-colors"
                           >
                             Move
                           </button>
                         )}
                         <button
                           onClick={async () => {
                             await clearCourt(courtNum);
                             showAlertMessage(`Court ${courtNum} ${isBlocked || isFutureBlock ? 'unblocked' : 'cleared'}`);
                           }}
                           className="bg-orange-600 text-white px-2 sm:px-3 py-1 rounded text-xs sm:text-sm hover:bg-orange-700 transition-colors"
                         >
                           Clear
                         </button>
                       </div>
                     )}
                   </div>
                 </div>
               );
             })}
           </div>
         </div>

         {/* Waitlist Management */}
         <div className="mb-6 sm:mb-8 bg-gray-800 rounded-xl p-4 sm:p-6">
           <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-2 sm:gap-0">
             <h2 className="text-xl sm:text-2xl font-bold text-white">
               Waitlist Management
               <span className="text-sm sm:text-lg font-normal text-gray-400 block sm:inline sm:ml-3">
                 ({data.waitingGroups.length} groups waiting)
               </span>
             </h2>
             {data.waitingGroups.length > 0 && (
               <button
                 onClick={async () => {
                   const confirmClear = window.confirm("Clear the waitlist? This will remove all waiting groups.");
                   if (confirmClear) {
                     const result = await TennisDataService.clearWaitlist();
                     if (result.success) {
                       showAlertMessage("Waitlist cleared successfully");
                     } else {
                       showAlertMessage(result.error || "Failed to clear waitlist");
                     }
                   }
                 }}
                 className="bg-orange-600 text-white py-2 px-3 sm:px-4 rounded-lg text-xs sm:text-sm font-semibold hover:bg-orange-700 transition-colors w-full sm:w-auto"
               >
                 Clear Waitlist
               </button>
             )}
           </div>
           {data.waitingGroups.length === 0 ? (
             <p className="text-gray-500 text-center py-8 text-sm sm:text-base">No groups in waitlist</p>
           ) : (
             <div className="space-y-3">
               {waitlistMoveFrom !== null && (
                 <div className="mb-4 p-3 sm:p-4 bg-blue-900/30 border-2 border-blue-600 rounded-lg">
                   <p className="text-white font-medium mb-3 text-sm sm:text-base">
                     Moving group from position {waitlistMoveFrom + 1} to:
                   </p>
                   <div className="flex gap-2 flex-wrap mb-3">
                     {data.waitingGroups.map((_, index) => {
                       const position = index + 1;
                       const isCurrentPosition = index === waitlistMoveFrom;
                       
                       return (
                         <button
                           key={position}
                           disabled={isCurrentPosition}
                           onClick={async () => {
                             // Reorder the waitlist
                             const newWaitlist = [...data.waitingGroups];
                             const [movedGroup] = newWaitlist.splice(waitlistMoveFrom, 1);
                             newWaitlist.splice(index, 0, movedGroup);
                             
                             const result = await TennisDataService.saveData({
                               ...data,
                               waitingGroups: newWaitlist
                             });
                             
                             if (result.success) {
                               showAlertMessage(`Group moved to position ${position}`);
                             } else {
                               showAlertMessage(result.error || 'Failed to move group');
                             }
                             
                             setWaitlistMoveFrom(null);
                           }}
                           className={`py-2 px-3 rounded text-xs sm:text-sm font-medium transition-colors ${
                             isCurrentPosition
                               ? "bg-gray-600 text-gray-400 cursor-not-allowed"
                               : "bg-blue-600 text-white hover:bg-blue-700"
                           }`}
                         >
                           Position {position}
                         </button>
                       );
                     })}
                   </div>
                   <button
                     onClick={() => setWaitlistMoveFrom(null)}
                     className="bg-gray-600 text-white px-4 py-1 rounded text-sm hover:bg-gray-700 transition-colors"
                   >
                     Cancel
                   </button>
                 </div>
               )}
               {data.waitingGroups.map((group, index) => (
                 <div key={index} className="bg-gray-700 p-3 sm:p-4 rounded-lg flex flex-col sm:flex-row justify-between items-start sm:items-center gap-2">
                   <div className="flex-1">
                     <p className="text-white font-medium text-sm sm:text-base">
                       Position {index + 1}: {group.players.map(p => p.name).join(", ")}
                     </p>
                     <p className="text-gray-400 text-xs sm:text-sm">
                       {group.players.length} player{group.players.length > 1 ? 's' : ''}
                     </p>
                   </div>
                   <div className="flex gap-2 w-full sm:w-auto">
                     <button
                       onClick={() => setWaitlistMoveFrom(index)}
                       className="bg-blue-600 text-white px-3 sm:px-4 py-1.5 sm:py-2 rounded hover:bg-blue-700 transition-colors text-xs sm:text-sm flex-1 sm:flex-initial"
                     >
                       Move
                     </button>
                     <button
                       onClick={async () => {
                         const result = await TennisDataService.removeFromWaitlist(index);
                         
                         if (result.success) {
                           showAlertMessage("Group removed from waitlist");
                         } else {
                           showAlertMessage(result.error || "Failed to remove group");
                         }
                       }}
                       className="bg-orange-600 text-white px-3 sm:px-4 py-1.5 sm:py-2 rounded hover:bg-orange-700 transition-colors text-xs sm:text-sm flex-1 sm:flex-initial"
                     >
                       Remove
                     </button>
                   </div>
                 </div>
               ))}
             </div>
           )}
         </div>
         
         {/* System Settings */}
         <div className="mb-6 sm:mb-8 bg-gray-800 rounded-xl p-4 sm:p-6">
           <h2 className="text-xl sm:text-2xl font-bold text-white mb-4">System Settings</h2>
           
           <div className="bg-gray-700 rounded-lg p-4">
             <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
               <div>
                 <h3 className="text-base sm:text-lg font-medium text-white">Tennis Ball Price</h3>
                 <p className="text-xs sm:text-sm text-gray-400">Set the price for tennis ball purchases</p>
               </div>
               
               <div className="flex items-center gap-3 w-full sm:w-auto">
                 <div className="relative flex-1 sm:flex-initial">
                   <span className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">$</span>
                   <input
                     type="number"
                     step="0.01"
                     min="0.50"
                     max="50.00"
                     value={ballPriceInput}
                     onChange={(e) => {
                       setBallPriceInput(e.target.value);
                       setPriceError('');
                       setShowPriceSuccess(false);
                     }}
                     className="pl-8 pr-3 py-2 bg-gray-600 text-white rounded border border-gray-500 focus:border-blue-500 focus:outline-none w-full sm:w-24"
                   />
                 </div>
                 
                 <button
                   onClick={handlePriceUpdate}
                   className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors text-sm sm:text-base"
                 >
                   Save
                 </button>
               </div>
             </div>
             
             {showPriceSuccess && (
               <div className="mt-2 text-green-400 text-xs sm:text-sm flex items-center gap-2">
                 <Check size={14} className="sm:w-4 sm:h-4" />
                 Price updated successfully
               </div>
             )}
             
             {priceError && (
               <div className="mt-2 text-red-400 text-xs sm:text-sm">
                 {priceError}
               </div>
             )}
           </div>
         </div>
         
         {/* Exit Admin */}
         <div className="flex justify-center">
           <button
             onClick={() => {
               setCurrentScreen("welcome");
               setSearchInput("");
             }}
             className="bg-gray-600 text-white py-2 sm:py-3 px-6 sm:px-8 rounded-xl text-base sm:text-lg font-semibold hover:bg-gray-700 transition-colors"
           >
             Exit Admin Panel
           </button>
         </div>
       </div>
     </div>
   );
 }

 // Search screen
 if (currentScreen === "search") {
   // Use state variables calculated in useEffect
   
   return (
     <div className="w-full h-full min-h-screen bg-gradient-to-br from-green-50 to-blue-50 p-4 sm:p-8 flex items-center justify-center">
       <AlertDisplay show={showAlert} message={alertMessage} />
       <div className="bg-white rounded-2xl shadow-2xl p-6 sm:p-12 w-full max-w-2xl">
         <div className="mb-6 sm:mb-8 relative">
           <label className="block text-xl sm:text-2xl font-medium mb-3 sm:mb-4">Enter your name or member number</label>
           <div className="relative">
             <input
               type="text"
               value={searchInput}
               onChange={(e) => {
  markUserTyping();
  const value = e.target.value || "";
  setSearchInput(value);
  
  // Check for admin code (immediate, no debounce)
  if (value === CONSTANTS.ADMIN_CODE) {
    setCurrentScreen("admin");
    setSearchInput("");
    return;
  }
  
  setShowSuggestions(value.length > 0);
}}
onFocus={() => {
  markUserTyping();
  setShowSuggestions(searchInput.length > 0);
}}
               
               placeholder="Start typing..."
               className="w-full p-4 sm:p-5 text-xl sm:text-2xl border-2 rounded-xl focus:border-green-500 focus:outline-none"
               id="main-search-input"
               autoFocus
               autoComplete="off"
               autoCorrect="off"
               autoCapitalize="words"
               spellCheck="false"
             />
             
             {/* Loading indicator */}
             {isSearching && (
               <div className="absolute right-12 top-1/2 transform -translate-y-1/2">
                 <div className="animate-spin h-6 w-6 border-2 border-gray-300 border-t-green-500 rounded-full"></div>
               </div>
             )}
           </div>
           
           {showSuggestions && getAutocompleteSuggestions(effectiveSearchInput).length > 0 && (
             <div className="absolute z-10 w-full mt-2 bg-white border-2 border-gray-200 rounded-xl shadow-lg overflow-y-auto" style={{ maxHeight: '400px' }}>
               {getAutocompleteSuggestions(effectiveSearchInput).map((suggestion, idx) => (
                 <button
                   key={idx}
                   onClick={() => handleSuggestionClick(suggestion)}
                   className="w-full p-3 sm:p-4 text-left hover:bg-green-50 border-b last:border-b-0 transition-colors block"
                 >
                   <div className="font-medium text-lg sm:text-xl">{suggestion.member.name}</div>
                   <div className="text-sm sm:text-base text-gray-600">Member #{suggestion.memberNumber}</div>
                 </button>
               ))}
             </div>
           )}
         </div>
         
         {canFirstGroupPlay && (
           <button
             onClick={() => {
               // Load the waiting group
               setCurrentGroup(firstWaitingGroup.players.map(player => ({
                 ...player,
                 memberNumber: findMemberNumber(player.id)
               })));
               
               // Set member number to first player
               const firstPlayerMemberNum = findMemberNumber(firstWaitingGroup.players[0].id);
               setMemberNumber(firstPlayerMemberNum);
               
               // Set waitlist priority flag
               setHasWaitlistPriority(true);
               
               // Remove the group from waitlist
               data.waitingGroups.shift();
               saveCourtData(data);
               
               // Navigate to court selection
               setCurrentScreen("court");
             }}
             className="w-full bg-green-500 text-white py-4 sm:py-5 px-6 rounded-xl text-xl sm:text-2xl font-semibold hover:bg-green-600 transition-colors mb-4 animate-pulse"
           >
             <div className="flex items-center justify-center">
               <span className="mr-2">Court Available:</span>
               <span>{waitingGroupDisplay}</span>
             </div>
           </button>
         )}
         
         <button
           onClick={() => setCurrentScreen("welcome")}
           className="w-full bg-gray-200 text-gray-700 py-3 sm:py-4 px-6 rounded-xl text-lg sm:text-xl hover:bg-gray-300 transition-colors"
         >
           Go Back
         </button>
       </div>
     </div>
   );
 }

 // Group management screen
 if (currentScreen === "group") {
   // Get frequent partners with caching using ref
   let frequentPartners = [];
   if (memberNumber) {
     if (!frequentPartnersCacheRef.current[memberNumber]) {
       frequentPartnersCacheRef.current[memberNumber] = getFrequentPartners(memberNumber);
     }
     frequentPartners = frequentPartnersCacheRef.current[memberNumber] || [];
   }

   return (
     <div className="w-full h-full min-h-screen bg-gradient-to-br from-green-50 to-blue-50 p-4 sm:p-8 flex items-center justify-center">
       <AlertDisplay show={showAlert} message={alertMessage} />
       {showTimeoutWarning && (
         <div className="fixed top-4 sm:top-8 left-1/2 transform -translate-x-1/2 bg-orange-500 text-white p-3 sm:p-4 rounded-xl shadow-lg z-50 text-base sm:text-lg animate-pulse">
           Session will expire in 30 seconds due to inactivity
         </div>
       )}
       <div className="bg-white rounded-2xl shadow-2xl p-4 sm:p-8 w-full max-w-5xl h-full max-h-[95vh] flex flex-col relative overflow-hidden">
         {/* Mobile-specific UI when no player added yet */}
         {window.__mobileFlow && currentGroup.length === 0 ? (
           <div className="mb-3 sm:mb-4 p-3 sm:p-4 bg-green-50 rounded-xl text-center">
             <p className="text-lg sm:text-2xl text-green-800 font-semibold">
               Court {window.__preselectedCourt} Selected
             </p>
           </div>
         ) : (
           /* Normal UI for desktop or when player exists */
           <div className="mb-3 sm:mb-4 p-3 sm:p-4 bg-blue-50 rounded-xl text-center">
             <p className="text-lg sm:text-2xl text-blue-800">
               Welcome{currentGroup[0]?.name ? <>, <strong>{currentGroup[0]?.name}</strong></> : ''}!
             </p>
             <p className="text-base sm:text-lg text-gray-600 mt-1 sm:mt-2">
               {currentGroup.length === 0
                 ? "Search for players to add to your group"
                 : currentGroup.length === 1 
                 ? "Add more players to your group or select a court"
                 : `${currentGroup.length} players in your group`}
             </p>
             {hasWaitlistPriority && (
               <div className="mt-2 sm:mt-3 p-2 sm:p-3 bg-yellow-100 rounded-lg animate-pulse">
                 <p className="text-base sm:text-lg font-bold text-yellow-800">
                   Courts are now available for your group!
                 </p>
               </div>
             )}
           </div>
         )}
         <div className="flex-1 overflow-y-auto pb-24 sm:pb-32" style={{maxHeight: 'calc(100vh - 280px)'}}>
           {/* Only show Current Group section if there are players or not in mobile flow */}
           {(currentGroup.length > 0 || !window.__mobileFlow) && (
             <>
               <h3 className="text-xl sm:text-2xl font-medium mb-2 sm:mb-3">Current Group</h3>
               <div className="space-y-2 mb-3 sm:mb-4">
                 {currentGroup.map((player, idx) => (
               <div
                 key={idx}
                 className="flex items-center justify-between bg-gray-50 p-2.5 sm:p-3 rounded-xl"
               >
                 <div>
                   <span className="font-medium text-base sm:text-lg">{player.name}</span>
                   {player.isGuest && (
                     <span className="text-xs sm:text-sm text-blue-600 ml-2 sm:ml-3 font-medium">
                       (Guest{player.sponsor ? ` of ${player.sponsor}` : ''})
                     </span>
                   )}
                   {!player.isGuest && player.ranking && (
                     <span className="text-xs sm:text-sm text-blue-600 ml-2 sm:ml-3">Rank #{player.ranking}</span>
                   )}
                 </div>
                 <button
                   onClick={() => {
                     setCurrentGroup(currentGroup.filter((_, i) => i !== idx));
                     window.computeEtaPreview();
                   }}
                   className="text-red-500 hover:bg-red-50 px-3 sm:px-4 py-1.5 sm:py-2 rounded-lg transition-colors text-sm sm:text-base"
                 >
                   Remove
                 </button>
               </div>
             ))}
               </div>
             </>
           )}


           {/* Mobile flow: Show search input when no players, otherwise show Add Another Player button */}
           {window.__mobileFlow && currentGroup.length === 0 ? (
             <div className="mb-4">
               <div className="relative">
                 <input
                   type="text"
                   value={searchInput}
                   onChange={(e) => {
                     markUserTyping();
                     const value = e.target.value || "";
                     setSearchInput(value);
                     
                     // Check for admin code (immediate, no debounce)
                     if (value === CONSTANTS.ADMIN_CODE) {
                       setCurrentScreen("admin");
                       setSearchInput("");
                       return;
                     }
                     
                     setShowSuggestions(value.length > 0);
                   }}
                   onFocus={() => {
                     markUserTyping();
                     setShowSuggestions(searchInput.length > 0);
                   }}
                   placeholder="Enter your name or Member #"
                   className="w-full p-4 sm:p-5 text-xl sm:text-2xl border-2 rounded-xl focus:border-green-500 focus:outline-none"
                   id="mobile-group-search-input"
                   autoFocus
                   autoComplete="off"
                   autoCorrect="off"
                   autoCapitalize="words"
                   spellCheck="false"
                 />
               </div>
               
               {/* Search suggestions dropdown */}
               {showSuggestions && (
                 <div className="absolute z-10 w-full mt-2 bg-white border-2 border-gray-200 rounded-xl shadow-lg overflow-hidden" style={{maxHeight: '400px', overflowY: 'auto'}}>
                   {getAutocompleteSuggestions(effectiveSearchInput).length > 0 ? (
                     getAutocompleteSuggestions(effectiveSearchInput).map((suggestion, idx) => (
                       <button
                         key={idx}
                         onClick={async () => {
                           await handleSuggestionClick(suggestion);
                           // For mobile flow, clear search after adding first player
                           if (window.__mobileFlow) {
                             setSearchInput("");
                             setShowSuggestions(false);
                           }
                         }}
                         className="w-full p-4 text-left hover:bg-blue-50 flex items-center border-b border-gray-100"
                       >
                         <div className="flex-1">
                           <div className="font-medium text-lg">
                             {suggestion.member.name}
                             {suggestion.member.isGuest && (
                               <span className="text-sm text-blue-600 ml-2">(Guest)</span>
                             )}
                           </div>
                           {suggestion.type === 'member' && (
                             <div className="text-sm text-gray-600">Member #{suggestion.member.id}</div>
                           )}
                         </div>
                         {suggestion.type === 'member' && suggestion.member.ranking && (
                           <div className="text-sm text-blue-600 font-medium">Rank #{suggestion.member.ranking}</div>
                         )}
                       </button>
                     ))
                   ) : (
                     <div className="p-4 text-center text-gray-500">
                       {searchInput.length < 2 ? "Keep typing..." : "No members found"}
                     </div>
                   )}
                 </div>
               )}
             </div>
           ) : currentGroup.length < CONSTANTS.MAX_PLAYERS && (
  <div className="flex gap-2 sm:gap-3 mb-3">
    <button
      onClick={() => {
        if (showGuestForm) {
          // If guest form is showing, close it and reset
          setShowGuestForm(false);
          setGuestName("");
          setGuestSponsor("");
          setShowGuestNameError(false);
          setShowSponsorError(false);
          setShowAddPlayer(false);
        } else {
          // Normal toggle behavior
          setShowAddPlayer(!showAddPlayer);
        }
      }}
      className="flex-1 bg-green-500 text-white py-2 sm:py-3 px-3 sm:px-6 rounded-xl text-base sm:text-xl hover:bg-green-600 transition-colors"
    >
      Add Another Player
    </button>
    <button
      onClick={() => {
        if (showGuestForm) {
          // If guest form is already showing, close it
          setShowGuestForm(false);
          setGuestName("");
          setGuestSponsor("");
          setShowGuestNameError(false);
          setShowSponsorError(false);
          setShowAddPlayer(false);
        } else {
          // Open guest form
          setShowGuestForm(true);
          setShowAddPlayer(true);
          setShowAddPlayerSuggestions(false);
          setAddPlayerSearch("");
          // Set default sponsor if only one member in group
          if (currentGroup.length === 1 && !currentGroup[0].isGuest) {
            setGuestSponsor(currentGroup[0].memberNumber);
          }
        }
      }}
      className="bg-blue-50 text-blue-600 border border-blue-600 py-2 sm:py-3 px-3 sm:px-6 rounded-xl text-base sm:text-xl hover:bg-blue-100 transition-colors"
    >
      + Guest
    </button>
  </div>
)}


           {showAddPlayer && !showGuestForm && (
             <div className="mb-4 relative">
               <div className="relative">
                 <input
                   type="text"
                   value={addPlayerSearch}
                   
                   onChange={(e) => {
  markUserTyping();
  setAddPlayerSearch(e.target.value || "");
  setShowAddPlayerSuggestions((e.target.value || "").length > 0);
}}
onFocus={() => {
  markUserTyping();
  setShowAddPlayerSuggestions(addPlayerSearch.length > 0);
}}
                   
                   placeholder="Enter name or member number..."
                   className="w-full p-2.5 sm:p-3 text-lg sm:text-xl border-2 rounded-xl focus:border-green-500 focus:outline-none"
                   autoFocus
                   autoComplete="off"
                   autoCorrect="off"
                   autoCapitalize="words"
                   spellCheck="false"
                 />
               </div>
               
               {showAddPlayerSuggestions && (
                 <div className="absolute z-10 w-full mt-2 bg-white border-2 border-gray-200 rounded-xl shadow-lg" style={{ maxHeight: '200px', overflowY: 'auto' }}>
                   {getAutocompleteSuggestions(effectiveAddPlayerSearch).length > 0 ? (
                     getAutocompleteSuggestions(effectiveAddPlayerSearch).map((suggestion, idx) => (
                       <button
                         key={idx}
                         onClick={async () => {
                           // Validate suggestion
                           if (!suggestion || !suggestion.member || !suggestion.member.id) {
                             showAlertMessage("Invalid player selection. Please try again.");
                             return;
                           }
                           
                           // Check for duplicate in current group
                           if (currentGroup.some(p => p.id === suggestion.member.id)) {
                             showAlertMessage(`${suggestion.member.name} is already in your group`);
                             setAddPlayerSearch("");
                             setShowAddPlayer(false);
                             setShowAddPlayerSuggestions(false);
                             return;
                           }
                           
                           const playerStatus = isPlayerAlreadyPlaying(suggestion.member.id);
                           
                           if (playerStatus.isPlaying && playerStatus.location === 'waiting' && playerStatus.position === 1) {
                             const data = getCourtData();
                             const availableCourts = getAvailableCourts(false);
                             
                             if (availableCourts.length > 0) {
                               const firstWaitingGroup = data.waitingGroups[0];
                               setCurrentGroup(firstWaitingGroup.players.map(player => ({
                                 ...player,
                                 memberNumber: findMemberNumber(player.id)
                               })));
                               
                               setHasWaitlistPriority(true);
                               
                               data.waitingGroups.shift();
                               saveCourtData(data);
                               
                               setAddPlayerSearch("");
                               setShowAddPlayer(false);
                               setShowAddPlayerSuggestions(false);
                               return;
                             }
                           }
                           
                           if (!playerStatus.isPlaying) {
                             // Validate we're not exceeding max players
                             if (currentGroup.length >= CONSTANTS.MAX_PLAYERS) {
                               showAlertMessage(`Group is full (max ${CONSTANTS.MAX_PLAYERS} players)`);
                               setAddPlayerSearch("");
                               setShowAddPlayer(false);
                               setShowAddPlayerSuggestions(false);
                               return;
                             }
                             
                             setCurrentGroup([...currentGroup, {
                               name: suggestion.member.name,
                               memberNumber: suggestion.memberNumber,
                               id: suggestion.member.id,
                               phone: suggestion.member.phone,
                               ranking: suggestion.member.ranking,
                               winRate: suggestion.member.winRate
                             }]);
                             setAddPlayerSearch("");
                             setShowAddPlayer(false);
                             setShowAddPlayerSuggestions(false);
                           } else {
                             let message = "";
                             if (playerStatus.location === 'court') {
                               message = `${playerStatus.playerName} is already playing on Court ${playerStatus.courtNumber}`;
                             } else if (playerStatus.location === 'waiting') {
                               message = `${playerStatus.playerName} is already in a group waiting for a court`;
                             } else if (playerStatus.location === 'current') {
                               message = `${playerStatus.playerName} is already in your group`;
                             }
                             setAlertMessage(message);
                             setShowAlert(true);
                             setTimeout(() => setShowAlert(false), CONSTANTS.ALERT_DISPLAY_MS);
                           }
                         }}
                         className="w-full p-2.5 sm:p-3 text-left hover:bg-green-50 border-b last:border-b-0 transition-colors block"
                       >
                         <div className="font-medium text-base sm:text-lg">{suggestion.member.name}</div>
                         <div className="text-xs sm:text-sm text-gray-600">Member #{suggestion.memberNumber}</div>
                       </button>
                     ))
                   ) : addPlayerSearch.length >= 2 ? (
                     <button
                       onClick={() => {
                         setGuestName(addPlayerSearch);
                         setShowGuestForm(true);
                         setShowAddPlayerSuggestions(false);
                         setAddPlayerSearch("");
                         // Set default sponsor if only one member in group
                         if (currentGroup.length === 1 && !currentGroup[0].isGuest) {
                           setGuestSponsor(currentGroup[0].memberNumber);
                         }
                       }}
                       className="w-full p-2.5 sm:p-3 text-left hover:bg-blue-50 transition-colors block"
                     >
                       <div className="font-medium text-base sm:text-lg text-blue-600">Add "{addPlayerSearch}" as guest?</div>
                       <div className="text-xs sm:text-sm text-gray-600">No member found with this name</div>
                     </button>
                   ) : null}
                 </div>
               )}
             </div>
           )}

           {/* Guest Form */}
           {showAddPlayer && showGuestForm && (
             <div className="mb-4 p-3 sm:p-4 bg-blue-50 rounded-xl">
               <h4 className="font-medium mb-2 sm:mb-3 text-sm sm:text-base">Add Guest Player</h4>
               
               <div className="mb-2 sm:mb-3">
                 <input
                   type="text"
                   value={guestName}
                   onChange={(e) => {
  markUserTyping();
  setGuestName(e.target.value);
  setShowGuestNameError(false);
}}
                   
                   placeholder="Enter first and last name"
                   className="w-full p-2 text-base sm:text-lg border-2 rounded-lg focus:border-blue-500 focus:outline-none"
                   autoFocus
                 />
                 {showGuestNameError && (
                   <p className="text-red-500 text-xs sm:text-sm mt-1">
                     Please enter your guest's full name
                   </p>
                 )}
               </div>

               {/* Only show sponsor selection if there are multiple members */}
               {currentGroup.filter(p => !p.isGuest).length > 1 && (
                 <div className="mb-2 sm:mb-3">
                   <label className={`block text-xs sm:text-sm font-medium mb-1 ${
                     showSponsorError ? 'text-red-500' : 'text-gray-700'
                   }`}>
                     {showSponsorError 
                       ? "Please choose your guest's sponsoring member" 
                       : "Sponsoring Member"}
                   </label>
                   <div className="flex flex-wrap gap-2">
                     {currentGroup.filter(p => !p.isGuest).map((member) => (
                       <button
                         key={member.id}
                         onClick={() => {
                           setGuestSponsor(member.memberNumber);
                           setShowSponsorError(false);
                         }}
                         className={`px-3 sm:px-4 py-1.5 sm:py-2 rounded-lg border-2 transition-colors text-xs sm:text-sm ${
                           guestSponsor === member.memberNumber
                             ? 'border-blue-500 bg-blue-50 text-blue-700'
                             : 'border-gray-300 bg-white text-gray-700 hover:border-gray-400'
                         }`}
                       >
                         {member.memberNumber === memberNumber ? "My Guest" : member.name}
                       </button>
                     ))}
                   </div>
                 </div>
               )}

               <div className="flex gap-2">
                 <button
                   onClick={async () => {
                     if (!validateGuestName(guestName)) {
                       setShowGuestNameError(true);
                       return;
                     }

                     // Check if sponsor is selected when multiple members exist
                     if (currentGroup.filter(p => !p.isGuest).length > 1 && !guestSponsor) {
                       setShowSponsorError(true);
                       return;
                     }

                     // Add guest to group
                     const guestId = -guestCounter;
                     setGuestCounter(guestCounter + 1);

                     const sponsorMember = guestSponsor || 
                       (currentGroup.filter(p => !p.isGuest)[0]?.memberNumber || memberNumber);

                     // Find the sponsor's details
                     const sponsorPlayer = currentGroup.find(p => p.memberNumber === sponsorMember) || 
                       (memberDatabase[sponsorMember]?.familyMembers[0]);

                     setCurrentGroup([...currentGroup, {
                       name: guestName.trim(),
                       memberNumber: "GUEST",
                       id: guestId,
                       phone: '',
                       ranking: null,
                       winRate: 0.5,
                       isGuest: true,
                       sponsor: sponsorMember
                     }]);

                     // Track guest charge
                     const guestCharge = {
                       id: Date.now(),
                       timestamp: new Date().toISOString(),
                       guestName: guestName.trim(),
                       sponsorName: sponsorPlayer?.name || 'Unknown',
                       sponsorNumber: sponsorMember,
                       amount: 15.00
                     };

                     console.log('🎾 Creating guest charge:', guestCharge);
                     
                     try {
                       // Get existing charges from localStorage
                       const existingChargesFromStorage = localStorage.getItem(TENNIS_CONFIG.STORAGE.GUEST_CHARGES_KEY);
                       const existingCharges = existingChargesFromStorage ? JSON.parse(existingChargesFromStorage) : [];
                       console.log('📋 Existing charges before save:', existingCharges.length);
                       
                       // Add new charge
                       existingCharges.push(guestCharge);
                       console.log('📋 Charges after adding new one:', existingCharges.length);
                       
                       // Save to localStorage
                       localStorage.setItem(TENNIS_CONFIG.STORAGE.GUEST_CHARGES_KEY, JSON.stringify(existingCharges));
                       console.log('💾 Guest charge saved to localStorage');
                       
                       // Dispatch event for real-time updates
                       if (USE_SHARED_CORE && Events) {
                         Events.emitDom(TENNIS_CONFIG.STORAGE.UPDATE_EVENT, {});
                       } else {
                         window.dispatchEvent(new Event(TENNIS_CONFIG.STORAGE.UPDATE_EVENT));
                       }
                       console.log('📡 Dispatched update event');
                       
                     } catch (error) {
                       console.error('❌ Error saving guest charge:', error);
                     }

                     // Reset form
                     setGuestName("");
                     setGuestSponsor("");
                     setShowGuestForm(false);
                     setShowAddPlayer(false);
                     setShowGuestNameError(false);
                     setShowSponsorError(false);
                   }}
                   className="bg-blue-500 text-white px-3 sm:px-4 py-1.5 sm:py-2 rounded-lg hover:bg-blue-600 transition-colors text-sm sm:text-base"
                 >
                   Add Guest
                 </button>
                 <button
                   onClick={() => {
                     setShowGuestForm(false);
                     setGuestName("");
                     setGuestSponsor("");
                     setShowGuestNameError(false);
                     setShowSponsorError(false);
                   }}
                   className="bg-gray-300 text-gray-700 px-3 sm:px-4 py-1.5 sm:py-2 rounded-lg hover:bg-gray-400 transition-colors text-sm sm:text-base"
                 >
                   Cancel
                 </button>
               </div>
             </div>
           )}

           {/* Frequent partners */}
           {memberNumber && frequentPartners && frequentPartners.length > 0 && currentGroup.length < CONSTANTS.MAX_PLAYERS && (
             <div className="p-3 sm:p-4 bg-yellow-50 rounded-xl">
               <div className="grid grid-cols-2 sm:grid-cols-3 gap-2 sm:gap-3">
                 {frequentPartners.slice(0, CONSTANTS.MAX_FREQUENT_PARTNERS).map((partner, idx) => {
                   const names = partner.player.name.split(' ');
                   const displayName = names.join(' ').length > 15 
                     ? `${names[0].charAt(0)}. ${names[1] || names[0]}`
                     : partner.player.name;
                   
                   return (
                     <button
                       key={idx}
                       onClick={() => addFrequentPartner(partner.player)}
                       disabled={isPlayerAlreadyPlaying(partner.player.id).isPlaying}
                       className="bg-white p-2 sm:p-3 rounded-lg hover:bg-yellow-100 transition-colors text-left disabled:opacity-50 disabled:cursor-not-allowed"
                     >
                       <div className="font-medium text-xs sm:text-sm">{displayName}</div>
                     </button>
                   );
                 })}
               </div>
             </div>
           )}
         </div>
         <div className="absolute bottom-4 sm:bottom-8 left-4 sm:left-8 right-4 sm:right-8 flex justify-between items-end gap-2 bottom-nav-buttons">
         <button
    onClick={() => {
      setCurrentGroup([]);
      setMemberNumber("");
      setCurrentScreen("search");
    }}
    className="bg-gray-300 text-gray-700 py-2 sm:py-3 px-3 sm:px-6 rounded-xl text-sm sm:text-lg hover:bg-gray-400 transition-colors"
  >
    Go Back
  </button>
  
  {currentGroup.length >= 1 && (
    <>
      {(() => {
        console.log("🎯 GROUP SCREEN BUTTON DEBUG:");
        console.log("  - availableCourts state:", availableCourts);
        console.log("  - availableCourts.length:", availableCourts.length);
        return availableCourts.length > 0;
      })() ? (
        <button
          onClick={() => {
            // Mobile: Skip court selection if we have a preselected court
            if (window.__mobileFlow && window.__preselectedCourt) {
              assignCourtToGroup(window.__preselectedCourt);
            } else {
              setCurrentScreen("court");
            }
          }}
          className="bg-blue-500 text-white py-2 sm:py-4 px-4 sm:px-8 rounded-xl text-base sm:text-xl hover:bg-blue-600 transition-colors"
        >
          {window.__mobileFlow && window.__preselectedCourt ? `Register for Court ${window.__preselectedCourt}` : 'Select a Court'}
        </button>
      ) : (
        <button
          onClick={() => {
            sendGroupToWaitlist(currentGroup);
            setShowSuccess(true);
            // Mobile: notify parent on success
            if (window.__mobileSuccessHandler) {
              window.__mobileSuccessHandler(null); // waitlist doesn't have court
            }
            // Mobile: trigger success signal
            if (window.UI?.__mobileSendSuccess__) {
              window.UI.__mobileSendSuccess__();
            }
            
            // Don't auto-reset in mobile flow - let the overlay handle timing
            if (!window.__mobileFlow) {
              setTimeout(() => {
                resetForm();
              }, CONSTANTS.AUTO_RESET_SUCCESS_MS);
            }
          }}
          className="bg-orange-500 text-white py-2 sm:py-4 px-4 sm:px-8 rounded-xl text-base sm:text-xl hover:bg-orange-600 transition-colors"
        >
          Join Waitlist
        </button>
      )}
    </>
  )}
  
  <button
    onClick={resetForm}
    className="bg-red-500 text-white py-2 sm:py-3 px-3 sm:px-6 rounded-xl text-sm sm:text-lg hover:bg-red-600 transition-colors"
  >
    Start Over
  </button>
</div>

<div id="etaPreview"
     aria-live="polite"
     style={{marginTop: '8px', fontSize: '0.95rem', opacity: '0.9'}}>
</div>


       </div>
     </div>
   );
 }

 // Court selection screen
 if (currentScreen === "court") {
   // When a group has already been assigned a court, treat it like changing courts
   const isSelectingDifferentCourt = isChangingCourt || hasAssignedCourt;
   
   const data = getCourtData();
   
   // Check if we should bypass waitlist priority (when only overtime courts are available)
   const shouldBypassWaitlistPriority = (() => {
     if (isSelectingDifferentCourt) return true; // Always bypass when changing courts
     
     // For new registrations, check if only overtime courts are available
     const tempAvailableCourts = getAvailableCourts(false); // Get courts without waitlist check
     const hasUnoccupiedCourts = data.courts.some(court => !court);
     
     // If there are available courts but no unoccupied courts, these must be overtime courts
     return tempAvailableCourts.length > 0 && !hasUnoccupiedCourts;
   })();
   
   const availableCourts = getAvailableCourts(
     !shouldBypassWaitlistPriority, 
     isSelectingDifferentCourt && wasOvertimeCourt,
     isSelectingDifferentCourt ? justAssignedCourt : null  // Pass the court to exclude
   ) || [];
   
   
   const hasWaitingGroups = data.waitingGroups.length > 0;
   const isFirstInWaitlist = currentGroup.some(player => isPlayerNextInWaitlist(player.id));
   
   // Check if showing overtime courts
   const hasUnoccupiedCourts = data.courts.some((court, index) => {
     const courtNumber = index + 1;
     
     // Check if court is blocked
     const blockStatus = getCourtBlockStatus(courtNumber);
     if (blockStatus && blockStatus.isCurrent) {
       return false; // Blocked courts are not unoccupied
     }
     
     // Check various conditions for an unoccupied court
     return !court || // No court data
            court.wasCleared || // Court was cleared
            (court.current === null && court.history) || // New structure with cleared court
            ((!court.players || court.players.length === 0) && 
             (!court.current || !court.current.players || court.current.players.length === 0)); // No players in either structure
   });
   const showingOvertimeCourts = availableCourts.length > 0 && !hasUnoccupiedCourts && !isSelectingDifferentCourt;
   
   
   return (
     <>
       <AlertDisplay show={showAlert} message={alertMessage} />
       <CourtSelectionScreen
         availableCourts={availableCourts}
         showingOvertimeCourts={showingOvertimeCourts}
         hasWaitingGroups={hasWaitingGroups}
         waitingGroupsCount={data.waitingGroups.length}
         onCourtSelect={async (courtNum) => {
           const DEBUG_SELECT = false;
           if (DEBUG_SELECT) console.log('[SelectCourt] clicked', { courtNumber: courtNum });
           
           // If changing courts, clear the original court first but skip adding to recentlyCleared
           if (isChangingCourt && justAssignedCourt) {
             await TennisDataService.clearCourt(justAssignedCourt, true);
           }
           await assignCourtToGroup(courtNum);
           setIsChangingCourt(false);
           setWasOvertimeCourt(false);
         }}
         onJoinWaitlist={async () => {
           await sendGroupToWaitlist(currentGroup);
           setShowSuccess(true);
           // Mobile: notify parent on success
           if (window.__mobileSuccessHandler) {
             window.__mobileSuccessHandler(null); // waitlist doesn't have court
           }
           // Mobile: trigger success signal
           if (window.UI?.__mobileSendSuccess__) {
             window.UI.__mobileSendSuccess__();
           }
           // Don't auto-reset in mobile flow - let the overlay handle timing
           if (!window.__mobileFlow) {
             setTimeout(() => {
               resetForm();
             }, CONSTANTS.AUTO_RESET_SUCCESS_MS);
           }
         }}
         onGoBack={() => {
           setCurrentScreen("group");
           setIsChangingCourt(false);
           setWasOvertimeCourt(false);
           // If we were changing courts and had replaced an overtime court, restore it
           if (isChangingCourt && justAssignedCourt && originalCourtData) {
             try {
               const data = getCourtData();
               data.courts[justAssignedCourt - 1] = originalCourtData;
               saveCourtData(data);
               setOriginalCourtData(null);
             } catch (error) {
               console.error('Failed to restore court:', error);
             }
           }
         }}
         onStartOver={resetForm}
       />
     </>
   );
 }

 // Clear court screen
 if (currentScreen === "clearCourt") {
   const clearableCourts = getCourtsOccupiedForClearing();
   const hasAny = clearableCourts.length > 0;
   const data = window.Tennis.Storage.readDataSafe();
   const occupiedCourts = clearableCourts.map(courtNumber => ({
     courtNumber,
     players: data?.courts?.[courtNumber - 1]?.current?.players || data?.courts?.[courtNumber - 1]?.players || [],
     isBlocked: false
   }));

   if (clearCourtStep === 1) {
     return (
       <div className="w-full h-full min-h-screen bg-gradient-to-br from-green-50 to-blue-50 p-4 sm:p-8 flex items-center justify-center">
         <AlertDisplay show={showAlert} message={alertMessage} />
         <div className="bg-white rounded-2xl shadow-2xl p-4 sm:p-8 w-full max-w-4xl">
           <h2 className="text-2xl sm:text-3xl font-bold text-center mb-6 sm:mb-8">Choose a court to clear</h2>
           
           {hasAny ? (
             <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 sm:gap-6 mb-6 sm:mb-8">
               {occupiedCourts.map(({ courtNumber }) => (
                 <button
                   key={courtNumber}
                   onClick={() => {
                     setSelectedCourtToClear(courtNumber);
                     setClearCourtStep(2);
                   }}
                   className="p-6 sm:p-8 rounded-xl text-xl sm:text-2xl font-bold bg-gradient-to-r from-blue-400 to-blue-500 text-white hover:from-blue-500 hover:to-blue-600 transition-all transform hover:scale-105 shadow-lg"
                 >
                   Court {courtNumber}
                 </button>
               ))}
             </div>
           ) : (
             <p className="text-center text-lg sm:text-xl text-gray-600 mb-6 sm:mb-8">No courts are currently in use.</p>
           )}
           
           <div className="flex justify-center">
             <button
               onClick={() => setCurrentScreen("welcome")}
               className="bg-gray-300 text-gray-700 py-2 sm:py-3 px-4 sm:px-6 rounded-xl text-base sm:text-lg hover:bg-gray-400 transition-colors"
             >
               Go Back
             </button>
           </div>
         </div>
       </div>
     );
   }

   if (clearCourtStep === 2) {
     const court = data.courts[selectedCourtToClear - 1];
     const players = court.current?.players || court.players || [];
     const displayNames = players.map(p => TennisBusinessLogic.formatPlayerDisplayName(p.name)).join(" and ");
     
     return (
       <div className="w-full h-full min-h-screen bg-gradient-to-br from-green-50 to-blue-50 p-4 sm:p-8 flex items-center justify-center">
         <AlertDisplay show={showAlert} message={alertMessage} />
         <div className="bg-white rounded-2xl shadow-2xl p-4 sm:p-8 w-full max-w-3xl">
           <div className="mb-6 sm:mb-8 text-center">
             <h2 className="text-2xl sm:text-3xl font-bold mb-2">Court {selectedCourtToClear}</h2>
             <p className="text-xl sm:text-2xl text-gray-600">{displayNames}</p>
           </div>
           
           <div className="space-y-4 sm:space-y-8 mb-6 sm:mb-8">
             <button

             onClick={async () => {
                 await clearCourt(selectedCourtToClear);
                 console.log(`Clearing court ${selectedCourtToClear} - players leaving`);
                 setClearCourtStep(3); // Success screen for players leaving
            }} 

               className="w-full bg-green-500 text-white py-3 sm:py-4 px-6 sm:px-8 rounded-xl text-lg sm:text-xl font-semibold hover:bg-green-600 transition-colors"
             >
               We are finished our game and leaving court {selectedCourtToClear}
             </button>
             
             <button
               onClick={async () => {
                 await clearCourt(selectedCourtToClear);
                 console.log(`Clearing court ${selectedCourtToClear} - observed empty`);
                 setClearCourtStep(4); // Success screen for observed empty
               }}
               className="w-full bg-blue-500 text-white py-3 sm:py-4 px-6 sm:px-8 rounded-xl text-lg sm:text-xl font-semibold hover:bg-blue-600 transition-colors"
             >
               Players have finished and court {selectedCourtToClear} is open (I'm sure!)
             </button>
           </div>
           
           <div className="flex flex-col sm:flex-row justify-between gap-3">
             <button
               onClick={() => setClearCourtStep(1)}
               className="bg-gray-300 text-gray-700 py-2 sm:py-3 px-4 sm:px-6 rounded-xl text-base sm:text-lg hover:bg-gray-400 transition-colors order-2 sm:order-1"
             >
               Go Back
             </button>
             
             <button
               onClick={() => {
                 resetForm();
                 setCurrentScreen("welcome");
               }}
               className="bg-red-500 text-white py-2 sm:py-3 px-4 sm:px-6 rounded-xl text-base sm:text-lg hover:bg-red-600 transition-colors order-1 sm:order-2"
             >
               Start Over
             </button>
           </div>
         </div>
       </div>
     );
   }

   if (clearCourtStep === 3) {
     setTimeout(() => {
       resetForm();
     }, CONSTANTS.AUTO_RESET_CLEAR_MS);
     
     return (
       <div className="w-full h-full min-h-screen bg-gradient-to-br from-green-50 to-blue-50 flex items-center justify-center p-4">
         <div className="bg-white rounded-3xl p-8 sm:p-16 shadow-2xl text-center max-w-2xl">
           <div className="w-24 h-24 sm:w-32 sm:h-32 bg-green-500 rounded-full flex items-center justify-center mx-auto mb-6 sm:mb-8">
             <Check size={48} className="text-white sm:w-16 sm:h-16" />
           </div>
           <h1 className="text-3xl sm:text-4xl font-bold mb-4">Thanks, have a great day!</h1>
           <p className="text-lg sm:text-xl text-gray-600">Court {selectedCourtToClear} is now available</p>
         </div>
       </div>
     );
   }

   if (clearCourtStep === 4) {
     setTimeout(() => {
       resetForm();
     }, CONSTANTS.AUTO_RESET_CLEAR_MS);
     
     return (
       <div className="w-full h-full min-h-screen bg-gradient-to-br from-green-50 to-blue-50 flex items-center justify-center p-4">
         <div className="bg-white rounded-3xl p-8 sm:p-16 shadow-2xl text-center max-w-2xl">
           <div className="w-24 h-24 sm:w-32 sm:h-32 bg-green-500 rounded-full flex items-center justify-center mx-auto mb-6 sm:mb-8">
             <Check size={48} className="text-white sm:w-16 sm:h-16" />
           </div>
           <h1 className="text-3xl sm:text-4xl font-bold mb-4">Thank you!</h1>
           <p className="text-lg sm:text-xl text-gray-600">Court {selectedCourtToClear} is now available</p>
         </div>
       </div>
     );
   }
 }

 return null;
};
 
// Mount the app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<TennisRegistration />);
 </script>

  <!-- Debug Panel - Only visible when ?debug=1 -->
  <script>
  (function() {
    const params = new URLSearchParams(location.search);
    if (params.get('debug') !== '1') return;

    const debugPanel = document.createElement('div');
    debugPanel.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      width: 320px;
      max-height: 400px;
      background: rgba(0, 0, 0, 0.85);
      color: #0f0;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      padding: 10px;
      border-radius: 4px;
      overflow-y: auto;
      z-index: 99999;
      pointer-events: none;
      border: 1px solid #0f0;
    `;
    debugPanel.innerHTML = '<div style="color: #ff0; margin-bottom: 5px;">DEBUG MODE - Events Log</div><div id="debugContent"></div>';
    document.body.appendChild(debugPanel);

    const updateDebugPanel = () => {
      if (!window.Tennis || !window.Tennis.Events || !window.Tennis.Events.debug) return;
      
      const events = window.Tennis.Events.debug.getLog();
      const content = document.getElementById('debugContent');
      if (!content) return;

      content.innerHTML = events.map((event, i) => {
        const time = new Date(event.timestamp).toLocaleTimeString();
        return `<div style="margin-bottom: 5px; padding-bottom: 5px; border-bottom: 1px solid #333;">
          <div style="color: #ff0;">[${time}] ${event.type}</div>
          <div style="color: #0ff;">${event.eventName}</div>
          ${event.data ? `<div style="color: #fff; font-size: 10px;">${JSON.stringify(event.data, null, 2)}</div>` : ''}
        </div>`;
      }).join('');
    };

    // Update every 500ms
    setInterval(updateDebugPanel, 500);
    
    // Initial update
    setTimeout(updateDebugPanel, 100);
  })();
  </script>
</body>
</html>